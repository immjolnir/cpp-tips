typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef struct {
    long long __clang_max_align_nonce1 __attribute__((aligned(__alignof(long long))));
    long double __clang_max_align_nonce2 __attribute__((aligned(__alignof(long double))));
} max_align_t;
namespace std {
    typedef unsigned long size_t;
    typedef long ptrdiff_t;
    typedef decltype(nullptr) nullptr_t;
    extern "C++" inline void __terminate() noexcept __attribute__((always_inline)) {
        void terminate() noexcept;
        terminate();
    }

}
namespace std {
    inline namespace __cxx11 {
    }
}
namespace __gnu_cxx {
    inline namespace __cxx11 {
    }
}
namespace std {
    inline constexpr bool __is_constant_evaluated() noexcept {
        return __builtin_is_constant_evaluated();
    }
}
namespace __cxxabiv1 {
    extern "C" {
        typedef int __guard __attribute__((mode(__DI__)));
        typedef void __cxa_vec_ctor_return_type;
        typedef void __cxa_cdtor_return_type;
    }
}
namespace __cxxabiv1 {
    class __forced_unwind {
        virtual ~__forced_unwind() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace std {
    class type_info;
}
namespace __cxxabiv1 {
    struct __cxa_refcounted_exception;
    extern "C" {
        void *__cxa_allocate_exception(size_t) noexcept;
        void __cxa_free_exception(void *) noexcept;
        __cxxabiv1::__cxa_refcounted_exception *__cxa_init_primary_exception(void *object, std::type_info *tinfo, void (*dest)(void *)) noexcept;
    }
}
namespace __cxxabiv1 {
    extern "C" {
        typedef __cxxabiv1::__cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);
        void *__cxa_vec_new(size_t __element_count, size_t __element_size, size_t __padding_size, __cxxabiv1::__cxa_cdtor_type __constructor, __cxxabiv1::__cxa_cdtor_type __destructor);
        void *__cxa_vec_new2(size_t __element_count, size_t __element_size, size_t __padding_size, __cxxabiv1::__cxa_cdtor_type __constructor, __cxxabiv1::__cxa_cdtor_type __destructor, void *(*__alloc)(size_t), void (*__dealloc)(void *));
        void *__cxa_vec_new3(size_t __element_count, size_t __element_size, size_t __padding_size, __cxxabiv1::__cxa_cdtor_type __constructor, __cxxabiv1::__cxa_cdtor_type __destructor, void *(*__alloc)(size_t), void (*__dealloc)(void *, size_t));
        __cxxabiv1::__cxa_vec_ctor_return_type __cxa_vec_ctor(void *__array_address, size_t __element_count, size_t __element_size, __cxxabiv1::__cxa_cdtor_type __constructor, __cxxabiv1::__cxa_cdtor_type __destructor);
        __cxxabiv1::__cxa_vec_ctor_return_type __cxa_vec_cctor(void *__dest_array, void *__src_array, size_t __element_count, size_t __element_size, __cxxabiv1::__cxa_cdtor_return_type (*__constructor)(void *, void *), __cxxabiv1::__cxa_cdtor_type __destructor);
        void __cxa_vec_dtor(void *__array_address, size_t __element_count, size_t __element_size, __cxxabiv1::__cxa_cdtor_type __destructor);
        void __cxa_vec_cleanup(void *__array_address, size_t __element_count, size_t __s, __cxxabiv1::__cxa_cdtor_type __destructor) noexcept;
        void __cxa_vec_delete(void *__array_address, size_t __element_size, size_t __padding_size, __cxxabiv1::__cxa_cdtor_type __destructor);
        void __cxa_vec_delete2(void *__array_address, size_t __element_size, size_t __padding_size, __cxxabiv1::__cxa_cdtor_type __destructor, void (*__dealloc)(void *));
        void __cxa_vec_delete3(void *__array_address, size_t __element_size, size_t __padding_size, __cxxabiv1::__cxa_cdtor_type __destructor, void (*__dealloc)(void *, size_t));
        int __cxa_guard_acquire(__cxxabiv1::__guard *);
        void __cxa_guard_release(__cxxabiv1::__guard *) noexcept;
        void __cxa_guard_abort(__cxxabiv1::__guard *) noexcept;
        int __cxa_atexit(void (*)(void *), void *, void *) noexcept;
        void __cxa_finalize(void *);
        int __cxa_thread_atexit(void (*)(void *), void *, void *) noexcept;
        void __cxa_pure_virtual();
        void __cxa_deleted_virtual();
        void __cxa_bad_cast();
        void __cxa_bad_typeid();
        void __cxa_throw_bad_array_new_length();
        char *__cxa_demangle(const char *__mangled_name, char *__output_buffer, size_t *__length, int *__status);
    }
}
extern "C++" {
    namespace std {
        class exception {
        public:
            exception() noexcept {
            }
            virtual ~exception() noexcept;
            exception(const std::exception &) noexcept = default            std::exception &operator=(const std::exception &) = default
            exception(std::exception &&) noexcept = default            std::exception &operator=(std::exception &&) = default
            virtual const char *what() const noexcept;
        };
    }
}
namespace std {
    std::size_t _Hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
    std::size_t _Fnv_hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
}
extern "C++" {
    namespace __cxxabiv1 {
        class __class_type_info;
    }
    namespace std {
        class type_info {
        public:
            virtual ~type_info() noexcept;
            const char *name() const noexcept {
                return this->__name[0] == '*' ? this->__name + 1 : this->__name;
            }
            bool before(const std::type_info &__arg) const noexcept;
            bool operator==(const std::type_info &__arg) const noexcept;
            bool operator!=(const std::type_info &__arg) const noexcept {
                return !this->operator==(__arg);
            }
            std::size_t hash_code() const noexcept {
                return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast<std::size_t>(3339675911UL));
            }
            virtual bool __is_pointer_p() const;
            virtual bool __is_function_p() const;
            virtual bool __do_catch(const std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
            virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target, void **__obj_ptr) const;
        protected:
            const char *__name;
            explicit type_info(const char *__n) : __name(__n) {
            }
        private:
            std::type_info &operator=(const std::type_info &) = delete
            type_info(const std::type_info &) = delete
        };
        inline bool type_info::before(const std::type_info &__arg) const noexcept {
            if (this->__name[0] != '*' || __arg.__name[0] != '*')
                return __builtin_strcmp(this->__name, __arg.__name) < 0;
            return this->__name < __arg.__name;
        }
        inline bool type_info::operator==(const std::type_info &__arg) const noexcept {
            if (std::__is_constant_evaluated())
                return this == &__arg;
            if (this->__name == __arg.__name)
                return true;
            return this->__name[0] != '*' && __builtin_strcmp(this->__name, __arg.name()) == 0;
        }
        class bad_cast : public std::exception {
        public:
            bad_cast() noexcept : std::exception() {
            }
            virtual ~bad_cast() noexcept;
            virtual const char *what() const noexcept;
        };
        class bad_typeid : public std::exception {
        public:
            bad_typeid() noexcept : std::exception() {
            }
            virtual ~bad_typeid() noexcept;
            virtual const char *what() const noexcept;
        };
    }
}
namespace __cxxabiv1 {
    class __fundamental_type_info : public std::type_info {
    public:
        explicit __fundamental_type_info(const char *__n) : std::type_info(__n) {
        }
        virtual ~__fundamental_type_info() noexcept;
    };
    class __array_type_info : public std::type_info {
    public:
        explicit __array_type_info(const char *__n) : std::type_info(__n) {
        }
        virtual ~__array_type_info() noexcept;
    };
    class __function_type_info : public std::type_info {
    public:
        explicit __function_type_info(const char *__n) : std::type_info(__n) {
        }
        virtual ~__function_type_info() noexcept;
    protected:
        virtual bool __is_function_p() const;
    };
    class __enum_type_info : public std::type_info {
    public:
        explicit __enum_type_info(const char *__n) : std::type_info(__n) {
        }
        virtual ~__enum_type_info() noexcept;
    };
    class __pbase_type_info : public std::type_info {
    public:
        unsigned int __flags;
        const std::type_info *__pointee;
        explicit __pbase_type_info(const char *__n, int __quals, const std::type_info *__type) : std::type_info(__n), __flags(__quals), __pointee(__type) {
        }
        virtual ~__pbase_type_info() noexcept;
        enum __masks {
            __const_mask = 1,
            __volatile_mask = 2,
            __restrict_mask = 4,
            __incomplete_mask = 8,
            __incomplete_class_mask = 16,
            __transaction_safe_mask = 32,
            __noexcept_mask = 64
        };
    protected:
        __pbase_type_info(const __cxxabiv1::__pbase_type_info &);
        __cxxabiv1::__pbase_type_info &operator=(const __cxxabiv1::__pbase_type_info &);
        virtual bool __do_catch(const std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
        inline virtual bool __pointer_catch(const __cxxabiv1::__pbase_type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
    };
    inline bool __pbase_type_info::__pointer_catch(const __cxxabiv1::__pbase_type_info *thrown_type, void **thr_obj, unsigned int outer) const {
        return this->__pointee->__do_catch(thrown_type->__pointee, thr_obj, outer + 2);
    }
    class __pointer_type_info : public __cxxabiv1::__pbase_type_info {
    public:
        explicit __pointer_type_info(const char *__n, int __quals, const std::type_info *__type) : __cxxabiv1::__pbase_type_info(__n, __quals, __type) {
        }
        virtual ~__pointer_type_info() noexcept;
    protected:
        virtual bool __is_pointer_p() const;
        virtual bool __pointer_catch(const __cxxabiv1::__pbase_type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
    };
    class __class_type_info;
    class __pointer_to_member_type_info : public __cxxabiv1::__pbase_type_info {
    public:
        __cxxabiv1::__class_type_info *__context;
        explicit __pointer_to_member_type_info(const char *__n, int __quals, const std::type_info *__type, __cxxabiv1::__class_type_info *__klass) : __cxxabiv1::__pbase_type_info(__n, __quals, __type), __context(__klass) {
        }
        virtual ~__pointer_to_member_type_info() noexcept;
    protected:
        __pointer_to_member_type_info(const __cxxabiv1::__pointer_to_member_type_info &);
        __cxxabiv1::__pointer_to_member_type_info &operator=(const __cxxabiv1::__pointer_to_member_type_info &);
        virtual bool __pointer_catch(const __cxxabiv1::__pbase_type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
    };
    class __base_class_type_info {
    public:
        const __cxxabiv1::__class_type_info *__base_type;
        long __offset_flags;
        enum __offset_flags_masks {
            __virtual_mask = 1,
            __public_mask = 2,
            __hwm_bit = 2,
            __offset_shift = 8
        };
        bool __is_virtual_p() const {
            return this->__offset_flags & __virtual_mask;
        }
        bool __is_public_p() const {
            return this->__offset_flags & __public_mask;
        }
        ptrdiff_t __offset() const {
            return static_cast<ptrdiff_t>(this->__offset_flags) >> __offset_shift;
        }
    };
    class __class_type_info : public std::type_info {
    public:
        explicit __class_type_info(const char *__n) : std::type_info(__n) {
        }
        virtual ~__class_type_info() noexcept;
        enum __sub_kind {
            __unknown = 0,
            __not_contained,
            __contained_ambig,
            __contained_virtual_mask = __base_class_type_info::__virtual_mask,
            __contained_public_mask = __base_class_type_info::__public_mask,
            __contained_mask = 1 << __base_class_type_info::__hwm_bit,
            __contained_private = __contained_mask,
            __contained_public = __contained_mask | __contained_public_mask
        };
        struct __upcast_result;
        struct __dyncast_result;
    protected:
        virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__dst_type, void **__obj_ptr) const;
        virtual bool __do_catch(const std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
    public:
        virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__dst, const void *__obj, __cxxabiv1::__class_type_info::__upcast_result &__restrict __result) const;
        inline __cxxabiv1::__class_type_info::__sub_kind __find_public_src(ptrdiff_t __src2dst, const void *__obj_ptr, const __cxxabiv1::__class_type_info *__src_type, const void *__src_ptr) const;
        virtual bool __do_dyncast(ptrdiff_t __src2dst, __cxxabiv1::__class_type_info::__sub_kind __access_path, const __cxxabiv1::__class_type_info *__dst_type, const void *__obj_ptr, const __cxxabiv1::__class_type_info *__src_type, const void *__src_ptr, __cxxabiv1::__class_type_info::__dyncast_result &__result) const;
        virtual __cxxabiv1::__class_type_info::__sub_kind __do_find_public_src(ptrdiff_t __src2dst, const void *__obj_ptr, const __cxxabiv1::__class_type_info *__src_type, const void *__src_ptr) const;
    };
    class __si_class_type_info : public __cxxabiv1::__class_type_info {
    public:
        const __cxxabiv1::__class_type_info *__base_type;
        explicit __si_class_type_info(const char *__n, const __cxxabiv1::__class_type_info *__base) : __cxxabiv1::__class_type_info(__n), __base_type(__base) {
        }
        virtual ~__si_class_type_info() noexcept;
    protected:
        __si_class_type_info(const __cxxabiv1::__si_class_type_info &);
        __cxxabiv1::__si_class_type_info &operator=(const __cxxabiv1::__si_class_type_info &);
        virtual bool __do_dyncast(ptrdiff_t __src2dst, __cxxabiv1::__class_type_info::__sub_kind __access_path, const __cxxabiv1::__class_type_info *__dst_type, const void *__obj_ptr, const __cxxabiv1::__class_type_info *__src_type, const void *__src_ptr, __cxxabiv1::__class_type_info::__dyncast_result &__result) const;
        virtual __cxxabiv1::__class_type_info::__sub_kind __do_find_public_src(ptrdiff_t __src2dst, const void *__obj_ptr, const __cxxabiv1::__class_type_info *__src_type, const void *__sub_ptr) const;
        virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__dst, const void *__obj, __cxxabiv1::__class_type_info::__upcast_result &__restrict __result) const;
    };
    class __vmi_class_type_info : public __cxxabiv1::__class_type_info {
    public:
        unsigned int __flags;
        unsigned int __base_count;
        __cxxabiv1::__base_class_type_info __base_info[1];
        explicit __vmi_class_type_info(const char *__n, int ___flags) : __cxxabiv1::__class_type_info(__n), __flags(___flags), __base_count(0), __base_info() {
        }
        virtual ~__vmi_class_type_info() noexcept;
        enum __flags_masks {
            __non_diamond_repeat_mask = 1,
            __diamond_shaped_mask = 2,
            __flags_unknown_mask = 16
        };
    protected:
        virtual bool __do_dyncast(ptrdiff_t __src2dst, __cxxabiv1::__class_type_info::__sub_kind __access_path, const __cxxabiv1::__class_type_info *__dst_type, const void *__obj_ptr, const __cxxabiv1::__class_type_info *__src_type, const void *__src_ptr, __cxxabiv1::__class_type_info::__dyncast_result &__result) const;
        virtual __cxxabiv1::__class_type_info::__sub_kind __do_find_public_src(ptrdiff_t __src2dst, const void *__obj_ptr, const __cxxabiv1::__class_type_info *__src_type, const void *__src_ptr) const;
        virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__dst, const void *__obj, __cxxabiv1::__class_type_info::__upcast_result &__restrict __result) const;
    };
    struct __cxa_exception;
    struct __cxa_refcounted_exception;
    struct __cxa_dependent_exception;
    struct __cxa_eh_globals;
    extern "C" {
        void *__dynamic_cast(const void *__src_ptr, const __cxxabiv1::__class_type_info *__src_type, const __cxxabiv1::__class_type_info *__dst_type, ptrdiff_t __src2dst);
        __cxxabiv1::__cxa_eh_globals *__cxa_get_globals() noexcept __attribute__((const));
        __cxxabiv1::__cxa_eh_globals *__cxa_get_globals_fast() noexcept __attribute__((const));
        void __cxa_free_exception(void *) noexcept;
        void __cxa_throw(void *, std::type_info *, void (*)(void *));
        void *__cxa_get_exception_ptr(void *) noexcept __attribute__((pure));
        void *__cxa_begin_catch(void *) noexcept;
        void __cxa_end_catch();
        void __cxa_rethrow();
        std::type_info *__cxa_current_exception_type() noexcept __attribute__((pure));
        __cxxabiv1::__cxa_dependent_exception *__cxa_allocate_dependent_exception() noexcept;
        void __cxa_free_dependent_exception(__cxxabiv1::__cxa_dependent_exception *) noexcept;
    }
    class __foreign_exception {
        virtual ~__foreign_exception() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace abi = __cxxabiv1;
namespace __gnu_cxx {
    class recursive_init_error : public std::exception {
    public:
        recursive_init_error() noexcept;
        virtual ~recursive_init_error() noexcept;
    };
}
namespace std {
    template <typename> class allocator
    template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        template <typename _Tp1> struct rebind;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        allocator() noexcept : __allocator_base<char16_t>() {
        }
        allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a) {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char16_t>(const allocator<char16_t> &) noexcept;
        ~allocator<char16_t>() noexcept {
        }
        friend bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
        friend bool operator!=(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    }
    template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        template <typename _Tp1> struct rebind;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        allocator() noexcept : __allocator_base<char32_t>() {
        }
        allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a) {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char32_t>(const allocator<char32_t> &) noexcept;
        ~allocator<char32_t>() noexcept {
        }
        friend bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
        friend bool operator!=(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    };
    template<> class allocator<void>;
    template <typename, typename> struct uses_allocator;
    template <typename> struct allocator_traits
    template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<std::allocator<char>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char>>::size_type max_size(const std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused))) noexcept {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char>>::allocator_type &__rhs) {
            return __rhs;
        }
    }
    template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n);
        static std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<std::allocator<wchar_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<wchar_t>>::size_type max_size(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static std::allocator_traits<std::allocator<wchar_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__rhs);
    }
    template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char16_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char16_t>>::size_type max_size(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused))) noexcept {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char16_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__rhs);
    }
    template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char32_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char32_t>>::size_type max_size(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused))) noexcept {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char32_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__rhs);
    };
}
namespace std {
    template <class _CharT> struct char_traits;
    template<> struct char_traits<char>;
    template<> struct char_traits<wchar_t>;
    template<> struct char_traits<char16_t>;
    template<> struct char_traits<char32_t>;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string
        template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::basic_string<char16_t>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::basic_string<char16_t>::size_type npos = static_cast<std::basic_string<char16_t>::size_type>(-1);
        protected:
            typedef std::basic_string<char16_t>::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::basic_string<char16_t>::allocator_type {
                std::basic_string<char16_t>::pointer _M_p;
            };
            std::basic_string<char16_t>::_Alloc_hider _M_dataplus;
            std::basic_string<char16_t>::size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::basic_string<char16_t>::size_type _M_allocated_capacity;
            };
            void _M_data(std::basic_string<char16_t>::pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::basic_string<char16_t>::size_type __length) {
                this->_M_string_length = __length;
            }
            std::basic_string<char16_t>::pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            std::basic_string<char16_t>::pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::basic_string<char16_t>::const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::basic_string<char16_t>::size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::basic_string<char16_t>::size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            bool _M_is_local() const {
                return this->_M_data() == this->_M_local_data();
            }
            std::basic_string<char16_t>::pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_create(std::basic_string<char16_t>::size_type &__capacity, std::basic_string<char16_t>::size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::basic_string<char16_t>::size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag) {
                std::basic_string<char16_t>::size_type __dnew = static_cast<std::basic_string<char16_t>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::basic_string<char16_t>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::basic_string<char16_t>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char16_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::basic_string<char16_t>::size_type __req, char16_t __c);
            std::basic_string<char16_t>::allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            const std::basic_string<char16_t>::allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr std::basic_string<char16_t>::pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                return this->_M_local_data();
            }
        private:
            std::basic_string<char16_t>::size_type _M_check(std::basic_string<char16_t>::size_type __pos, const char *__s) const;
            void _M_check_length(std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2, const char *__s) const;
            std::basic_string<char16_t>::size_type _M_limit(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static void _S_copy(char16_t *__d, const char16_t *__s, std::basic_string<char16_t>::size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char16_t *__d, const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            static void _S_assign(char16_t *__d, std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _Iterator> static void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static void _S_copy_chars(char16_t *__p, std::basic_string<char16_t>::iterator __k1, std::basic_string<char16_t>::iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, std::basic_string<char16_t>::const_iterator __k1, std::basic_string<char16_t>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2) noexcept;
            void _M_assign(const std::basic_string<char16_t> &);
            void _M_mutate(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __len1, const char16_t *__s, std::basic_string<char16_t>::size_type __len2);
            void _M_erase(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            basic_string(const std::basic_string<char16_t> &__str);
            basic_string(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, const std::allocator<char16_t> &__a);
            basic_string(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            basic_string(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, const std::allocator<char16_t> &__a);
            basic_string(const char16_t *__s, std::basic_string<char16_t>::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            basic_string(std::basic_string<char16_t>::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            basic_string(std::basic_string<char16_t> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            basic_string(const std::basic_string<char16_t> &__str, const std::allocator<char16_t> &__a);
            basic_string(std::basic_string<char16_t> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            ~basic_string<char16_t>() noexcept {
                this->_M_dispose();
            }
            std::basic_string<char16_t> &operator=(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &operator=(const char16_t *__s);
            std::basic_string<char16_t> &operator=(char16_t __c);
            std::basic_string<char16_t> &operator=(std::basic_string<char16_t> &&__str);
            std::basic_string<char16_t> &operator=(initializer_list<char16_t> __l);
            std::basic_string<char16_t>::iterator begin() noexcept;
            std::basic_string<char16_t>::const_iterator begin() const noexcept;
            std::basic_string<char16_t>::iterator end() noexcept;
            std::basic_string<char16_t>::const_iterator end() const noexcept;
            std::basic_string<char16_t>::reverse_iterator rbegin() noexcept;
            std::basic_string<char16_t>::const_reverse_iterator rbegin() const noexcept;
            std::basic_string<char16_t>::reverse_iterator rend() noexcept;
            std::basic_string<char16_t>::const_reverse_iterator rend() const noexcept;
            std::basic_string<char16_t>::const_iterator cbegin() const noexcept;
            std::basic_string<char16_t>::const_iterator cend() const noexcept;
            std::basic_string<char16_t>::const_reverse_iterator crbegin() const noexcept;
            std::basic_string<char16_t>::const_reverse_iterator crend() const noexcept;
        public:
            std::basic_string<char16_t>::size_type size() const noexcept;
            std::basic_string<char16_t>::size_type length() const noexcept {
                return this->_M_string_length;
            }
            std::basic_string<char16_t>::size_type max_size() const noexcept {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::basic_string<char16_t>::size_type __n, char16_t __c);
            void resize(std::basic_string<char16_t>::size_type __n);
            void shrink_to_fit() noexcept;
            std::basic_string<char16_t>::size_type capacity() const noexcept;
            void reserve(std::basic_string<char16_t>::size_type __res_arg);
            void reserve();
            void clear() noexcept;
            bool empty() const noexcept;
            std::basic_string<char16_t>::const_reference operator[](std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::reference operator[](std::basic_string<char16_t>::size_type __pos);
            std::basic_string<char16_t>::const_reference at(std::basic_string<char16_t>::size_type __n) const;
            std::basic_string<char16_t>::reference at(std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t>::reference front() noexcept;
            std::basic_string<char16_t>::const_reference front() const noexcept;
            std::basic_string<char16_t>::reference back() noexcept;
            std::basic_string<char16_t>::const_reference back() const noexcept;
            std::basic_string<char16_t> &operator+=(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &operator+=(const char16_t *__s);
            std::basic_string<char16_t> &operator+=(char16_t __c);
            std::basic_string<char16_t> &operator+=(initializer_list<char16_t> __l);
            std::basic_string<char16_t> &append(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &append(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &append(const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &append(const char16_t *__s);
            std::basic_string<char16_t> &append(std::basic_string<char16_t>::size_type __n, char16_t __c);
            std::basic_string<char16_t> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t> &append(_InputIterator __first, _InputIterator __last);
            void push_back(char16_t __c);
            std::basic_string<char16_t> &assign(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &assign(std::basic_string<char16_t> &&__str);
            std::basic_string<char16_t> &assign(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &assign(const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &assign(const char16_t *__s);
            std::basic_string<char16_t> &assign(std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t> &assign(_InputIterator __first, _InputIterator __last);
            std::basic_string<char16_t> &assign(initializer_list<char16_t> __l);
            std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::const_iterator __p, std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::const_iterator __p, initializer_list<char16_t> __l);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos1, const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos1, const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos2, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos, const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos, const char16_t *__s);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, char16_t __c);
            std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::__const_iterator __p, char16_t __c);
            std::basic_string<char16_t> &erase(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t>::iterator erase(std::basic_string<char16_t>::__const_iterator __position);
            std::basic_string<char16_t>::iterator erase(std::basic_string<char16_t>::__const_iterator __first, std::basic_string<char16_t>::__const_iterator __last);
            void pop_back() noexcept;
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos1, std::basic_string<char16_t>::size_type __n1, const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos2, std::basic_string<char16_t>::size_type __n2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s, std::basic_string<char16_t>::size_type __n2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2, char16_t __c);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const char16_t *__s);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t> &replace(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, std::basic_string<char16_t>::iterator __k1, std::basic_string<char16_t>::iterator __k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, std::basic_string<char16_t>::const_iterator __k1, std::basic_string<char16_t>::const_iterator __k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, initializer_list<char16_t> __l);
        private:
            template <class _Integer> std::basic_string<char16_t> &_M_replace_dispatch(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::basic_string<char16_t> &_M_replace_dispatch(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::basic_string<char16_t> &_M_replace_aux(std::basic_string<char16_t>::size_type __pos1, std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2, char16_t __c);
            std::basic_string<char16_t> &_M_replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __len1, const char16_t *__s, const std::basic_string<char16_t>::size_type __len2);
            std::basic_string<char16_t> &_M_append(const char16_t *__s, std::basic_string<char16_t>::size_type __n);
        public:
            std::basic_string<char16_t>::size_type copy(char16_t *__s, std::basic_string<char16_t>::size_type __n, std::basic_string<char16_t>::size_type __pos) const;
            void swap(std::basic_string<char16_t> &__s) noexcept;
            const char16_t *c_str() const noexcept;
            const char16_t *data() const noexcept {
                return this->_M_data();
            }
            std::basic_string<char16_t>::allocator_type get_allocator() const noexcept;
            std::basic_string<char16_t>::size_type find(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type rfind(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type rfind(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type rfind(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const;
            std::basic_string<char16_t>::size_type rfind(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t> substr(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const;
            int compare(const std::basic_string<char16_t> &__str) const;
            int compare(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, const std::basic_string<char16_t> &__str) const;
            int compare(std::basic_string<char16_t>::size_type __pos1, std::basic_string<char16_t>::size_type __n1, const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos2, std::basic_string<char16_t>::size_type __n2) const;
            int compare(const char16_t *__s) const noexcept;
            int compare(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s) const;
            int compare(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s, std::basic_string<char16_t>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
        template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::basic_string<char32_t>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::basic_string<char32_t>::size_type npos = static_cast<std::basic_string<char32_t>::size_type>(-1);
        protected:
            typedef std::basic_string<char32_t>::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::basic_string<char32_t>::allocator_type {
                std::basic_string<char32_t>::pointer _M_p;
            };
            std::basic_string<char32_t>::_Alloc_hider _M_dataplus;
            std::basic_string<char32_t>::size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::basic_string<char32_t>::size_type _M_allocated_capacity;
            };
            void _M_data(std::basic_string<char32_t>::pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::basic_string<char32_t>::size_type __length) {
                this->_M_string_length = __length;
            }
            std::basic_string<char32_t>::pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            std::basic_string<char32_t>::pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::basic_string<char32_t>::const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::basic_string<char32_t>::size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::basic_string<char32_t>::size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            bool _M_is_local() const {
                return this->_M_data() == this->_M_local_data();
            }
            std::basic_string<char32_t>::pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_create(std::basic_string<char32_t>::size_type &__capacity, std::basic_string<char32_t>::size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::basic_string<char32_t>::size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag) {
                std::basic_string<char32_t>::size_type __dnew = static_cast<std::basic_string<char32_t>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::basic_string<char32_t>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::basic_string<char32_t>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char32_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::basic_string<char32_t>::size_type __req, char32_t __c);
            std::basic_string<char32_t>::allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            const std::basic_string<char32_t>::allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr std::basic_string<char32_t>::pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                return this->_M_local_data();
            }
        private:
            std::basic_string<char32_t>::size_type _M_check(std::basic_string<char32_t>::size_type __pos, const char *__s) const;
            void _M_check_length(std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2, const char *__s) const;
            std::basic_string<char32_t>::size_type _M_limit(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static void _S_copy(char32_t *__d, const char32_t *__s, std::basic_string<char32_t>::size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char32_t *__d, const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            static void _S_assign(char32_t *__d, std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _Iterator> static void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static void _S_copy_chars(char32_t *__p, std::basic_string<char32_t>::iterator __k1, std::basic_string<char32_t>::iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, std::basic_string<char32_t>::const_iterator __k1, std::basic_string<char32_t>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2) noexcept;
            void _M_assign(const std::basic_string<char32_t> &);
            void _M_mutate(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __len1, const char32_t *__s, std::basic_string<char32_t>::size_type __len2);
            void _M_erase(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            basic_string(const std::basic_string<char32_t> &__str);
            basic_string(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, const std::allocator<char32_t> &__a);
            basic_string(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            basic_string(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, const std::allocator<char32_t> &__a);
            basic_string(const char32_t *__s, std::basic_string<char32_t>::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            basic_string(std::basic_string<char32_t>::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            basic_string(std::basic_string<char32_t> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            basic_string(const std::basic_string<char32_t> &__str, const std::allocator<char32_t> &__a);
            basic_string(std::basic_string<char32_t> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            ~basic_string<char32_t>() noexcept {
                this->_M_dispose();
            }
            std::basic_string<char32_t> &operator=(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &operator=(const char32_t *__s);
            std::basic_string<char32_t> &operator=(char32_t __c);
            std::basic_string<char32_t> &operator=(std::basic_string<char32_t> &&__str);
            std::basic_string<char32_t> &operator=(initializer_list<char32_t> __l);
            std::basic_string<char32_t>::iterator begin() noexcept;
            std::basic_string<char32_t>::const_iterator begin() const noexcept;
            std::basic_string<char32_t>::iterator end() noexcept;
            std::basic_string<char32_t>::const_iterator end() const noexcept;
            std::basic_string<char32_t>::reverse_iterator rbegin() noexcept;
            std::basic_string<char32_t>::const_reverse_iterator rbegin() const noexcept;
            std::basic_string<char32_t>::reverse_iterator rend() noexcept;
            std::basic_string<char32_t>::const_reverse_iterator rend() const noexcept;
            std::basic_string<char32_t>::const_iterator cbegin() const noexcept;
            std::basic_string<char32_t>::const_iterator cend() const noexcept;
            std::basic_string<char32_t>::const_reverse_iterator crbegin() const noexcept;
            std::basic_string<char32_t>::const_reverse_iterator crend() const noexcept;
        public:
            std::basic_string<char32_t>::size_type size() const noexcept;
            std::basic_string<char32_t>::size_type length() const noexcept {
                return this->_M_string_length;
            }
            std::basic_string<char32_t>::size_type max_size() const noexcept {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::basic_string<char32_t>::size_type __n, char32_t __c);
            void resize(std::basic_string<char32_t>::size_type __n);
            void shrink_to_fit() noexcept;
            std::basic_string<char32_t>::size_type capacity() const noexcept;
            void reserve(std::basic_string<char32_t>::size_type __res_arg);
            void reserve();
            void clear() noexcept;
            bool empty() const noexcept;
            std::basic_string<char32_t>::const_reference operator[](std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::reference operator[](std::basic_string<char32_t>::size_type __pos);
            std::basic_string<char32_t>::const_reference at(std::basic_string<char32_t>::size_type __n) const;
            std::basic_string<char32_t>::reference at(std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t>::reference front() noexcept;
            std::basic_string<char32_t>::const_reference front() const noexcept;
            std::basic_string<char32_t>::reference back() noexcept;
            std::basic_string<char32_t>::const_reference back() const noexcept;
            std::basic_string<char32_t> &operator+=(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &operator+=(const char32_t *__s);
            std::basic_string<char32_t> &operator+=(char32_t __c);
            std::basic_string<char32_t> &operator+=(initializer_list<char32_t> __l);
            std::basic_string<char32_t> &append(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &append(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &append(const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &append(const char32_t *__s);
            std::basic_string<char32_t> &append(std::basic_string<char32_t>::size_type __n, char32_t __c);
            std::basic_string<char32_t> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t> &append(_InputIterator __first, _InputIterator __last);
            void push_back(char32_t __c);
            std::basic_string<char32_t> &assign(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &assign(std::basic_string<char32_t> &&__str);
            std::basic_string<char32_t> &assign(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &assign(const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &assign(const char32_t *__s);
            std::basic_string<char32_t> &assign(std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t> &assign(_InputIterator __first, _InputIterator __last);
            std::basic_string<char32_t> &assign(initializer_list<char32_t> __l);
            std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::const_iterator __p, std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::const_iterator __p, initializer_list<char32_t> __l);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos1, const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos1, const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos2, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos, const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos, const char32_t *__s);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, char32_t __c);
            std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::__const_iterator __p, char32_t __c);
            std::basic_string<char32_t> &erase(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t>::iterator erase(std::basic_string<char32_t>::__const_iterator __position);
            std::basic_string<char32_t>::iterator erase(std::basic_string<char32_t>::__const_iterator __first, std::basic_string<char32_t>::__const_iterator __last);
            void pop_back() noexcept;
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos1, std::basic_string<char32_t>::size_type __n1, const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos2, std::basic_string<char32_t>::size_type __n2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s, std::basic_string<char32_t>::size_type __n2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2, char32_t __c);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const char32_t *__s);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t> &replace(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, std::basic_string<char32_t>::iterator __k1, std::basic_string<char32_t>::iterator __k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, std::basic_string<char32_t>::const_iterator __k1, std::basic_string<char32_t>::const_iterator __k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, initializer_list<char32_t> __l);
        private:
            template <class _Integer> std::basic_string<char32_t> &_M_replace_dispatch(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::basic_string<char32_t> &_M_replace_dispatch(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::basic_string<char32_t> &_M_replace_aux(std::basic_string<char32_t>::size_type __pos1, std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2, char32_t __c);
            std::basic_string<char32_t> &_M_replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __len1, const char32_t *__s, const std::basic_string<char32_t>::size_type __len2);
            std::basic_string<char32_t> &_M_append(const char32_t *__s, std::basic_string<char32_t>::size_type __n);
        public:
            std::basic_string<char32_t>::size_type copy(char32_t *__s, std::basic_string<char32_t>::size_type __n, std::basic_string<char32_t>::size_type __pos) const;
            void swap(std::basic_string<char32_t> &__s) noexcept;
            const char32_t *c_str() const noexcept;
            const char32_t *data() const noexcept {
                return this->_M_data();
            }
            std::basic_string<char32_t>::allocator_type get_allocator() const noexcept;
            std::basic_string<char32_t>::size_type find(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type rfind(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type rfind(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type rfind(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const;
            std::basic_string<char32_t>::size_type rfind(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t> substr(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const;
            int compare(const std::basic_string<char32_t> &__str) const;
            int compare(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, const std::basic_string<char32_t> &__str) const;
            int compare(std::basic_string<char32_t>::size_type __pos1, std::basic_string<char32_t>::size_type __n1, const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos2, std::basic_string<char32_t>::size_type __n2) const;
            int compare(const char32_t *__s) const noexcept;
            int compare(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s) const;
            int compare(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s, std::basic_string<char32_t>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
}
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned int wint_t;
typedef struct {
    int __count;
    union {
        unsigned int __wch;
        char __wchb[4];
    } __value;
} __mbstate_t;
typedef __mbstate_t mbstate_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct __locale_struct {
    struct __locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern "C" {
    struct tm;
    extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
    extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true);
    extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(true);
    extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(true);
    extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
    extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(true);
    extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(true);
    extern wchar_t *wcsdup(const wchar_t *__s) noexcept(true) __attribute__((malloc));
    extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) noexcept(true) __attribute__((pure));
    extern size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) noexcept(true) __attribute__((pure));
    extern wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) noexcept(true) __attribute__((pure));
    extern wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) noexcept(true) __attribute__((pure));
    extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) noexcept(true);
    extern size_t wcslen(const wchar_t *__s) noexcept(true) __attribute__((pure));
    extern wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) noexcept(true) __attribute__((pure));
    extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) noexcept(true) __attribute__((pure));
    extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) noexcept(true) __attribute__((pure));
    extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true) __attribute__((pure));
    extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true);
    extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) noexcept(true);
    extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern wint_t btowc(int __c) noexcept(true);
    extern int wctob(wint_t __c) noexcept(true);
    extern int mbsinit(const mbstate_t *__ps) noexcept(true) __attribute__((pure));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) noexcept(true);
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t __mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern int wcwidth(wchar_t __c) noexcept(true);
    extern int wcswidth(const wchar_t *__s, size_t __n) noexcept(true);
    extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float32 wcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float64 wcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float32x wcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float64x wcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true);
    extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true);
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern int fwide(__FILE *__fp, int __mode) noexcept(true);
    extern int fwprintf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wprintf(const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) noexcept(true);
    extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wscanf(const wchar_t *__restrict __format, ...);
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(true);
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) asm("__isoc99_fwscanf");
    extern int wscanf(const wchar_t *__restrict __format, ...) asm("__isoc99_wscanf");
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(true) asm("__isoc99_swscanf");
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vfwscanf");
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vwscanf");
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true) asm("__isoc99_vswscanf");
    extern wint_t fgetwc(__FILE *__stream);
    extern wint_t getwc(__FILE *__stream);
    extern wint_t getwchar();
    extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
    extern wint_t getwc_unlocked(__FILE *__stream);
    extern wint_t getwchar_unlocked();
    extern wint_t fgetwc_unlocked(__FILE *__stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) noexcept(true);
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(true);
}
namespace std {
    using ::mbstate_t;
}
extern "C++" {
    namespace std {
        using ::wint_t;
        using ::btowc;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::fwprintf;
        using ::fwscanf;
        using ::getwc;
        using ::getwchar;
        using ::mbrlen;
        using ::mbrtowc;
        using ::mbsinit;
        using ::mbsrtowcs;
        using ::putwc;
        using ::putwchar;
        using ::swprintf;
        using ::swscanf;
        using ::ungetwc;
        using ::vfwprintf;
        using ::vfwscanf;
        using ::vswprintf;
        using ::vswscanf;
        using ::vwprintf;
        using ::vwscanf;
        using ::wcrtomb;
        using ::wcscat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcscpy;
        using ::wcscspn;
        using ::wcsftime;
        using ::wcslen;
        using ::wcsncat;
        using ::wcsncmp;
        using ::wcsncpy;
        using ::wcsrtombs;
        using ::wcsspn;
        using ::wcstod;
        using ::wcstof;
        using ::wcstok;
        using ::wcstol;
        using ::wcstoul;
        using ::wcsxfrm;
        using ::wctob;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wprintf;
        using ::wscanf;
        using ::wcschr;
        using ::wcspbrk;
        using ::wcsrchr;
        using ::wcsstr;
        using ::wmemchr;
        inline wchar_t *wcschr(wchar_t *__p, wchar_t __c) {
            return wcschr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2) {
            return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c) {
            return wcsrchr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2) {
            return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, std::size_t __n) {
            return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
        }
    }
}
namespace __gnu_cxx {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
namespace std {
    using std::wcstof;
    using std::vfwscanf;
    using std::vswscanf;
    using std::vwscanf;
    using std::wcstold;
    using std::wcstoll;
    using std::wcstoull;
}
namespace std {
    typedef long streamoff;
    typedef std::ptrdiff_t streamsize;
    template <typename _StateT> class fpos {
    private:
        std::streamoff _M_off;
        _StateT _M_state;
    public:
        fpos<_StateT>() : _M_off(0), _M_state() {
        }
        fpos<_StateT>(std::streamoff __off) : _M_off(__off), _M_state() {
        }
        fpos<_StateT>(const fpos<_StateT> &) = default
        fpos<_StateT> &operator=(const fpos<_StateT> &) = default
        ~fpos<_StateT>() = default
        operator streamoff() const {
            return this->_M_off;
        }
        void state(_StateT __st) {
            this->_M_state = __st;
        }
        _StateT state() const {
            return this->_M_state;
        }
        fpos<_StateT> &operator+=(std::streamoff __off) {
            this->_M_off += __off;
            return *this;
        }
        fpos<_StateT> &operator-=(std::streamoff __off) {
            this->_M_off -= __off;
            return *this;
        }
        fpos<_StateT> operator+(std::streamoff __off) const {
            fpos<_StateT> __pos(*this);
            __pos += __off;
            return __pos;
        }
        fpos<_StateT> operator-(std::streamoff __off) const {
            fpos<_StateT> __pos(*this);
            __pos -= __off;
            return __pos;
        }
        std::streamoff operator-(const fpos<_StateT> &__other) const {
            return this->_M_off - __other._M_off;
        }
    };
    template <typename _StateT> inline bool operator==(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs) {
        return std::streamoff(__lhs) == std::streamoff(__rhs);
    }
    template <typename _StateT> inline bool operator!=(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs) {
        return std::streamoff(__lhs) != std::streamoff(__rhs);
    }
    typedef fpos<mbstate_t> streampos;
    typedef fpos<mbstate_t> wstreampos;
    typedef fpos<mbstate_t> u16streampos;
    typedef fpos<mbstate_t> u32streampos;
}
namespace std {
    class ios_base;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_filebuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ifstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ofstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_fstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    typedef basic_ios<char> ios;
    typedef basic_streambuf<char> streambuf;
    typedef basic_istream<char> istream;
    typedef basic_ostream<char> ostream;
    typedef basic_iostream<char> iostream;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_istringstream<char> istringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_filebuf<char> filebuf;
    typedef basic_ifstream<char> ifstream;
    typedef basic_ofstream<char> ofstream;
    typedef basic_fstream<char> fstream;
    typedef basic_ios<wchar_t> wios;
    typedef basic_streambuf<wchar_t> wstreambuf;
    typedef basic_istream<wchar_t> wistream;
    typedef basic_ostream<wchar_t> wostream;
    typedef basic_iostream<wchar_t> wiostream;
    typedef basic_stringbuf<wchar_t> wstringbuf;
    typedef basic_istringstream<wchar_t> wistringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;
    typedef basic_stringstream<wchar_t> wstringstream;
    typedef basic_filebuf<wchar_t> wfilebuf;
    typedef basic_ifstream<wchar_t> wifstream;
    typedef basic_ofstream<wchar_t> wofstream;
    typedef basic_fstream<wchar_t> wfstream;
}
extern "C++" {
    namespace std {
        class bad_exception : public std::exception {
        public:
            bad_exception() noexcept : std::exception() {
            }
            virtual ~bad_exception() noexcept;
            virtual const char *what() const noexcept;
        };
        typedef void (*terminate_handler)();
        std::terminate_handler set_terminate(std::terminate_handler) noexcept;
        std::terminate_handler get_terminate() noexcept;
        void terminate() noexcept;
        typedef void (*unexpected_handler)() __attribute__((deprecated("")));
        std::unexpected_handler set_unexpected(std::unexpected_handler) noexcept __attribute__((deprecated("")));
        std::unexpected_handler get_unexpected() noexcept __attribute__((deprecated("")));
        void unexpected() __attribute__((deprecated("")));
        bool uncaught_exception() noexcept __attribute__((pure));
        int uncaught_exceptions() noexcept __attribute__((pure));
    }
    namespace __gnu_cxx {
        void __verbose_terminate_handler();
    }
}
extern "C++" {
    namespace std {
        class bad_alloc : public std::exception {
        public:
            bad_alloc() throw() : std::exception() {
            }
            bad_alloc(const std::bad_alloc &) = default
            std::bad_alloc &operator=(const std::bad_alloc &) = default
            virtual ~bad_alloc() throw();
            virtual const char *what() const throw();
        };
        class bad_array_new_length : public std::bad_alloc {
        public:
            bad_array_new_length() throw() : std::bad_alloc() {
            }
            virtual ~bad_array_new_length() throw();
            virtual const char *what() const throw();
        };
        struct nothrow_t {
            explicit nothrow_t() = default
        };
        extern const std::nothrow_t nothrow;
        typedef void (*new_handler)();
        std::new_handler set_new_handler(std::new_handler) throw();
        std::new_handler get_new_handler() noexcept;
    }
    void *operator new(std::size_t);
    void *operator new[](std::size_t);
    void operator delete(void *) noexcept;
    void operator delete[](void *) noexcept;
    void *operator new(std::size_t, const std::nothrow_t &) noexcept __attribute__((alloc_size(1))) __attribute__((malloc));
    void *operator new[](std::size_t, const std::nothrow_t &) noexcept __attribute__((alloc_size(1))) __attribute__((malloc));
    void operator delete(void *, const std::nothrow_t &) noexcept;
    void operator delete[](void *, const std::nothrow_t &) noexcept;
    inline void *operator new(std::size_t, void *__p) noexcept {
        return __p;
    }
    inline void *operator new[](std::size_t, void *__p) noexcept {
        return __p;
    }
    inline void operator delete(void *, void *) noexcept {
    }
    inline void operator delete[](void *, void *) noexcept {
    }
}
namespace std {
    template <typename _Tp> inline constexpr _Tp *__addressof(_Tp &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char *__addressof<char>(char &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char *__addressof<const char>(const char &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr wchar_t *__addressof<wchar_t>(wchar_t &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const wchar_t *__addressof<const wchar_t>(const wchar_t &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char16_t *__addressof<char16_t>(char16_t &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char16_t *__addressof<const char16_t>(const char16_t &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char32_t *__addressof<char32_t>(char32_t &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char32_t *__addressof<const char32_t>(const char32_t &__r) noexcept {
        return __builtin_addressof(__r);
    }
}
namespace std {
    template <typename _Tp> class reference_wrapper;
    template <typename _Tp, _Tp __v> struct integral_constant {
        static constexpr _Tp value = __v;
        typedef _Tp value_type;
        typedef integral_constant<_Tp, __v> type;
        constexpr operator value_type() const noexcept {
            return value;
        }
        constexpr std::integral_constant::value_type operator()() const noexcept {
            return value;
        }
    };
    template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        typedef bool value_type;
        typedef integral_constant<bool, true> type;
        constexpr operator value_type() const noexcept {
            return value;
        }
        constexpr std::integral_constant<bool, true>::value_type operator()() const noexcept;
    };
    template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        typedef bool value_type;
        typedef integral_constant<bool, false> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, false>::value_type operator()() const noexcept;
    };
    template<> struct integral_constant<unsigned long, 0> {
        static constexpr unsigned long value = 0UL;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 0UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 0>::value_type operator()() const noexcept;
    };
    template<> struct integral_constant<unsigned long, 2> {
        static constexpr unsigned long value = 2UL;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 2UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 2>::value_type operator()() const noexcept;
    };
    constexpr _Tp value;
    using true_type = integral_constant<bool, true>;
    using false_type = integral_constant<bool, false>;
    template <bool __v> using __bool_constant = integral_constant<bool, __v>;
    template <bool> struct __conditional {
        template <typename _Tp, typename> using type = _Tp;
    };
    template<> struct __conditional<true> {
        template <typename _Tp, typename> using type = _Tp;
    };
    template<> struct __conditional<false> {
        template <typename, typename _Up> using type = _Up;
    };
    template <bool _Cond, typename _If, typename _Else> using __conditional_t = typename __conditional<_Cond>::template type<_If, _Else>;
    template <typename _Type> struct __type_identity {
        using type = _Type;
    };
    template<> struct __type_identity<std::allocator<char>> {
        using type = std::allocator<char>;
    };
    template <typename _Tp> using __type_identity_t = typename __type_identity<_Tp>::type;
    template <typename ...> struct __or_
    template<> struct __or_<<std::is_integral<unsigned int>, std::is_floating_point<unsigned int>>> : public __conditional_t<is_integral<unsigned int>::value, std::is_integral<unsigned int>, std::is_floating_point<unsigned int>> {
    }
    template<> struct __or_<<std::is_integral<unsigned long>, std::is_floating_point<unsigned long>>> : public __conditional_t<is_integral<unsigned long>::value, std::is_integral<unsigned long>, std::is_floating_point<unsigned long>> {
    }
    template<> struct __or_<<std::is_integral<unsigned long long>, std::is_floating_point<unsigned long long>>> : public __conditional_t<is_integral<unsigned long long>::value, std::is_integral<unsigned long long>, std::is_floating_point<unsigned long long>> {
    }
    template<> struct __or_<<std::is_reference<std::allocator<char>>, std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public __conditional_t<is_reference<allocator<char>>::value, std::is_reference<std::allocator<char>>, __or_<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
    }
    template<> struct __or_<<std::is_lvalue_reference<std::allocator<char>>, std::is_rvalue_reference<std::allocator<char>>>> : public __conditional_t<is_lvalue_reference<allocator<char>>::value, std::is_lvalue_reference<std::allocator<char>>, std::is_rvalue_reference<std::allocator<char>>> {
    }
    template<> struct __or_<<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public __conditional_t<is_function<allocator<char>>::value, std::is_function<std::allocator<char>>, __or_<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
    }
    template<> struct __or_<<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public __conditional_t<is_void<allocator<char>>::value, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> {
    }
    template<> struct __or_<<std::__is_referenceable<std::basic_stringstream<char> &>, std::is_void<std::basic_stringstream<char> &>>> : public __conditional_t<__is_referenceable<basic_stringstream<char> &>::value, std::__is_referenceable<std::basic_stringstream<char> &>, std::is_void<std::basic_stringstream<char> &>> {
    }
    template<> struct __or_<<std::__is_referenceable<std::basic_ostream<char> &>, std::is_void<std::basic_ostream<char> &>>> : public __conditional_t<__is_referenceable<basic_ostream<char> &>::value, std::__is_referenceable<std::basic_ostream<char> &>, std::is_void<std::basic_ostream<char> &>> {
    }
    template<> struct __or_<<std::is_void<std::random_access_iterator_tag>, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public __conditional_t<is_void<random_access_iterator_tag>::value, std::is_void<std::random_access_iterator_tag>, __or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> {
    }
    template<> struct __or_<<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public __conditional_t<is_function<input_iterator_tag>::value, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> {
    }
    template<> struct __or_<<std::is_void<char *>, std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_void<char *>::value, std::is_void<char *>, __or_<std::is_function<const char *>, std::is_array<const char *>>> {
    }
    template<> struct __or_<<std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_function<const char *>::value, std::is_function<const char *>, std::is_array<const char *>> {
    }
    template<> struct __or_<<std::is_void<const char *>, std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_void<const char *>::value, std::is_void<const char *>, __or_<std::is_function<const char *>, std::is_array<const char *>>> {
    }
    template<> struct __or_<<std::is_void<char *>, std::is_function<char *>, std::is_array<char *>>> : public __conditional_t<is_void<char *>::value, std::is_void<char *>, __or_<std::is_function<char *>, std::is_array<char *>>> {
    }
    template<> struct __or_<<std::is_function<char *>, std::is_array<char *>>> : public __conditional_t<is_function<char *>::value, std::is_function<char *>, std::is_array<char *>> {
    };
    template<> struct __or_<> : public std::false_type {
    };
    template <typename _B1> struct __or_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __or_<_B1, _B2> : public __conditional_t<_B1::value, _B1, _B2> {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __or_<_B1, _B2, _B3, _Bn...> : public __conditional_t<_B1::value, _B1, __or_<_B2, _B3, _Bn...>> {
    };
    template <typename ...> struct __and_
    template<> struct __and_<<std::is_arithmetic<unsigned int>, std::__not_<std::is_signed<unsigned int>>>> : public __conditional_t<is_arithmetic<unsigned int>::value, std::__not_<std::is_signed<unsigned int>>, std::is_arithmetic<unsigned int>> {
    }
    template<> struct __and_<<std::is_arithmetic<unsigned long>, std::__not_<std::is_signed<unsigned long>>>> : public __conditional_t<is_arithmetic<unsigned long>::value, std::__not_<std::is_signed<unsigned long>>, std::is_arithmetic<unsigned long>> {
    }
    template<> struct __and_<<std::is_arithmetic<unsigned long long>, std::__not_<std::is_signed<unsigned long long>>>> : public __conditional_t<is_arithmetic<unsigned long long>::value, std::__not_<std::is_signed<unsigned long long>>, std::is_arithmetic<unsigned long long>> {
    }
    template<> struct __and_<<std::is_array<std::allocator<char>>, std::__not_<std::extent<std::allocator<char>, 0>>>> : public __conditional_t<is_array<allocator<char>>::value, std::__not_<std::extent<std::allocator<char>, 0>>, std::is_array<std::allocator<char>>> {
    }
    template<> struct __and_<<std::is_class<std::basic_stringstream<char> &>, std::__not_<std::is_same<std::basic_stringstream<char> &, std::ios_base>>, std::is_convertible<std::basic_stringstream<char> *, std::ios_base *>>> : public __conditional_t<is_class<basic_stringstream<char> &>::value, __and_<std::__not_<std::is_same<std::basic_stringstream<char> &, std::ios_base>>, std::is_convertible<std::basic_stringstream<char> *, std::ios_base *>>, std::is_class<std::basic_stringstream<char> &>> {
    }
    template<> struct __and_<<std::is_class<std::basic_ostream<char> &>, std::__not_<std::is_same<std::basic_ostream<char> &, std::ios_base>>, std::is_convertible<std::basic_ostream<char> *, std::ios_base *>>> : public __conditional_t<is_class<basic_ostream<char> &>::value, __and_<std::__not_<std::is_same<std::basic_ostream<char> &, std::ios_base>>, std::is_convertible<std::basic_ostream<char> *, std::ios_base *>>, std::is_class<std::basic_ostream<char> &>> {
    };
    template<> struct __and_<> : public std::true_type {
    };
    template <typename _B1> struct __and_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __and_<_B1, _B2> : public __conditional_t<_B1::value, _B2, _B1> {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __and_<_B1, _B2, _B3, _Bn...> : public __conditional_t<_B1::value, __and_<_B2, _B3, _Bn...>, _B1> {
    };
    template <typename _Pp> struct __not_ : public __bool_constant<!bool(_Pp::value)> {
    };
    template<> struct __not_<std::is_signed<unsigned int>> : public __bool_constant<!bool(is_signed<unsigned int>::value)> {
    };
    template<> struct __not_<std::is_signed<unsigned long>> : public __bool_constant<!bool(is_signed<unsigned long>::value)> {
    };
    template<> struct __not_<std::is_signed<unsigned long long>> : public __bool_constant<!bool(is_signed<unsigned long long>::value)> {
    };
    template <typename> struct is_reference
    template<> struct is_reference<std::allocator<char>> : public __or_<is_lvalue_reference<allocator<char>>, is_rvalue_reference<allocator<char>>>::type {
    };
    template <typename> struct is_function
    template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    }
    template<> struct is_function<std::input_iterator_tag> : public __bool_constant<!is_const<const input_iterator_tag>::value> {
    }
    template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    }
    template<> struct is_function<char *> : public __bool_constant<!is_const<char *const>::value> {
    };
    template <typename> struct is_void
    template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    }
    template<> struct is_void<std::allocator<char>> : public __is_void_helper<__remove_cv_t<allocator<char>>>::type {
    }
    template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    }
    template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    }
    template<> struct is_void<std::random_access_iterator_tag> : public __is_void_helper<__remove_cv_t<random_access_iterator_tag>>::type {
    }
    template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    }
    template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    }
    template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    }
    template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    }
    template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    }
    template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    }
    template<> struct is_void<char *> : public __is_void_helper<__remove_cv_t<char *>>::type {
    }
    template<> struct is_void<const char *> : public __is_void_helper<__remove_cv_t<const char *>>::type {
    };
    template <typename> struct remove_cv
    template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    }
    template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    }
    template<> struct remove_cv<char16_t> {
        using type = char16_t;
    }
    template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    }
    template<> struct remove_cv<char32_t> {
        using type = char32_t;
    }
    template<> struct remove_cv<void> {
        using type = void;
    }
    template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    }
    template<> struct remove_cv<unsigned long long> {
        using type = unsigned long long;
    }
    template<> struct remove_cv<std::allocator<char>> {
        using type = std::allocator<char>;
    }
    template<> struct remove_cv<char> {
        using type = char;
    }
    template<> struct remove_cv<const char> {
        using type = char;
    }
    template<> struct remove_cv<std::random_access_iterator_tag> {
        using type = std::random_access_iterator_tag;
    }
    template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    }
    template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    }
    template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    }
    template<> struct remove_cv<char *> {
        using type = char *;
    }
    template<> struct remove_cv<const char *> {
        using type = const char *;
    };
    template <typename> struct is_const
    template<> struct is_const<wchar_t> : public std::false_type {
    }
    template<> struct is_const<char16_t> : public std::false_type {
    }
    template<> struct is_const<char32_t> : public std::false_type {
    }
    template<> struct is_const<unsigned int> : public std::false_type {
    }
    template<> struct is_const<unsigned short> : public std::false_type {
    }
    template<> struct is_const<const std::allocator<char>> : public std::true_type {
    }
    template<> struct is_const<const std::input_iterator_tag> : public std::true_type {
    }
    template<> struct is_const<const char *const> : public std::true_type {
    }
    template<> struct is_const<char *const> : public std::true_type {
    };
    template <typename> struct __is_array_unknown_bounds
    template<> struct __is_array_unknown_bounds<std::allocator<char>> : public __and_<is_array<std::allocator<char>>, __not_<extent<std::allocator<char>>>> {
    };
    template <typename _Tp, std::size_t = sizeof(_Tp)> constexpr std::true_type __is_complete_or_unbounded(__type_identity<_Tp>) {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<std::allocator<char>, 1UL>(__type_identity<std::allocator<char>>) {
        return {};
    }
    template <typename _TypeIdentity, typename _NestedType = typename _TypeIdentity::type> constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>, __is_array_unknown_bounds<_NestedType>>::type __is_complete_or_unbounded(_TypeIdentity) {
        return {};
    }
    template<> constexpr typename __or_<is_reference<allocator<char>>, is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>::type __is_complete_or_unbounded<std::__type_identity<std::allocator<char>>, std::allocator<char>>(std::__type_identity<std::allocator<char>>)    template <typename _Tp> struct __success_type {
        typedef _Tp type;
    };
    struct __failure_type {
    };
    template <typename _Tp> using __remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename> struct __is_void_helper : public std::false_type {
    };
    template<> struct __is_void_helper<std::allocator<char>> : public std::false_type {
    };
    template<> struct __is_void_helper<char> : public std::false_type {
    };
    template<> struct __is_void_helper<std::random_access_iterator_tag> : public std::false_type {
    };
    template<> struct __is_void_helper<wchar_t> : public std::false_type {
    };
    template<> struct __is_void_helper<char16_t> : public std::false_type {
    };
    template<> struct __is_void_helper<char32_t> : public std::false_type {
    };
    template<> struct __is_void_helper<char *> : public std::false_type {
    };
    template<> struct __is_void_helper<const char *> : public std::false_type {
    };
    template<> struct __is_void_helper<void> : public std::true_type {
    };
    template <typename _Tp> struct is_void : public __is_void_helper<__remove_cv_t<_Tp>>::type {
    };
    template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    };
    template<> struct is_void<std::allocator<char>> : public __is_void_helper<__remove_cv_t<allocator<char>>>::type {
    };
    template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    };
    template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    };
    template<> struct is_void<std::random_access_iterator_tag> : public __is_void_helper<__remove_cv_t<random_access_iterator_tag>>::type {
    };
    template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    };
    template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    };
    template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    };
    template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    };
    template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    };
    template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    };
    template<> struct is_void<char *> : public __is_void_helper<__remove_cv_t<char *>>::type {
    };
    template<> struct is_void<const char *> : public __is_void_helper<__remove_cv_t<const char *>>::type {
    };
    template <typename> struct __is_integral_helper : public std::false_type {
    };
    template<> struct __is_integral_helper<bool> : public std::true_type {
    };
    template<> struct __is_integral_helper<char> : public std::true_type {
    };
    template<> struct __is_integral_helper<signed char> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned char> : public std::true_type {
    };
    template<> struct __is_integral_helper<wchar_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char16_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char32_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<short> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned short> : public std::true_type {
    };
    template<> struct __is_integral_helper<int> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned int> : public std::true_type {
    };
    template<> struct __is_integral_helper<long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long> : public std::true_type {
    };
    template<> struct __is_integral_helper<long long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long long> : public std::true_type {
    };
    template<> struct __is_integral_helper<__int128> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned __int128> : public std::true_type {
    };
    template <typename _Tp> struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {
    };
    template<> struct is_integral<wchar_t> : public __is_integral_helper<__remove_cv_t<wchar_t>>::type {
    };
    template<> struct is_integral<unsigned int> : public __is_integral_helper<__remove_cv_t<unsigned int>>::type {
    };
    template<> struct is_integral<char16_t> : public __is_integral_helper<__remove_cv_t<char16_t>>::type {
    };
    template<> struct is_integral<unsigned short> : public __is_integral_helper<__remove_cv_t<unsigned short>>::type {
    };
    template<> struct is_integral<char32_t> : public __is_integral_helper<__remove_cv_t<char32_t>>::type {
    };
    template<> struct is_integral<unsigned long> : public __is_integral_helper<__remove_cv_t<unsigned long>>::type {
    };
    template<> struct is_integral<unsigned long long> : public __is_integral_helper<__remove_cv_t<unsigned long long>>::type {
    };
    template <typename> struct __is_floating_point_helper : public std::false_type {
    };
    template<> struct __is_floating_point_helper<float> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<double> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<long double> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<__float128> : public std::true_type {
    };
    template <typename _Tp> struct is_floating_point : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct is_array : public std::false_type {
    };
    template<> struct is_array<std::allocator<char>> : public std::false_type {
    };
    template<> struct is_array<std::input_iterator_tag> : public std::false_type {
    };
    template<> struct is_array<const char *> : public std::false_type {
    };
    template<> struct is_array<char *> : public std::false_type {
    };
    template <typename _Tp, std::size_t _Size> struct is_array<_Tp[_Size]> : public std::true_type {
    };
    template <typename _Tp> struct is_array<_Tp[]> : public std::true_type {
    };
    template <typename> struct __is_pointer_helper : public std::false_type {
    };
    template <typename _Tp> struct __is_pointer_helper<_Tp *> : public std::true_type {
    };
    template <typename _Tp> struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct is_lvalue_reference : public std::false_type {
    };
    template<> struct is_lvalue_reference<std::allocator<char>> : public std::false_type {
    };
    template <typename _Tp> struct is_lvalue_reference<_Tp &> : public std::true_type {
    };
    template <typename> struct is_rvalue_reference : public std::false_type {
    };
    template<> struct is_rvalue_reference<std::allocator<char>> : public std::false_type {
    };
    template <typename _Tp> struct is_rvalue_reference<_Tp &&> : public std::true_type {
    };
    template <typename> struct __is_member_object_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public __not_<is_function<_Tp>>::type {
    };
    template <typename _Tp> struct is_member_object_pointer : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct __is_member_function_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type {
    };
    template <typename _Tp> struct is_member_function_pointer : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {
    };
    template<> struct is_enum<wchar_t> : public integral_constant<bool, __is_enum(wchar_t)> {
    };
    template<> struct is_enum<unsigned int> : public integral_constant<bool, __is_enum(unsigned int)> {
    };
    template<> struct is_enum<char16_t> : public integral_constant<bool, __is_enum(char16_t)> {
    };
    template<> struct is_enum<unsigned short> : public integral_constant<bool, __is_enum(unsigned short)> {
    };
    template<> struct is_enum<char32_t> : public integral_constant<bool, __is_enum(char32_t)> {
    };
    template <typename _Tp> struct is_union : public integral_constant<bool, __is_union(_Tp)> {
    };
    template <typename _Tp> struct is_class : public integral_constant<bool, __is_class(_Tp)> {
    };
    template<> struct is_class<std::basic_stringstream<char> &> : public integral_constant<bool, __is_class(std::basic_stringstream<char> &)> {
    };
    template<> struct is_class<std::basic_ostream<char> &> : public integral_constant<bool, __is_class(std::basic_ostream<char> &)> {
    };
    template <typename _Tp> struct is_function : public __bool_constant<!is_const<const _Tp>::value> {
    };
    template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    };
    template<> struct is_function<std::input_iterator_tag> : public __bool_constant<!is_const<const input_iterator_tag>::value> {
    };
    template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    };
    template<> struct is_function<char *> : public __bool_constant<!is_const<char *const>::value> {
    };
    template <typename _Tp> struct is_function<_Tp &> : public std::false_type {
    };
    template <typename _Tp> struct is_function<_Tp &&> : public std::false_type {
    };
    template <typename> struct __is_null_pointer_helper : public std::false_type {
    };
    template<> struct __is_null_pointer_helper<std::nullptr_t> : public std::true_type {
    };
    template <typename _Tp> struct is_null_pointer : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct __attribute__((deprecated("use 'std::is_null_pointer' instead"))) __is_nullptr_t : public is_null_pointer<_Tp> {
    };
    template <typename _Tp> struct is_reference : public __or_<is_lvalue_reference<_Tp>, is_rvalue_reference<_Tp>>::type {
    };
    template<> struct is_reference<std::allocator<char>> : public __or_<is_lvalue_reference<allocator<char>>, is_rvalue_reference<allocator<char>>>::type {
    };
    template <typename _Tp> struct is_arithmetic : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {
    };
    template<> struct is_arithmetic<unsigned int> : public __or_<is_integral<unsigned int>, is_floating_point<unsigned int>>::type {
    };
    template<> struct is_arithmetic<unsigned long> : public __or_<is_integral<unsigned long>, is_floating_point<unsigned long>>::type {
    };
    template<> struct is_arithmetic<unsigned long long> : public __or_<is_integral<unsigned long long>, is_floating_point<unsigned long long>>::type {
    };
    template <typename _Tp> struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template <typename _Tp> struct is_object : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {
    };
    template <typename> struct is_member_pointer;
    template <typename _Tp> struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>, is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template <typename _Tp> struct is_compound : public __not_<is_fundamental<_Tp>>::type {
    };
    template <typename _Tp> struct __is_member_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public std::true_type {
    };
    template <typename _Tp> struct is_member_pointer : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename, typename> struct is_same
    template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    }
    template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    }
    template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    }
    template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    }
    template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    }
    template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    }
    template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    }
    template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Tp, typename ..._Types> using __is_one_of = __or_<is_same<_Tp, _Types>...>;
    template <typename _Tp> using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>, signed char, short, int, long, long long, __int128>;
    template <typename _Tp> using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, unsigned __int128>;
    template <typename _Tp> using __is_standard_integer = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;
    template <typename ...> using __void_t = void;
    template <typename _Tp, typename = void> struct __is_referenceable : public std::false_type {
    };
    template<> struct __is_referenceable<std::basic_stringstream<char> &, void> : public std::true_type {
    };
    template<> struct __is_referenceable<std::basic_ostream<char> &, void> : public std::true_type {
    };
    template <typename _Tp> struct __is_referenceable<_Tp, __void_t<_Tp &>> : public std::true_type {
    };
    template <typename> struct is_const : public std::false_type {
    };
    template<> struct is_const<wchar_t> : public std::false_type {
    };
    template<> struct is_const<char16_t> : public std::false_type {
    };
    template<> struct is_const<char32_t> : public std::false_type {
    };
    template<> struct is_const<unsigned int> : public std::false_type {
    };
    template<> struct is_const<unsigned short> : public std::false_type {
    };
    template<> struct is_const<const std::allocator<char>> : public std::true_type {
    };
    template<> struct is_const<const std::input_iterator_tag> : public std::true_type {
    };
    template<> struct is_const<const char *const> : public std::true_type {
    };
    template<> struct is_const<char *const> : public std::true_type {
    };
    template <typename _Tp> struct is_const<const _Tp> : public std::true_type {
    };
    template <typename> struct is_volatile : public std::false_type {
    };
    template<> struct is_volatile<wchar_t> : public std::false_type {
    };
    template<> struct is_volatile<char16_t> : public std::false_type {
    };
    template<> struct is_volatile<char32_t> : public std::false_type {
    };
    template<> struct is_volatile<unsigned int> : public std::false_type {
    };
    template<> struct is_volatile<unsigned short> : public std::false_type {
    };
    template <typename _Tp> struct is_volatile<volatile _Tp> : public std::true_type {
    };
    template <typename _Tp> struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_pod : public integral_constant<bool, __is_pod(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {
    };
    template <typename _Tp> struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
    };
    template <typename _Tp> struct is_final : public integral_constant<bool, __is_final(_Tp)> {
    };
    template <typename _Tp> struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {
    };
    template <typename _Tp, bool = is_arithmetic<_Tp>::value> struct __is_signed_helper : public std::false_type {
    };
    template<> struct __is_signed_helper<unsigned int, true> : public integral_constant<bool, unsigned int(-1) < unsigned int(0)> {
    };
    template<> struct __is_signed_helper<unsigned long, true> : public integral_constant<bool, unsigned long(-1) < unsigned long(0)> {
    };
    template<> struct __is_signed_helper<unsigned long long, true> : public integral_constant<bool, unsigned long long(-1) < unsigned long long(0)> {
    };
    template <typename _Tp> struct __is_signed_helper<_Tp, true> : public integral_constant<bool, _Tp(-1) < _Tp(0)> {
    };
    template <typename _Tp> struct is_signed : public __is_signed_helper<_Tp>::type {
    };
    template<> struct is_signed<unsigned int> : public __is_signed_helper<unsigned int>::type {
    };
    template<> struct is_signed<unsigned long> : public __is_signed_helper<unsigned long>::type {
    };
    template<> struct is_signed<unsigned long long> : public __is_signed_helper<unsigned long long>::type {
    };
    template <typename _Tp> struct is_unsigned : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>> {
    };
    template<> struct is_unsigned<unsigned int> : public __and_<is_arithmetic<unsigned int>, __not_<is_signed<unsigned int>>> {
    };
    template<> struct is_unsigned<unsigned long> : public __and_<is_arithmetic<unsigned long>, __not_<is_signed<unsigned long>>> {
    };
    template<> struct is_unsigned<unsigned long long> : public __and_<is_arithmetic<unsigned long long>, __not_<is_signed<unsigned long long>>> {
    };
    template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);
    template<> std::random_access_iterator_tag &&__declval<std::random_access_iterator_tag, std::random_access_iterator_tag &&>(int);
    template<> char *&&__declval<char *, char *&&>(int);
    template<> const char *&&__declval<const char *, const char *&&>(int);
    template <typename _Tp> _Tp __declval(long);
    template<> std::random_access_iterator_tag __declval<std::random_access_iterator_tag>(long);
    template<> char *__declval<char *>(long);
    template<> const char *__declval<const char *>(long);
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0));
    template <typename, unsigned int = 0> struct extent;
    template <typename> struct remove_all_extents;
    template <typename _Tp> struct __is_array_known_bounds : public integral_constant<bool, (extent<_Tp>::value > 0)> {
    };
    template <typename _Tp> struct __is_array_unknown_bounds : public __and_<is_array<_Tp>, __not_<extent<_Tp>>> {
    };
    template<> struct __is_array_unknown_bounds<std::allocator<char>> : public __and_<is_array<std::allocator<char>>, __not_<extent<std::allocator<char>>>> {
    };
    struct __do_is_destructible_impl {
        template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())> static std::true_type __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_destructible_impl : public std::__do_is_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_destructible_safe;
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, false> : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_destructible : public __is_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_nt_destructible_impl {
        template <typename _Tp> static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_nt_destructible_impl : public std::__do_is_nt_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_nt_destructible_safe;
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, false> : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct __is_constructible_impl : public __bool_constant<__is_constructible(_Tp, _Args...)> {
    };
    template <typename _Tp, typename ..._Args> struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_default_constructible : public __is_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_constructible_impl;
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_copy_constructible : public __is_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_constructible_impl;
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_move_constructible : public __is_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> using __is_nothrow_constructible_impl = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;
    template <typename _Tp, typename ..._Args> struct is_nothrow_constructible : public __is_nothrow_constructible_impl<_Tp, _Args...>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_default_constructible : public __bool_constant<__is_nothrow_constructible(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_default_constructible<std::allocator<char>> : public __bool_constant<__is_nothrow_constructible(std::allocator<char>)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<std::allocator<char>>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_copy_constructible_impl;
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_constructible : public __is_nothrow_copy_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_move_constructible_impl;
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_constructible : public __is_nothrow_move_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_assignable : public __bool_constant<__is_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_assignable_impl;
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_copy_assignable : public __is_copy_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_assignable_impl;
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_move_assignable : public __is_move_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> using __is_nothrow_assignable_impl = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;
    template <typename _Tp, typename _Up> struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_copy_assignable_impl;
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_move_assignable_impl;
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct is_trivially_constructible : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_default_constructible : public __bool_constant<__is_trivially_constructible(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_implicitly_default_constructible_impl {
        template <typename _Tp> static void __helper(const _Tp &);
        template <typename _Tp> static std::true_type __test(const _Tp &, decltype(__helper<const _Tp &>({})) * = 0);
        static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_impl : public std::__do_is_implicitly_default_constructible_impl {
        typedef decltype(__test(declval<_Tp>())) type;
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_implicitly_default_constructible : public __and_<__is_constructible_impl<_Tp>, __is_implicitly_default_constructible_safe<_Tp>> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_constructible_impl;
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, true> : public __and_<__is_copy_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp &)>> {
    };
    template <typename _Tp> struct is_trivially_copy_constructible : public __is_trivially_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_constructible_impl;
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, true> : public __and_<__is_move_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, _Tp &&)>> {
    };
    template <typename _Tp> struct is_trivially_move_constructible : public __is_trivially_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_trivially_assignable : public __bool_constant<__is_trivially_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_assignable_impl;
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_trivially_copy_assignable : public __is_trivially_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_assignable_impl;
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_trivially_move_assignable : public __is_trivially_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_destructible : public __and_<__is_destructible_safe<_Tp>, __bool_constant<__has_trivial_destructor(_Tp)>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename> struct rank : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, std::size_t _Size> struct rank<_Tp[_Size]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename _Tp> struct rank<_Tp[]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename, unsigned int _Uint = 0> struct extent : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, unsigned int _Uint, std::size_t _Size> struct extent<_Tp[_Size], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, unsigned int _Uint> struct extent<_Tp[], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, typename _Up> struct is_same : public integral_constant<bool, __is_same(_Tp, _Up)> {
    };
    template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    };
    template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    };
    template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    };
    template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    };
    template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    };
    template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    };
    template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    };
    template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Base, typename _Derived> struct is_base_of : public integral_constant<bool, __is_base_of(_Base, _Derived)> {
    };
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_convertible_helper {
        typedef typename is_void<_To>::type type;
    };
    template<> class __is_convertible_helper<std::random_access_iterator_tag, std::input_iterator_tag, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::input_iterator_tag>(std::input_iterator_tag) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<std::random_access_iterator_tag, std::input_iterator_tag, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<std::random_access_iterator_tag, std::input_iterator_tag>(...);
    public:
        typedef decltype(__test<std::random_access_iterator_tag, std::input_iterator_tag>(0)) type;
    };
    template<> class __is_convertible_helper<char *, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char *, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *, const char *>(...);
    public:
        typedef decltype(__test<char *, const char *>(0)) type;
    };
    template<> class __is_convertible_helper<const char *, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *, const char *>(...);
    public:
        typedef decltype(__test<const char *, const char *>(0)) type;
    };
    template<> class __is_convertible_helper<char *, char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<char *>(char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char *, char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *, char *>(...);
    public:
        typedef decltype(__test<char *, char *>(0)) type;
    };
    template <typename _From, typename _To> class __is_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        typedef decltype(__test<_From, _To>(0)) type;
    };
    template <typename _From, typename _To> struct is_convertible : public __is_convertible_helper<_From, _To>::type {
    };
    template<> struct is_convertible<std::random_access_iterator_tag, std::input_iterator_tag> : public __is_convertible_helper<random_access_iterator_tag, input_iterator_tag>::type {
    };
    template<> struct is_convertible<char *, const char *> : public __is_convertible_helper<char *, const char *>::type {
    };
    template<> struct is_convertible<const char *, const char *> : public __is_convertible_helper<const char *, const char *>::type {
    };
    template<> struct is_convertible<char *, char *> : public __is_convertible_helper<char *, char *>::type {
    };
    template <typename _ToElementType, typename _FromElementType> using __is_array_convertible = is_convertible<_FromElementType (*)[], _ToElementType (*)[]>;
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_nt_convertible_helper : is_void<_To> {
    };
    template <typename _From, typename _To> class __is_nt_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1> static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))> __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        using type = decltype(__test<_From, _To>(0));
    };
    template <typename _From, typename _To> struct __is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {
    };
    template <typename _Tp> struct remove_const {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_const<const _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile<volatile _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_cv {
        using type = _Tp;
    };
    template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    };
    template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    };
    template<> struct remove_cv<char16_t> {
        using type = char16_t;
    };
    template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    };
    template<> struct remove_cv<char32_t> {
        using type = char32_t;
    };
    template<> struct remove_cv<void> {
        using type = void;
    };
    template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    };
    template<> struct remove_cv<unsigned long long> {
        using type = unsigned long long;
    };
    template<> struct remove_cv<std::allocator<char>> {
        using type = std::allocator<char>;
    };
    template<> struct remove_cv<char> {
        using type = char;
    };
    template<> struct remove_cv<const char> {
        using type = char;
    };
    template<> struct remove_cv<std::random_access_iterator_tag> {
        using type = std::random_access_iterator_tag;
    };
    template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    };
    template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    };
    template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    };
    template<> struct remove_cv<char *> {
        using type = char *;
    };
    template<> struct remove_cv<const char *> {
        using type = const char *;
    };
    template <typename _Tp> struct remove_cv<const _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<const volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct add_const {
        typedef const _Tp type;
    };
    template <typename _Tp> struct add_volatile {
        typedef volatile _Tp type;
    };
    template <typename _Tp> struct add_cv {
        typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
    };
    template <typename _Tp> using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;
    template <typename _Tp> struct remove_reference {
        typedef _Tp type;
    };
    template<> struct remove_reference<std::basic_stringstream<char> &> {
        typedef std::basic_stringstream<char> type;
    };
    template<> struct remove_reference<std::basic_ostream<char> &> {
        typedef std::basic_ostream<char> type;
    };
    template<> struct remove_reference<std::allocator<char> &> {
        typedef std::allocator<char> type;
    };
    template<> struct remove_reference<std::allocator<wchar_t> &> {
        typedef std::allocator<wchar_t> type;
    };
    template<> struct remove_reference<std::allocator<char16_t> &> {
        typedef std::allocator<char16_t> type;
    };
    template<> struct remove_reference<std::allocator<char32_t> &> {
        typedef std::allocator<char32_t> type;
    };
    template<> struct remove_reference<std::basic_string<char> &> {
        typedef std::basic_string<char> type;
    };
    template <typename _Tp> struct remove_reference<_Tp &> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_reference<_Tp &&> {
        typedef _Tp type;
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_lvalue_reference_helper<_Tp, true> {
        typedef _Tp &type;
    };
    template <typename _Tp> struct add_lvalue_reference : public __add_lvalue_reference_helper<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_rvalue_reference_helper<_Tp, true> {
        typedef _Tp &&type;
    };
    template <typename _Tp> struct add_rvalue_reference : public __add_rvalue_reference_helper<_Tp> {
    };
    template <typename _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
    template <typename _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
    template <typename _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
    template <typename _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector
    template<> struct __cv_selector<unsigned int, false, false> {
        typedef unsigned int __type;
    }
    template<> struct __cv_selector<unsigned short, false, false> {
        typedef unsigned short __type;
    }
    template<> struct __cv_selector<int, false, false> {
        typedef int __type;
    }
    template<> struct __cv_selector<short, false, false> {
        typedef short __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, false> {
        typedef _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, true> {
        typedef volatile _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, false> {
        typedef const _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, true> {
        typedef const volatile _Unqualified __type;
    };
    template <typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value> class __match_cv_qualifiers {
        typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<wchar_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char16_t, unsigned short, false, false> {
        typedef __cv_selector<unsigned short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char32_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<unsigned int, int, false, false> {
        typedef __cv_selector<int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<unsigned short, short, false, false> {
        typedef __cv_selector<short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template <typename _Tp> struct __make_unsigned {
        typedef _Tp __type;
    };
    template<> struct __make_unsigned<char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<signed char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<short> {
        typedef unsigned short __type;
    };
    template<> struct __make_unsigned<int> {
        typedef unsigned int __type;
    };
    template<> struct __make_unsigned<long> {
        typedef unsigned long __type;
    };
    template<> struct __make_unsigned<long long> {
        typedef unsigned long long __type;
    };
    template<> struct __make_unsigned<__int128> {
        typedef unsigned __int128 __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_unsigned_selector
    template<> class __make_unsigned_selector<wchar_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(wchar_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char16_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char16_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char32_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char32_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<wchar_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<wchar_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char16_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char16_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char32_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char32_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    class __make_unsigned_selector_base {
    protected:
        template <typename ...> struct _List {
        };
        template<> struct _List<<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned short, unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned char);
        };
        template<> struct _List<<unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned short);
        };
        template<> struct _List<<unsigned int, unsigned long, unsigned long long>> : _List<unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned int);
        };
        template<> struct _List<<unsigned long, unsigned long long>> : _List<unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned long);
        };
        template<> struct _List<<unsigned long long>> : _List<> {
            static constexpr std::size_t __size = sizeof(unsigned long long);
        };
        template<> struct _List<<>> {
        };
        template <typename _Tp, typename ..._Up> struct _List<_Tp, _Up...> : _List<_Up...> {
            static constexpr std::size_t __size = sizeof(_Tp);
        };
        template <std::size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)> struct __select
        template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
        template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned int, unsigned long, unsigned long long>> {
        }
        template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned int;
        }
        template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
        template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned short;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, true> {
            using __type = _Uint;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, false> : __select<_Sz, _List<_UInts...>> {
        };
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    template<> struct __make_unsigned<wchar_t> {
        using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
    constexpr bool value;
    template<> struct __make_unsigned<char16_t> {
        using __type = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char32_t> {
        using __type = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_unsigned {
        typedef typename __make_unsigned_selector<_Tp>::__type type;
    };
    template<> struct make_unsigned<bool>;
    template <typename _Tp> struct __make_signed {
        typedef _Tp __type;
    };
    template<> struct __make_signed<char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned short> {
        typedef short __type;
    };
    template<> struct __make_signed<unsigned int> {
        typedef int __type;
    };
    template<> struct __make_signed<unsigned long> {
        typedef long __type;
    };
    template<> struct __make_signed<unsigned long long> {
        typedef long long __type;
    };
    template<> struct __make_signed<unsigned __int128> {
        typedef __int128 __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_signed_selector
    template<> class __make_signed_selector<wchar_t, false, true> {
        typedef typename __make_unsigned_selector<wchar_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
    template<> class __make_signed_selector<unsigned int, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned int>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned int, __signed_type>::__type;
    }
    template<> class __make_signed_selector<char16_t, false, true> {
        typedef typename __make_unsigned_selector<char16_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
    template<> class __make_signed_selector<unsigned short, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned short>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned short, __signed_type>::__type;
    }
    template<> class __make_signed_selector<char32_t, false, true> {
        typedef typename __make_unsigned_selector<char32_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
        typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template<> struct __make_signed<wchar_t> {
        using __type = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
    constexpr bool value;
    template<> struct __make_signed<char16_t> {
        using __type = typename __make_signed_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_signed<char32_t> {
        using __type = typename __make_signed_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_signed {
        typedef typename __make_signed_selector<_Tp>::__type type;
    };
    template<> struct make_signed<bool>;
    template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;
    template <typename _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
    template <typename _Tp> struct remove_extent {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp[_Size]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_extent<_Tp[]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_all_extents {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_all_extents<_Tp[_Size]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> struct remove_all_extents<_Tp[]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
    template <typename _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
    template <typename _Tp, typename> struct __remove_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp, typename _Up> struct __remove_pointer_helper<_Tp, _Up *> {
        typedef _Up type;
    };
    template <typename _Tp> struct remove_pointer : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {
    };
    template <typename _Tp, bool = __or_<__is_referenceable<_Tp>, is_void<_Tp>>::value> struct __add_pointer_helper {
        typedef _Tp type;
    };
    template<> struct __add_pointer_helper<std::basic_stringstream<char> &, true> {
        typedef typename remove_reference<basic_stringstream<char> &>::type *type;
    };
    template<> struct __add_pointer_helper<std::basic_ostream<char> &, true> {
        typedef typename remove_reference<basic_ostream<char> &>::type *type;
    };
    template <typename _Tp> struct __add_pointer_helper<_Tp, true> {
        typedef typename remove_reference<_Tp>::type *type;
    };
    template <typename _Tp> struct add_pointer : public __add_pointer_helper<_Tp> {
    };
    template<> struct add_pointer<std::basic_stringstream<char> &> : public __add_pointer_helper<std::basic_stringstream<char> &> {
    };
    template<> struct add_pointer<std::basic_ostream<char> &> : public __add_pointer_helper<std::basic_ostream<char> &> {
    };
    template <typename _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
    template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
    template <std::size_t _Len> struct __aligned_storage_msa {
        union __type {
            unsigned char __data[_Len];
            struct __attribute__((aligned)) {
            } __align;
        };
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> struct aligned_storage {
        union type {
            unsigned char __data[_Len];
            struct __attribute__((aligned((_Align)))) {
            } __align;
        };
    };
    template <typename ..._Types> struct __strictest_alignment {
        static const std::size_t _S_alignment = 0;
        static const std::size_t _S_size = 0;
    };
    template <typename _Tp, typename ..._Types> struct __strictest_alignment<_Tp, _Types...> {
        static const std::size_t _S_alignment = alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
        static const std::size_t _S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
    template <std::size_t _Len, typename ..._Types> struct aligned_union {
    private:
        static_assert(sizeof...(_Types) != 0, "At least one type is required");
        using __strictest = __strictest_alignment<_Types...>;
        static const std::size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;
    public:
        static const std::size_t alignment_value = __strictest::_S_alignment;
        typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };
    const std::size_t alignment_value;
    template <typename _Up, bool _IsArray = is_array<_Up>::value, bool _IsFunction = is_function<_Up>::value> struct __decay_selector;
    template <typename _Up> struct __decay_selector<_Up, false, false> {
        typedef __remove_cv_t<_Up> __type;
    };
    template <typename _Up> struct __decay_selector<_Up, true, false> {
        typedef typename remove_extent<_Up>::type *__type;
    };
    template <typename _Up> struct __decay_selector<_Up, false, true> {
        typedef typename add_pointer<_Up>::type __type;
    };
    template <typename _Tp> class decay {
        typedef typename remove_reference<_Tp>::type __remove_type;
    public:
        typedef typename __decay_selector<__remove_type>::__type type;
    };
    template <typename _Tp> struct __strip_reference_wrapper {
        typedef _Tp __type;
    };
    template <typename _Tp> struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
        typedef _Tp &__type;
    };
    template <typename _Tp> using __decay_t = typename decay<_Tp>::type;
    template <typename _Tp> using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;
    template <bool, typename _Tp = void> struct enable_if {
    };
    template<> struct enable_if<false, void> {
    };
    template<> struct enable_if<false, std::error_code &> {
    };
    template<> struct enable_if<true, void> {
        typedef void type;
    };
    template<> struct enable_if<false, int> {
    };
    template<> struct enable_if<true, int> {
        typedef int type;
    };
    template <typename _Tp> struct enable_if<true, _Tp> {
        typedef _Tp type;
    };
    template <bool _Cond, typename _Tp = void> using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <typename ..._Cond> using _Require = __enable_if_t<__and_<_Cond...>::value>;
    template <typename _Tp> using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> struct conditional {
        typedef _Iftrue type;
    };
    template <typename _Iftrue, typename _Iffalse> struct conditional<false, _Iftrue, _Iffalse> {
        typedef _Iffalse type;
    };
    template <typename ..._Tp> struct common_type;
    struct __do_common_type_impl {
        template <typename _Tp, typename _Up> using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());
        template <typename _Tp, typename _Up> static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test_2(...);
        template <typename _Tp, typename _Up> static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
    };
    template<> struct common_type<> {
    };
    template <typename _Tp0> struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {
    };
    template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>> struct __common_type_impl {
        using type = common_type<_Dp1, _Dp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2> : private std::__do_common_type_impl {
        using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };
    template <typename _Tp1, typename _Tp2> struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {
    };
    template <typename ...> struct __common_type_pack {
    };
    template <typename, typename, typename = void> struct __common_type_fold;
    template <typename _Tp1, typename _Tp2, typename ..._Rp> struct common_type<_Tp1, _Tp2, _Rp...> : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>> {
    };
    template <typename _CTp, typename ..._Rp> struct __common_type_fold<_CTp, __common_type_pack<_Rp...>, __void_t<typename _CTp::type>> : public common_type<typename _CTp::type, _Rp...> {
    };
    template <typename _CTp, typename _Rp> struct __common_type_fold<_CTp, _Rp, void> {
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl {
        using type = __underlying_type(_Tp);
    };
    template <typename _Tp> struct __underlying_type_impl<_Tp, false> {
    };
    template <typename _Tp> struct underlying_type : public __underlying_type_impl<_Tp> {
    };
    template <typename _Tp> struct __declval_protector {
        static const bool __stop = false;
    };
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0)) {
        static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
        return __declval<_Tp>(0);
    }
    template<> auto declval<std::random_access_iterator_tag>() noexcept -> decltype(__declval<std::random_access_iterator_tag>(0))    template<> auto declval<char *>() noexcept -> decltype(__declval<char *>(0))    template<> auto declval<const char *>() noexcept -> decltype(__declval<const char *>(0))    template <typename _Signature> struct result_of;
    struct __invoke_memfun_ref {
    };
    struct __invoke_memfun_deref {
    };
    struct __invoke_memobj_ref {
    };
    struct __invoke_memobj_deref {
    };
    struct __invoke_other {
    };
    template <typename _Tp, typename _Tag> struct __result_of_success : __success_type<_Tp> {
        using __invoke_type = _Tag;
    };
    struct __result_of_memfun_ref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype((std::declval<_Tp1>() .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_ref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_ref : private std::__result_of_memfun_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memfun_deref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype(((*std::declval<_Tp1>()) .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_deref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_deref : private std::__result_of_memfun_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memobj_ref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype(std::declval<_Tp1>() .* std::declval<_Fp>()), std::__invoke_memobj_ref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_ref : private std::__result_of_memobj_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    struct __result_of_memobj_deref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype((*std::declval<_Tp1>()) .* std::declval<_Fp>()), std::__invoke_memobj_deref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_deref : private std::__result_of_memobj_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj;
    template <typename _Res, typename _Class, typename _Arg> struct __result_of_memobj<_Res _Class::*, _Arg> {
        typedef __remove_cvref_t<_Arg> _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename __conditional_t<__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value, __result_of_memobj_ref<_MemPtr, _Arg>, __result_of_memobj_deref<_MemPtr, _Arg>>::type type;
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun;
    template <typename _Res, typename _Class, typename _Arg, typename ..._Args> struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
        typedef typename remove_reference<_Arg>::type _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename __conditional_t<is_base_of<_Class, _Argval>::value, __result_of_memfun_ref<_MemPtr, _Arg, _Args...>, __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type type;
    };
    template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>> struct __inv_unwrap {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
        using type = _Up &;
    };
    template <bool, bool, typename _Functor, typename ..._ArgTypes> struct __result_of_impl {
        typedef std::__failure_type type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_impl<true, false, _MemPtr, _Arg> : public __result_of_memobj<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type> {
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...> : public __result_of_memfun<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type, _Args...> {
    };
    struct __result_of_other_impl {
        template <typename _Fn, typename ..._Args> static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)), std::__invoke_other> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _Functor, typename ..._ArgTypes> struct __result_of_impl<false, false, _Functor, _ArgTypes...> : private std::__result_of_other_impl {
        typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };
    template <typename _Functor, typename ..._ArgTypes> struct __invoke_result : public __result_of_impl<is_member_object_pointer<typename remove_reference<_Functor>::type>::value, is_member_function_pointer<typename remove_reference<_Functor>::type>::value, _Functor, _ArgTypes...>::type {
    };
    template <typename _Functor, typename ..._ArgTypes> struct result_of<_Functor (_ArgTypes...)> : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <std::size_t _Len, typename ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <typename _Tp> using decay_t = typename decay<_Tp>::type;
    template <bool _Cond, typename _Tp = void> using enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
    template <typename ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
    template <typename _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
    template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;
    template <typename ...> using void_t = void;
    template <typename _Default, typename _AlwaysVoid, template <typename ...> class _Op, typename ..._Args> struct __detector {
        using value_t = std::false_type;
        using type = _Default;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {
        using value_t = std::true_type;
        using type = _Op<_Args...>;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or = __detector<_Default, void, _Op, _Args...>;
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
    template <typename _Tp> struct __is_swappable;
    template <typename _Tp> struct __is_nothrow_swappable;
    template <typename> struct __is_tuple_like_impl : std::false_type {
    };
    template <typename _Tp> struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {
    };
    template <typename _Tp> inline _Require<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>> swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value);
    template <typename _Tp, std::size_t _Nm> inline __enable_if_t<__is_swappable<_Tp>::value> swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);
    namespace __swappable_details {
        using std::swap;
        struct __do_is_swappable_impl {
            template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_impl {
            template <typename _Tp> static __bool_constant<noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> __test(int);
            template <typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp> struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_swappable : public __is_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct is_swappable : public __is_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool is_swappable_v = is_swappable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
    namespace __swappable_with_details {
        using std::swap;
        struct __do_is_swappable_with_impl {
            template <typename _Tp, typename _Up, typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())), typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))> static std::true_type __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_with_impl {
            template <typename _Tp, typename _Up> static __bool_constant<noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) && noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))> __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp, typename _Up> struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>({})), "second template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>({})), "second template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
    template <typename _Result, typename _Ret, bool = is_void<_Ret>::value, typename = void> struct __is_invocable_impl : std::false_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, true, __void_t<typename _Result::type>> : std::true_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, false, __void_t<typename _Result::type>> {
    private:
        static typename _Result::type _S_get();
        template <typename _Tp> static void _S_conv(_Tp);
        template <typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))> static std::true_type _S_test(int);
        template <typename _Tp> static std::false_type _S_test(...);
    public:
        using type = decltype(_S_test<_Ret>(1));
    };
    template <typename _Fn, typename ..._ArgTypes> struct __is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
    };
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_ref) {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept((std::declval<_Up>() .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_deref) {
        return noexcept(((*std::declval<_Tp>()) .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_ref) {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept(std::declval<_Up>() .* std::declval<_Fn>());
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_deref) {
        return noexcept((*std::declval<_Tp>()) .* std::declval<_Fn>());
    }
    template <typename _Fn, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_other) {
        return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }
    template <typename _Result, typename _Fn, typename ..._Args> struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type({}))> {
    };
    template <typename _Fn, typename ..._Args> using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
    template <typename _Fn, typename ..._Args> struct __is_nothrow_invocable : __and_<__is_invocable<_Fn, _Args...>, __call_is_nothrow_<_Fn, _Args...>>::type {
    };
    struct __nonesuchbase {
    };
    struct __nonesuch : private std::__nonesuchbase {
        ~__nonesuch() = delete
        __nonesuch(const std::__nonesuch &) = delete
        void operator=(const std::__nonesuch &) = delete
    };
}
namespace std {
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept {
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &&__t) noexcept {
        static_assert(!std::is_lvalue_reference<_Tp>::value, "std::forward must not be used to convert an rvalue to an lvalue");
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept {
        return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char> &>::type &&move<std::allocator<char> &>(std::allocator<char> &__t) noexcept {
        return static_cast<typename std::remove_reference<allocator<char> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<wchar_t> &>::type &&move<std::allocator<wchar_t> &>(std::allocator<wchar_t> &__t) noexcept {
        return static_cast<typename std::remove_reference<allocator<wchar_t> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char16_t> &>::type &&move<std::allocator<char16_t> &>(std::allocator<char16_t> &__t) noexcept {
        return static_cast<typename std::remove_reference<allocator<char16_t> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char32_t> &>::type &&move<std::allocator<char32_t> &>(std::allocator<char32_t> &__t) noexcept {
        return static_cast<typename std::remove_reference<allocator<char32_t> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<basic_string<char> &>::type &&move<std::basic_string<char> &>(std::basic_string<char> &__t) noexcept {
        return static_cast<typename std::remove_reference<basic_string<char> &>::type &&>(__t);
    }
    template <typename _Tp> struct __move_if_noexcept_cond : public __and_<__not_<is_nothrow_move_constructible<_Tp>>, is_copy_constructible<_Tp>>::type {
    };
    template <typename _Tp> constexpr __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&> move_if_noexcept(_Tp &__x) noexcept {
        return std::move(__x);
    }
    template <typename _Tp> inline _Tp *addressof(_Tp &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline char *addressof<char>(char &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline const char *addressof<const char>(const char &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline wchar_t *addressof<wchar_t>(wchar_t &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline const wchar_t *addressof<const wchar_t>(const wchar_t &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline char16_t *addressof<char16_t>(char16_t &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline const char16_t *addressof<const char16_t>(const char16_t &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline char32_t *addressof<char32_t>(char32_t &__r) noexcept {
        return std::__addressof(__r);
    }
    template<> inline const char32_t *addressof<const char32_t>(const char32_t &__r) noexcept {
        return std::__addressof(__r);
    }
    template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete    template<> const char *addressof<char>(const char &&) = delete    template<> const wchar_t *addressof<wchar_t>(const wchar_t &&) = delete    template<> const char16_t *addressof<char16_t>(const char16_t &&) = delete    template<> const char32_t *addressof<char32_t>(const char32_t &&) = delete
    template <typename _Tp, typename _Up = _Tp> inline _Tp __exchange(_Tp &__obj, _Up &&__new_val) {
        _Tp __old_val = std::move(__obj);
        __obj = std::forward<_Up>(__new_val);
        return __old_val;
    }
    template <typename _Tp> inline typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value>::type swap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value) {
        _Tp __tmp = std::move(__a);
        __a = std::move(__b);
        __b = std::move(__tmp);
    }
    template <typename _Tp, std::size_t _Nm> inline typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value) {
        for (std::size_t __n = 0; __n < _Nm; ++__n)
            swap(__a[__n], __b[__n]);
    }
}
extern "C++" {
    namespace std {
        class type_info;
        namespace __exception_ptr {
            class exception_ptr;
        }
        using __exception_ptr::exception_ptr;
        std::__exception_ptr::exception_ptr current_exception() noexcept;
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex) noexcept;
        void rethrow_exception(std::__exception_ptr::exception_ptr);
        namespace __exception_ptr {
            using std::rethrow_exception;
            class exception_ptr {
                void *_M_exception_object;
                explicit exception_ptr(void *__e) noexcept;
                void _M_addref() noexcept;
                void _M_release() noexcept;
                void *_M_get() const noexcept __attribute__((pure));
                friend std::__exception_ptr::exception_ptr std::current_exception() noexcept;
                friend void std::rethrow_exception(std::__exception_ptr::exception_ptr);
                friend template <typename _Ex> std::__exception_ptr::exception_ptr std::make_exception_ptr(_Ex) noexcept;
            public:
                exception_ptr() noexcept;
                exception_ptr(const std::__exception_ptr::exception_ptr &) noexcept;
                exception_ptr(std::nullptr_t) noexcept : _M_exception_object(nullptr) {
                }
                exception_ptr(std::__exception_ptr::exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object) {
                    __o._M_exception_object = nullptr;
                }
                std::__exception_ptr::exception_ptr &operator=(const std::__exception_ptr::exception_ptr &) noexcept;
                std::__exception_ptr::exception_ptr &operator=(std::__exception_ptr::exception_ptr &&__o) noexcept {
                    std::__exception_ptr::exception_ptr(static_cast<std::__exception_ptr::exception_ptr &&>(__o)).swap(*this);
                    return *this;
                }
                ~exception_ptr() noexcept;
                void swap(std::__exception_ptr::exception_ptr &) noexcept;
                explicit operator bool() const noexcept {
                    return this->_M_exception_object;
                }
                friend bool operator==(const std::__exception_ptr::exception_ptr &__x, const std::__exception_ptr::exception_ptr &__y) noexcept {
                    return __x._M_exception_object == __y._M_exception_object;
                }
;
                friend bool operator!=(const std::__exception_ptr::exception_ptr &__x, const std::__exception_ptr::exception_ptr &__y) noexcept {
                    return __x._M_exception_object != __y._M_exception_object;
                }
;
                const class std::type_info *__cxa_exception_type() const noexcept __attribute__((pure));
            };
            inline exception_ptr::exception_ptr() noexcept : _M_exception_object(0) {
            }
            inline exception_ptr::exception_ptr(const std::__exception_ptr::exception_ptr &__other) noexcept : _M_exception_object(__other._M_exception_object) {
                if (this->_M_exception_object)
                    this->_M_addref();
            }
            inline exception_ptr::~exception_ptr() noexcept {
                if (this->_M_exception_object)
                    this->_M_release();
            }
            inline std::__exception_ptr::exception_ptr &exception_ptr::operator=(const std::__exception_ptr::exception_ptr &__other) noexcept {
                std::__exception_ptr::exception_ptr(__other).swap(*this);
                return *this;
            }
            inline void exception_ptr::swap(std::__exception_ptr::exception_ptr &__other) noexcept {
                void *__tmp = this->_M_exception_object;
                this->_M_exception_object = __other._M_exception_object;
                __other._M_exception_object = __tmp;
            }
            inline void swap(std::__exception_ptr::exception_ptr &__lhs, std::__exception_ptr::exception_ptr &__rhs) {
                __lhs.swap(__rhs);
            }
            template <typename _Ex> inline void __dest_thunk(void *__x) {
                static_cast<_Ex *>(__x)->~_Ex();
            }
        }
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept {
            using _Ex2 = typename decay<_Ex>::type;
            void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
            (void)__cxxabiv1::__cxa_init_primary_exception(__e, const_cast<std::type_info *>(&typeid(_Ex)), __exception_ptr::__dest_thunk<_Ex2>);
            try {
                ::new (__e) _Ex2((__ex));
                return std::__exception_ptr::exception_ptr(__e);
            } catch (...) {
                __cxxabiv1::__cxa_free_exception(__e);
                return current_exception();
            }
        }
    }
}
extern "C++" {
    namespace std {
        class nested_exception {
            std::__exception_ptr::exception_ptr _M_ptr;
        public:
            nested_exception() noexcept : _M_ptr(current_exception()) {
            }
            nested_exception(const std::nested_exception &) noexcept = default
            std::nested_exception &operator=(const std::nested_exception &) noexcept = default
            virtual ~nested_exception() noexcept;
            void rethrow_nested() const [[noreturn]] {
                if (this->_M_ptr)
                    rethrow_exception(this->_M_ptr);
                std::terminate();
            }
            std::__exception_ptr::exception_ptr nested_ptr() const noexcept {
                return this->_M_ptr;
            }
        };
        template <typename _Except> struct _Nested_exception : public _Except, public std::nested_exception {
            explicit _Nested_exception<_Except>(const _Except &__ex) : _Except(__ex) {
            }
            explicit _Nested_exception<_Except>(_Except &&__ex) : _Except(static_cast<_Except &&>(__ex)) {
            }
        };
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::true_type) [[noreturn]] {
            using _Up = typename remove_reference<_Tp>::type;
            throw _Nested_exception<_Up>({std::forward<_Tp>(__t)});
        }
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::false_type) [[noreturn]] {
            throw std::forward<_Tp>(__t);
        }
        template <typename _Tp> inline void throw_with_nested(_Tp &&__t) [[noreturn]] {
            using _Up = typename decay<_Tp>::type;
            using _CopyConstructible = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
            static_assert(_CopyConstructible::value, "throw_with_nested argument must be CopyConstructible");
            using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>, __not_<is_base_of<std::nested_exception, _Up>>>;
            std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest({}));
        }
        template <typename _Tp> using __rethrow_if_nested_cond = typename enable_if<__and_<is_polymorphic<_Tp>, __or_<__not_<is_base_of<nested_exception, _Tp>>, is_convertible<_Tp *, nested_exception *>>>::value>::type;
        template <typename _Ex> inline __rethrow_if_nested_cond<_Ex> __rethrow_if_nested_impl(const _Ex *__ptr) {
            if (auto __ne_ptr = dynamic_cast<const std::nested_exception *>(__ptr))
                __ne_ptr->rethrow_nested();
        }
        inline void __rethrow_if_nested_impl(const void *) {
        }
        template <typename _Ex> inline void rethrow_if_nested(const _Ex &__ex) {
            std::__rethrow_if_nested_impl(std::__addressof(__ex));
        }
    }
}
namespace __gnu_cxx {
    template <typename _CharT> struct _Char_types {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template <typename _CharT> struct char_traits {
        typedef _CharT char_type;
        typedef typename _Char_types<_CharT>::int_type int_type;
        typedef typename _Char_types<_CharT>::pos_type pos_type;
        typedef typename _Char_types<_CharT>::off_type off_type;
        typedef typename _Char_types<_CharT>::state_type state_type;
        static constexpr void assign(__gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2) {
            __c1 = __c2;
        }
        static constexpr bool eq(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2) {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2) {
            return __c1 < __c2;
        }
        static constexpr int compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits::char_type *__s);
        static constexpr const __gnu_cxx::char_traits::char_type *find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a);
        static __gnu_cxx::char_traits::char_type *move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits::char_type *copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits::char_type *assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a);
        static constexpr __gnu_cxx::char_traits::char_type to_char_type(const __gnu_cxx::char_traits::int_type &__c) {
            return static_cast<__gnu_cxx::char_traits::char_type>(__c);
        }
        static constexpr __gnu_cxx::char_traits::int_type to_int_type(const __gnu_cxx::char_traits::char_type &__c) {
            return static_cast<__gnu_cxx::char_traits::int_type>(__c);
        }
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits::int_type &__c1, const __gnu_cxx::char_traits::int_type &__c2) {
            return __c1 == __c2;
        }
        static constexpr __gnu_cxx::char_traits::int_type eof() {
            return static_cast<__gnu_cxx::char_traits::int_type>(-1);
        }
        static constexpr __gnu_cxx::char_traits::int_type not_eof(const __gnu_cxx::char_traits::int_type &__c) {
            return !eq_int_type(__c, eof()) ? __c : to_int_type(__gnu_cxx::char_traits::char_type());
        }
    };
    template <typename _CharT> constexpr int char_traits<_CharT>::compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n) {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (lt(__s1[__i], __s2[__i]))
                return -1;
            else if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }
    template <typename _CharT> constexpr std::size_t char_traits<_CharT>::length(const __gnu_cxx::char_traits::char_type *__p) {
        std::size_t __i = 0;
        while (!eq(__p[__i], __gnu_cxx::char_traits::char_type()))
            ++__i;
        return __i;
    }
    template <typename _CharT> constexpr const typename char_traits<_CharT>::char_type *char_traits<_CharT>::find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a) {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (eq(__s[__i], __a))
                return __s + __i;
        return 0;
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n) {
        if (__n == 0)
            return __s1;
        __builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits::char_type));
        return __s1;
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n) {
        __builtin_memcpy(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits::char_type));
        return __s1;
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a) {
        if (sizeof(_CharT) == 1 && __is_trivial(_CharT)) {
            unsigned char __c;
            __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
            __builtin_memset(__s, __c, __n);
        } else {
            for (std::size_t __i = 0; __i < __n; ++__i)
                __s[__i] = __a;
        }
        return __s;
    }
}
namespace std {
    template <typename _CharT> struct char_traits : public __gnu_cxx::char_traits<_CharT> {
    };
    template<> struct char_traits<char> {
        typedef char char_type;
        typedef int int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }
        static int compare(const std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return 0;
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static std::size_t length(const std::char_traits<char>::char_type *__s) {
            return __builtin_strlen(__s);
        }
        static const std::char_traits<char>::char_type *find(const std::char_traits<char>::char_type *__s, std::size_t __n, const std::char_traits<char>::char_type &__a) {
            if (__n == 0)
                return 0;
            return static_cast<const std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static std::char_traits<char>::char_type *move(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static std::char_traits<char>::char_type *copy(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static std::char_traits<char>::char_type *assign(std::char_traits<char>::char_type *__s, std::size_t __n, std::char_traits<char>::char_type __a) {
            if (__n == 0)
                return __s;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr std::char_traits<char>::char_type to_char_type(const std::char_traits<char>::int_type &__c) noexcept {
            return static_cast<std::char_traits<char>::char_type>(__c);
        }
        static constexpr std::char_traits<char>::int_type to_int_type(const std::char_traits<char>::char_type &__c) noexcept {
            return static_cast<std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
        }
        static constexpr bool eq_int_type(const std::char_traits<char>::int_type &__c1, const std::char_traits<char>::int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char>::int_type eof() noexcept {
            return static_cast<std::char_traits<char>::int_type>(-1);
        }
        static constexpr std::char_traits<char>::int_type not_eof(const std::char_traits<char>::int_type &__c) noexcept {
            return (__c == eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef std::streamoff off_type;
        typedef std::wstreampos pos_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept {
            return __c1 < __c2;
        }
        static int compare(const std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return 0;
            return wmemcmp(__s1, __s2, __n);
        }
        static std::size_t length(const std::char_traits<wchar_t>::char_type *__s) {
            return wcslen(__s);
        }
        static const std::char_traits<wchar_t>::char_type *find(const std::char_traits<wchar_t>::char_type *__s, std::size_t __n, const std::char_traits<wchar_t>::char_type &__a) {
            if (__n == 0)
                return 0;
            return wmemchr(__s, __a, __n);
        }
        static std::char_traits<wchar_t>::char_type *move(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return wmemmove(__s1, __s2, __n);
        }
        static std::char_traits<wchar_t>::char_type *copy(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return wmemcpy(__s1, __s2, __n);
        }
        static std::char_traits<wchar_t>::char_type *assign(std::char_traits<wchar_t>::char_type *__s, std::size_t __n, std::char_traits<wchar_t>::char_type __a) {
            if (__n == 0)
                return __s;
            return wmemset(__s, __a, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type to_char_type(const std::char_traits<wchar_t>::int_type &__c) noexcept {
            return std::char_traits<wchar_t>::char_type(__c);
        }
        static constexpr std::char_traits<wchar_t>::int_type to_int_type(const std::char_traits<wchar_t>::char_type &__c) noexcept {
            return std::char_traits<wchar_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<wchar_t>::int_type &__c1, const std::char_traits<wchar_t>::int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<wchar_t>::int_type eof() noexcept {
            return static_cast<std::char_traits<wchar_t>::int_type>((4294967295U));
        }
        static constexpr std::char_traits<wchar_t>::int_type not_eof(const std::char_traits<wchar_t>::int_type &__c) noexcept {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef struct {
    int __val[2];
} __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef long __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
namespace std {
    using ::int8_t;
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::int_fast8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::int_least8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uint8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::uint_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::uint_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::uintmax_t;
    using ::uintptr_t;
}
namespace std {
    template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef uint_least16_t int_type;
        typedef std::streamoff off_type;
        typedef std::u16streampos pos_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept {
            return __c1 < __c2;
        }
        static int compare(const std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static std::size_t length(const std::char_traits<char16_t>::char_type *__s) {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char16_t>::char_type()))
                ++__i;
            return __i;
        }
        static const std::char_traits<char16_t>::char_type *find(const std::char_traits<char16_t>::char_type *__s, std::size_t __n, const std::char_traits<char16_t>::char_type &__a) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static std::char_traits<char16_t>::char_type *move(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static std::char_traits<char16_t>::char_type *copy(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static std::char_traits<char16_t>::char_type *assign(std::char_traits<char16_t>::char_type *__s, std::size_t __n, std::char_traits<char16_t>::char_type __a) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char16_t>::char_type to_char_type(const std::char_traits<char16_t>::int_type &__c) noexcept {
            return std::char_traits<char16_t>::char_type(__c);
        }
        static constexpr std::char_traits<char16_t>::int_type to_int_type(const std::char_traits<char16_t>::char_type &__c) noexcept {
            return __c == eof() ? std::char_traits<char16_t>::int_type(65533) : std::char_traits<char16_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char16_t>::int_type &__c1, const std::char_traits<char16_t>::int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char16_t>::int_type eof() noexcept {
            return static_cast<std::char_traits<char16_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char16_t>::int_type not_eof(const std::char_traits<char16_t>::int_type &__c) noexcept {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef uint_least32_t int_type;
        typedef std::streamoff off_type;
        typedef std::u32streampos pos_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept {
            return __c1 < __c2;
        }
        static int compare(const std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static std::size_t length(const std::char_traits<char32_t>::char_type *__s) {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char32_t>::char_type()))
                ++__i;
            return __i;
        }
        static const std::char_traits<char32_t>::char_type *find(const std::char_traits<char32_t>::char_type *__s, std::size_t __n, const std::char_traits<char32_t>::char_type &__a) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static std::char_traits<char32_t>::char_type *move(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static std::char_traits<char32_t>::char_type *copy(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static std::char_traits<char32_t>::char_type *assign(std::char_traits<char32_t>::char_type *__s, std::size_t __n, std::char_traits<char32_t>::char_type __a) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char32_t>::char_type to_char_type(const std::char_traits<char32_t>::int_type &__c) noexcept {
            return std::char_traits<char32_t>::char_type(__c);
        }
        static constexpr std::char_traits<char32_t>::int_type to_int_type(const std::char_traits<char32_t>::char_type &__c) noexcept {
            return std::char_traits<char32_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char32_t>::int_type &__c1, const std::char_traits<char32_t>::int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char32_t>::int_type eof() noexcept {
            return static_cast<std::char_traits<char32_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char32_t>::int_type not_eof(const std::char_traits<char32_t>::int_type &__c) noexcept {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
extern "C" {
    struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        char int_p_cs_precedes;
        char int_p_sep_by_space;
        char int_n_cs_precedes;
        char int_n_sep_by_space;
        char int_p_sign_posn;
        char int_n_sign_posn;
    };
    extern char *setlocale(int __category, const char *__locale) noexcept(true);
    extern struct lconv *localeconv() noexcept(true);
    extern locale_t newlocale(int __category_mask, const char *__locale, locale_t __base) noexcept(true);
    extern locale_t duplocale(locale_t __dataset) noexcept(true);
    extern void freelocale(locale_t __dataset) noexcept(true);
    extern locale_t uselocale(locale_t __dataset) noexcept(true);
}
namespace std {
    using ::lconv;
    using ::setlocale;
    using ::localeconv;
}
namespace __gnu_cxx {
    extern "C" locale_t __uselocale(locale_t) noexcept(true)
}
namespace std {
    typedef __locale_t __c_locale;
    inline int __convert_from_v(const std::__c_locale &__cloc __attribute__((unused)), char *__out, const int __size __attribute__((unused)), const char *__fmt, ...) {
        std::__c_locale __old = __gnu_cxx::__uselocale(__cloc);
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
        __builtin_va_end(__args);
        __gnu_cxx::__uselocale(__old);
        return __ret;
    }
}
extern "C" {
    enum {
        _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
        _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
        _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
        _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
        _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
        _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
        _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
        _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
        _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
        _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
        _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
        _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
    };
    extern const unsigned short **__ctype_b_loc() noexcept(true) __attribute__((const));
    extern const __int32_t **__ctype_tolower_loc() noexcept(true) __attribute__((const));
    extern const __int32_t **__ctype_toupper_loc() noexcept(true) __attribute__((const));
    extern int isalnum(int) noexcept(true);
    extern int isalpha(int) noexcept(true);
    extern int iscntrl(int) noexcept(true);
    extern int isdigit(int) noexcept(true);
    extern int islower(int) noexcept(true);
    extern int isgraph(int) noexcept(true);
    extern int isprint(int) noexcept(true);
    extern int ispunct(int) noexcept(true);
    extern int isspace(int) noexcept(true);
    extern int isupper(int) noexcept(true);
    extern int isxdigit(int) noexcept(true);
    extern int tolower(int __c) noexcept(true);
    extern int toupper(int __c) noexcept(true);
    extern int isblank(int) noexcept(true);
    extern int isctype(int __c, int __mask) noexcept(true);
    extern int isascii(int __c) noexcept(true);
    extern int toascii(int __c) noexcept(true);
    extern int _toupper(int) noexcept(true);
    extern int _tolower(int) noexcept(true);
    extern int isalnum_l(int, locale_t) noexcept(true);
    extern int isalpha_l(int, locale_t) noexcept(true);
    extern int iscntrl_l(int, locale_t) noexcept(true);
    extern int isdigit_l(int, locale_t) noexcept(true);
    extern int islower_l(int, locale_t) noexcept(true);
    extern int isgraph_l(int, locale_t) noexcept(true);
    extern int isprint_l(int, locale_t) noexcept(true);
    extern int ispunct_l(int, locale_t) noexcept(true);
    extern int isspace_l(int, locale_t) noexcept(true);
    extern int isupper_l(int, locale_t) noexcept(true);
    extern int isxdigit_l(int, locale_t) noexcept(true);
    extern int isblank_l(int, locale_t) noexcept(true);
    extern int __tolower_l(int __c, locale_t __l) noexcept(true);
    extern int tolower_l(int __c, locale_t __l) noexcept(true);
    extern int __toupper_l(int __c, locale_t __l) noexcept(true);
    extern int toupper_l(int __c, locale_t __l) noexcept(true);
}
namespace std {
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;
}
namespace std {
    using ::isblank;
}
namespace std {
    class locale;
    template <typename _Facet> bool has_facet(const std::locale &) throw();
    template <typename _Facet> const _Facet &use_facet(const std::locale &);
    template <typename _CharT> bool isspace(_CharT, const std::locale &);
    template <typename _CharT> bool isprint(_CharT, const std::locale &);
    template <typename _CharT> bool iscntrl(_CharT, const std::locale &);
    template <typename _CharT> bool isupper(_CharT, const std::locale &);
    template <typename _CharT> bool islower(_CharT, const std::locale &);
    template <typename _CharT> bool isalpha(_CharT, const std::locale &);
    template <typename _CharT> bool isdigit(_CharT, const std::locale &);
    template <typename _CharT> bool ispunct(_CharT, const std::locale &);
    template <typename _CharT> bool isxdigit(_CharT, const std::locale &);
    template <typename _CharT> bool isalnum(_CharT, const std::locale &);
    template <typename _CharT> bool isgraph(_CharT, const std::locale &);
    template <typename _CharT> bool isblank(_CharT, const std::locale &);
    template <typename _CharT> _CharT toupper(_CharT, const std::locale &);
    template <typename _CharT> _CharT tolower(_CharT, const std::locale &);
    struct ctype_base;
    template <typename _CharT> class ctype;
    template<> class ctype<char>;
    template<> class ctype<wchar_t>;
    template <typename _CharT> class ctype_byname;
    class codecvt_base;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt;
    template<> class codecvt<char, char, mbstate_t>;
    template<> class codecvt<wchar_t, char, mbstate_t>;
    template<> class codecvt<char16_t, char, mbstate_t>;
    template<> class codecvt<char32_t, char, mbstate_t>;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt_byname;
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put;
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct;
        template <typename _CharT> class numpunct_byname;
    }
    inline namespace __cxx11 {
        template <typename _CharT> class collate;
        template <typename _CharT> class collate_byname;
    }
    class time_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get;
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get_byname;
    }
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put_byname;
    class money_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class money_get;
        template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class money_put;
    }
    inline namespace __cxx11 {
        template <typename _CharT, bool _Intl = false> class moneypunct;
        template <typename _CharT, bool _Intl = false> class moneypunct_byname;
    }
    struct messages_base;
    inline namespace __cxx11 {
        template <typename _CharT> class messages;
        template <typename _CharT> class messages_byname;
    }
}
typedef __time_t time_t;
struct timespec {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
};
typedef __pid_t pid_t;
struct sched_param {
    int sched_priority;
};
extern "C" {
    extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) noexcept(true);
    extern int unshare(int __flags) noexcept(true);
    extern int sched_getcpu() noexcept(true);
    extern int getcpu(unsigned int *, unsigned int *) noexcept(true);
    extern int setns(int __fd, int __nstype) noexcept(true);
}
typedef unsigned long __cpu_mask;
typedef struct {
    __cpu_mask __bits[16];
} cpu_set_t;
extern "C" {
    extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp) noexcept(true);
    extern cpu_set_t *__sched_cpualloc(size_t __count) noexcept(true);
    extern void __sched_cpufree(cpu_set_t *__set) noexcept(true);
}
extern "C" {
    extern int sched_setparam(__pid_t __pid, const struct sched_param *__param) noexcept(true);
    extern int sched_getparam(__pid_t __pid, struct sched_param *__param) noexcept(true);
    extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param) noexcept(true);
    extern int sched_getscheduler(__pid_t __pid) noexcept(true);
    extern int sched_yield() noexcept(true);
    extern int sched_get_priority_max(int __algorithm) noexcept(true);
    extern int sched_get_priority_min(int __algorithm) noexcept(true);
    extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t) noexcept(true);
    extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true);
    extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true);
}
struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};
struct timex {
    unsigned int modes;
    __syscall_slong_t offset;
    __syscall_slong_t freq;
    __syscall_slong_t maxerror;
    __syscall_slong_t esterror;
    int status;
    __syscall_slong_t constant;
    __syscall_slong_t precision;
    __syscall_slong_t tolerance;
    struct timeval time;
    __syscall_slong_t tick;
    __syscall_slong_t ppsfreq;
    __syscall_slong_t jitter;
    int shift;
    __syscall_slong_t stabil;
    __syscall_slong_t jitcnt;
    __syscall_slong_t calcnt;
    __syscall_slong_t errcnt;
    __syscall_slong_t stbcnt;
    int tai;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
};
extern "C" {
    extern int clock_adjtime(__clockid_t __clock_id, struct timex *__utx) noexcept(true);
}
typedef __clock_t clock_t;
struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    const char *tm_zone;
};
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};
struct sigevent;
extern "C" {
    extern clock_t clock() noexcept(true);
    extern time_t time(time_t *__timer) noexcept(true);
    extern double difftime(time_t __time1, time_t __time0) noexcept(true) __attribute__((const));
    extern time_t mktime(struct tm *__tp) noexcept(true);
    extern size_t strftime(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp) noexcept(true);
    extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp) noexcept(true);
    extern size_t strftime_l(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(true);
    extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp, locale_t __loc) noexcept(true);
    extern struct tm *gmtime(const time_t *__timer) noexcept(true);
    extern struct tm *localtime(const time_t *__timer) noexcept(true);
    extern struct tm *gmtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(true);
    extern struct tm *localtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(true);
    extern char *asctime(const struct tm *__tp) noexcept(true);
    extern char *ctime(const time_t *__timer) noexcept(true);
    extern char *asctime_r(const struct tm *__restrict __tp, char *__restrict __buf) noexcept(true);
    extern char *ctime_r(const time_t *__restrict __timer, char *__restrict __buf) noexcept(true);
    extern char *__tzname[2];
    extern int __daylight;
    extern long __timezone;
    extern char *tzname[2];
    extern void tzset() noexcept(true);
    extern int daylight;
    extern long timezone;
    extern time_t timegm(struct tm *__tp) noexcept(true);
    extern time_t timelocal(struct tm *__tp) noexcept(true);
    extern int dysize(int __year) noexcept(true) __attribute__((const));
    extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining);
    extern int clock_getres(clockid_t __clock_id, struct timespec *__res) noexcept(true);
    extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp) noexcept(true);
    extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp) noexcept(true);
    extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem);
    extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id) noexcept(true);
    extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) noexcept(true);
    extern int timer_delete(timer_t __timerid) noexcept(true);
    extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) noexcept(true);
    extern int timer_gettime(timer_t __timerid, struct itimerspec *__value) noexcept(true);
    extern int timer_getoverrun(timer_t __timerid) noexcept(true);
    extern int timespec_get(struct timespec *__ts, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern int timespec_getres(struct timespec *__ts, int __base) noexcept(true);
    extern int getdate_err;
    extern struct tm *getdate(const char *__string);
    extern int getdate_r(const char *__restrict __string, struct tm *__restrict __resbufp);
}
typedef union {
    unsigned long long __value64;
    struct {
        unsigned int __low;
        unsigned int __high;
    } __value32;
} __atomic_wide_counter;
typedef struct __pthread_internal_list {
    struct __pthread_internal_list *__prev;
    struct __pthread_internal_list *__next;
} __pthread_list_t;
typedef struct __pthread_internal_slist {
    struct __pthread_internal_slist *__next;
} __pthread_slist_t;
struct __pthread_mutex_s {
    int __lock;
    unsigned int __count;
    int __owner;
    unsigned int __nusers;
    int __kind;
    short __spins;
    short __elision;
    __pthread_list_t __list;
};
struct __pthread_rwlock_arch_t {
    unsigned int __readers;
    unsigned int __writers;
    unsigned int __wrphase_futex;
    unsigned int __writers_futex;
    unsigned int __pad3;
    unsigned int __pad4;
    int __cur_writer;
    int __shared;
    signed char __rwelision;
    unsigned char __pad1[7];
    unsigned long __pad2;
    unsigned int __flags;
};
struct __pthread_cond_s {
    __atomic_wide_counter __wseq;
    __atomic_wide_counter __g1_start;
    unsigned int __g_refs[2];
    unsigned int __g_size[2];
    unsigned int __g1_orig_size;
    unsigned int __wrefs;
    unsigned int __g_signals[2];
};
typedef unsigned int __tss_t;
typedef unsigned long __thrd_t;
typedef struct {
    int __data;
} __once_flag;
typedef unsigned long pthread_t;
typedef union {
    char __size[4];
    int __align;
} pthread_mutexattr_t;
typedef union {
    char __size[4];
    int __align;
} pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
    char __size[56];
    long __align;
};
typedef union pthread_attr_t pthread_attr_t;
typedef union {
    struct __pthread_mutex_s __data;
    char __size[40];
    long __align;
} pthread_mutex_t;
typedef union {
    struct __pthread_cond_s __data;
    char __size[48];
    long long __align;
} pthread_cond_t;
typedef union {
    struct __pthread_rwlock_arch_t __data;
    char __size[56];
    long __align;
} pthread_rwlock_t;
typedef union {
    char __size[8];
    long __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {
    char __size[32];
    long __align;
} pthread_barrier_t;
typedef union {
    char __size[4];
    int __align;
} pthread_barrierattr_t;
typedef long __jmp_buf[8];
typedef struct {
    unsigned long __val[16];
} __sigset_t;
struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
};
extern "C" {
    extern long __sysconf(int __name) noexcept(true);
}
enum {
    PTHREAD_CREATE_JOINABLE,
    PTHREAD_CREATE_DETACHED
};
enum {
    PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP,
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum {
    PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_ROBUST,
    PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};
enum {
    PTHREAD_PRIO_NONE,
    PTHREAD_PRIO_INHERIT,
    PTHREAD_PRIO_PROTECT
};
enum {
    PTHREAD_RWLOCK_PREFER_READER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum {
    PTHREAD_INHERIT_SCHED,
    PTHREAD_EXPLICIT_SCHED
};
enum {
    PTHREAD_SCOPE_SYSTEM,
    PTHREAD_SCOPE_PROCESS
};
enum {
    PTHREAD_PROCESS_PRIVATE,
    PTHREAD_PROCESS_SHARED
};
struct _pthread_cleanup_buffer {
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
enum {
    PTHREAD_CANCEL_ENABLE,
    PTHREAD_CANCEL_DISABLE
};
enum {
    PTHREAD_CANCEL_DEFERRED,
    PTHREAD_CANCEL_ASYNCHRONOUS
};
extern "C" {
    extern int pthread_create(pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) noexcept(true) __attribute__((nonnull(1, 3)));
    extern void pthread_exit(void *__retval);
    extern int pthread_join(pthread_t __th, void **__thread_return);
    extern int pthread_tryjoin_np(pthread_t __th, void **__thread_return) noexcept(true);
    extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return, const struct timespec *__abstime);
    extern int pthread_clockjoin_np(pthread_t __th, void **__thread_return, clockid_t __clockid, const struct timespec *__abstime);
    extern int pthread_detach(pthread_t __th) noexcept(true);
    extern pthread_t pthread_self() noexcept(true) __attribute__((const));
    extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) noexcept(true) __attribute__((const));
    extern int pthread_attr_init(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_destroy(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedparam(pthread_attr_t *__restrict __attr, const struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr, int *__restrict __policy) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr, int *__restrict __inherit) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getscope(const pthread_attr_t *__restrict __attr, int *__restrict __scope) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) noexcept(true) __attribute__((nonnull(1, 2))) __attribute__((deprecated("")));
    extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr) noexcept(true) __attribute__((nonnull(1))) __attribute__((deprecated("")));
    extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getstack(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, size_t *__restrict __stacksize) noexcept(true) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_getattr_default_np(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr, const __sigset_t *sigmask);
    extern int pthread_attr_getsigmask_np(const pthread_attr_t *__attr, __sigset_t *sigmask);
    extern int pthread_setattr_default_np(const pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_getattr_np(pthread_t __th, pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(2, 3)));
    extern int pthread_setschedprio(pthread_t __target_thread, int __prio) noexcept(true);
    extern int pthread_getname_np(pthread_t __target_thread, char *__buf, size_t __buflen) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_setname_np(pthread_t __target_thread, const char *__name) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_getconcurrency() noexcept(true);
    extern int pthread_setconcurrency(int __level) noexcept(true);
    extern int pthread_yield() noexcept(true);
    extern int pthread_yield() noexcept(true) asm("sched_yield") __attribute__((deprecated("pthread_yield is deprecated, use sched_yield instead")));
    extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((nonnull(1, 2)));
    extern int pthread_setcancelstate(int __state, int *__oldstate);
    extern int pthread_setcanceltype(int __type, int *__oldtype);
    extern int pthread_cancel(pthread_t __th);
    extern void pthread_testcancel();
    struct __cancel_jmp_buf_tag {
        __jmp_buf __cancel_jmp_buf;
        int __mask_was_saved;
    };
    typedef struct {
        struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
        void *__pad[4];
    } __pthread_unwind_buf_t __attribute__((aligned));
    struct __pthread_cleanup_frame {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    };
    class __pthread_cleanup_class {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    public:
        __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1) {
        }
        ~__pthread_cleanup_class() noexcept {
            if (this->__do_it)
                this->__cancel_routine(this->__cancel_arg);
        }
        void __setdoit(int __newval) {
            this->__do_it = __newval;
        }
        void __defer() {
            pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &this->__cancel_type);
        }
        void __restore() const {
            pthread_setcanceltype(this->__cancel_type, 0);
        }
    };
    extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask) noexcept(true);
    extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_lock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_clocklock(pthread_mutex_t *__restrict __mutex, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_consistent_np(pthread_mutex_t *) noexcept(true) asm("pthread_mutex_consistent") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")));
    extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_getrobust_np(pthread_mutexattr_t *, int *) noexcept(true) asm("pthread_mutexattr_getrobust") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")));
    extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *, int) noexcept(true) asm("pthread_mutexattr_setrobust") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")));
    extern int pthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_init(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_destroy(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_signal(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_broadcast(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __attribute__((nonnull(1, 2)));
    extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_cond_clockwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, __clockid_t __clock_id, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 4)));
    extern int pthread_condattr_init(pthread_condattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_destroy(pthread_condattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_destroy(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_lock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_trylock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_unlock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_wait(pthread_barrier_t *__barrier) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *)) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_key_delete(pthread_key_t __key) noexcept(true);
    extern void *pthread_getspecific(pthread_key_t __key) noexcept(true);
    extern int pthread_setspecific(pthread_key_t __key, const void *__pointer) noexcept(true);
    extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) noexcept(true);
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static inline int __gthread_active_p() {
    return 1;
}
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *__args) {
    return pthread_create(__threadid, __null, __func, __args);
}
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) {
    return pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(__gthread_t __threadid) {
    return pthread_detach(__threadid);
}
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) {
    return pthread_equal(__t1, __t2);
}
static inline __gthread_t __gthread_self() {
    return pthread_self();
}
static inline int __gthread_yield() {
    return sched_yield();
}
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)()) {
    if (__gthread_active_p())
        return pthread_once(__once, __func);
    else
        return -1;
}
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) {
    return pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(__gthread_key_t __key) {
    return pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(__gthread_key_t __key) {
    return pthread_getspecific(__key);
}
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) {
    return pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        pthread_mutex_init(__mutex, __null);
}
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_destroy(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_lock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_trylock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    if (__gthread_active_p())
        return pthread_mutex_timedlock(__mutex, __abs_timeout);
    else
        return 0;
}
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_unlock(__mutex);
    else
        return 0;
}
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) {
    return pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) {
    return pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) {
    return pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *__mutex) {
    return __gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) {
    return pthread_cond_destroy(__cond);
}
typedef int _Atomic_word;
extern "C" {
    extern char __libc_single_threaded;
}
namespace __gnu_cxx {
    inline bool __is_single_threaded() noexcept __attribute__((always_inline)) {
        return ::__libc_single_threaded;
    }
    inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        return __atomic_fetch_add(__mem, __val, 4);
    }
    inline void __atomic_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        __atomic_fetch_add(__mem, __val, 4);
    }
    inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        _Atomic_word __result = *__mem;
        *__mem += __val;
        return __result;
    }
    inline void __atomic_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        *__mem += __val;
    }
    inline _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        if (__is_single_threaded())
            return __exchange_and_add_single(__mem, __val);
        else
            return __exchange_and_add(__mem, __val);
    }
    inline void __atomic_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        if (__is_single_threaded())
            __atomic_add_single(__mem, __val);
        else
            __atomic_add(__mem, __val);
    }
}
namespace std {
    void __throw_bad_exception();
    void __throw_bad_alloc();
    void __throw_bad_array_new_length();
    void __throw_bad_cast();
    void __throw_bad_typeid();
    void __throw_logic_error(const char *);
    void __throw_domain_error(const char *);
    void __throw_invalid_argument(const char *);
    void __throw_length_error(const char *);
    void __throw_out_of_range(const char *);
    void __throw_out_of_range_fmt(const char *, ...);
    void __throw_runtime_error(const char *);
    void __throw_range_error(const char *);
    void __throw_overflow_error(const char *);
    void __throw_underflow_error(const char *);
    void __throw_ios_failure(const char *);
    void __throw_ios_failure(const char *, int);
    void __throw_system_error(int);
    void __throw_future_error(int);
    void __throw_bad_function_call();
}
namespace std {
    template <typename _Tp> class __new_allocator {
    public:
        typedef _Tp value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        template <typename _Tp1> struct rebind {
            typedef __new_allocator<_Tp1> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        __new_allocator<_Tp>() noexcept {
        }
        __new_allocator<_Tp>(const __new_allocator<_Tp> &) noexcept {
        }
        template <typename _Tp1> __new_allocator<_Tp>(const __new_allocator<_Tp1> &) noexcept {
        }
        ~__new_allocator<_Tp>() noexcept {
        }
        std::__new_allocator::pointer address(std::__new_allocator::reference __x) const noexcept {
            return std::__addressof(__x);
        }
        std::__new_allocator::const_pointer address(std::__new_allocator::const_reference __x) const noexcept {
            return std::__addressof(__x);
        }
        _Tp *allocate(std::__new_allocator::size_type __n, const void * = static_cast<const void *>(0)) {
            static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(_Tp)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            return static_cast<_Tp *>(__builtin_operator_new(__n * sizeof(_Tp)));
        }
        void deallocate(_Tp *__p, std::__new_allocator::size_type __n __attribute__((unused))) {
            __builtin_operator_delete((__p));
        }
        std::__new_allocator::size_type max_size() const noexcept {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value) {
            ::new ((void *)__p) _Up((std::forward<_Args>(__args)...));
        }
        template <typename _Up> void destroy(_Up *__p) noexcept(std::is_nothrow_destructible<_Up>::value) {
            __p->~_Up();
        }
        friend template <typename _Up> bool operator==(const __new_allocator<_Tp> &, const __new_allocator<_Up> &) noexcept {
            return true;
        }
;
        friend template <typename _Up> bool operator!=(const __new_allocator<_Tp> &, const __new_allocator<_Up> &) noexcept {
            return false;
        }
;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept {
            return std::size_t(9223372036854775807L) / sizeof(_Tp);
        }
    };
    template<> class __new_allocator<char> {
    public:
        typedef char value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        __new_allocator() noexcept {
        }
        __new_allocator(const std::__new_allocator<char> &) noexcept {
        }
        template <typename _Tp1> __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> __new_allocator<char>(const __new_allocator<char> &) noexcept;
        ~__new_allocator<char>() noexcept {
        }
        std::__new_allocator<char>::pointer address(std::__new_allocator<char>::reference __x) const noexcept;
        std::__new_allocator<char>::const_pointer address(std::__new_allocator<char>::const_reference __x) const noexcept;
        char *allocate(std::__new_allocator::size_type __n, const void * = static_cast<const void *>(0)) {
            static_assert(sizeof(char) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            return static_cast<char *>(__builtin_operator_new(__n * sizeof(char)));
        }
        void deallocate(char *__p, std::__new_allocator::size_type __n __attribute__((unused))) {
            __builtin_operator_delete((__p));
        }
        std::__new_allocator::size_type max_size() const noexcept {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const std::__new_allocator<char> &, const __new_allocator<_Up> &) noexcept;
        template<> bool operator==<char>(const std::__new_allocator<char> &, const __new_allocator<char> &) noexcept;
        friend template <typename _Up> bool operator!=(const std::__new_allocator<char> &, const __new_allocator<_Up> &) noexcept;
        template<> bool operator!=<char>(const std::__new_allocator<char> &, const __new_allocator<char> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept {
            return std::size_t(9223372036854775807L) / sizeof(char);
        }
    };
    template<> class __new_allocator<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        __new_allocator() noexcept {
        }
        __new_allocator(const std::__new_allocator<wchar_t> &) noexcept {
        }
        template <typename _Tp1> __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> __new_allocator<wchar_t>(const __new_allocator<wchar_t> &) noexcept;
        ~__new_allocator<wchar_t>() noexcept {
        }
        std::__new_allocator<wchar_t>::pointer address(std::__new_allocator<wchar_t>::reference __x) const noexcept;
        std::__new_allocator<wchar_t>::const_pointer address(std::__new_allocator<wchar_t>::const_reference __x) const noexcept;
        wchar_t *allocate(std::__new_allocator::size_type __n, const void *);
        void deallocate(wchar_t *__p, std::__new_allocator::size_type __n __attribute__((unused))) {
            __builtin_operator_delete((__p));
        }
        std::__new_allocator::size_type max_size() const noexcept;
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const std::__new_allocator<wchar_t> &, const __new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const std::__new_allocator<wchar_t> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept;
    };
    template<> class __new_allocator<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        __new_allocator() noexcept {
        }
        __new_allocator(const std::__new_allocator<char16_t> &) noexcept {
        }
        template <typename _Tp1> __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> __new_allocator<char16_t>(const __new_allocator<char16_t> &) noexcept;
        ~__new_allocator<char16_t>() noexcept {
        }
        std::__new_allocator<char16_t>::pointer address(std::__new_allocator<char16_t>::reference __x) const noexcept;
        std::__new_allocator<char16_t>::const_pointer address(std::__new_allocator<char16_t>::const_reference __x) const noexcept;
        char16_t *allocate(std::__new_allocator::size_type __n, const void * = static_cast<const void *>(0)) {
            static_assert(sizeof(char16_t) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char16_t)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            return static_cast<char16_t *>(__builtin_operator_new(__n * sizeof(char16_t)));
        }
        void deallocate(char16_t *__p, std::__new_allocator::size_type __n __attribute__((unused))) {
            __builtin_operator_delete((__p));
        }
        std::__new_allocator::size_type max_size() const noexcept {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const std::__new_allocator<char16_t> &, const __new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const std::__new_allocator<char16_t> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept {
            return std::size_t(9223372036854775807L) / sizeof(char16_t);
        }
    };
    template<> class __new_allocator<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        __new_allocator() noexcept {
        }
        __new_allocator(const std::__new_allocator<char32_t> &) noexcept {
        }
        template <typename _Tp1> __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> __new_allocator<char32_t>(const __new_allocator<char32_t> &) noexcept;
        ~__new_allocator<char32_t>() noexcept {
        }
        std::__new_allocator<char32_t>::pointer address(std::__new_allocator<char32_t>::reference __x) const noexcept;
        std::__new_allocator<char32_t>::const_pointer address(std::__new_allocator<char32_t>::const_reference __x) const noexcept;
        char32_t *allocate(std::__new_allocator::size_type __n, const void * = static_cast<const void *>(0)) {
            static_assert(sizeof(char32_t) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char32_t)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            return static_cast<char32_t *>(__builtin_operator_new(__n * sizeof(char32_t)));
        }
        void deallocate(char32_t *__p, std::__new_allocator::size_type __n __attribute__((unused))) {
            __builtin_operator_delete((__p));
        }
        std::__new_allocator::size_type max_size() const noexcept {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const std::__new_allocator<char32_t> &, const __new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const std::__new_allocator<char32_t> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept {
            return std::size_t(9223372036854775807L) / sizeof(char32_t);
        }
    };
}
namespace std {
    template <typename _Tp> using __allocator_base = __new_allocator<_Tp>;
}
namespace std {
    template<> class allocator<void> {
    public:
        typedef void value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef void *pointer;
        typedef const void *const_pointer;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
    };
    template <typename _Tp> class allocator : public __allocator_base<_Tp> {
    public:
        typedef _Tp value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        allocator<type-parameter-0-0>() noexcept {
        }
        allocator<type-parameter-0-0>(const allocator<type-parameter-0-0> &__a) noexcept : __allocator_base<_Tp>(__a) {
        }
        allocator<type-parameter-0-0> &operator=(const allocator<type-parameter-0-0> &) = default
        template <typename _Tp1> allocator<type-parameter-0-0>(const allocator<_Tp1> &) noexcept {
        }
        ~allocator<type-parameter-0-0>() noexcept {
        }
        friend bool operator==(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept {
            return true;
        }
;
        friend bool operator!=(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept {
            return false;
        }
;
    };
    template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        template <typename _Tp1> struct rebind;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        allocator() noexcept : __allocator_base<char16_t>() {
        }
        allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a) {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char16_t>(const allocator<char16_t> &) noexcept;
        ~allocator<char16_t>() noexcept {
        }
        friend bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
        friend bool operator!=(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    };
    template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        template <typename _Tp1> struct rebind;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        allocator() noexcept : __allocator_base<char32_t>() {
        }
        allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a) {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char32_t>(const allocator<char32_t> &) noexcept;
        ~allocator<char32_t>() noexcept {
        }
        friend bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
        friend bool operator!=(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    };
    template <typename _T1, typename _T2> inline bool operator==(const allocator<_T1> &, const allocator<_T2> &) noexcept {
        return true;
    }
    template<> inline bool operator==<char, char>(const allocator<char> &, const allocator<char> &) noexcept    template <typename _T1, typename _T2> inline bool operator!=(const allocator<_T1> &, const allocator<_T2> &) noexcept {
        return false;
    }
    template<> inline bool operator!=<char, char>(const allocator<char> &, const allocator<char> &) noexcept    template <typename _Tp> class allocator<const _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const type-parameter-0-0>(const allocator<_Up> &) {
        }
    };
    template <typename _Tp> class allocator<volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<volatile type-parameter-0-0>(const allocator<_Up> &) {
        }
    };
    template <typename _Tp> class allocator<const volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const volatile type-parameter-0-0>(const allocator<_Up> &) {
        }
    };
    template<> class allocator<char> : public __allocator_base<char> {
    public:
        typedef char value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        template <typename _Tp1> struct rebind;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        allocator() noexcept : __allocator_base<char>() {
        }
        allocator(const std::allocator<char> &__a) noexcept : __allocator_base<char>(__a) {
        }
        std::allocator<char> &operator=(const std::allocator<char> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char>(const allocator<char> &) noexcept;
        ~allocator<char>() noexcept {
        }
        friend bool operator==(const std::allocator<char> &, const std::allocator<char> &) noexcept {
            return true;
        }
;
        friend bool operator!=(const std::allocator<char> &, const std::allocator<char> &) noexcept {
            return false;
        }
;
    };
    template<> class allocator<wchar_t> : public __allocator_base<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        template <typename _Tp1> struct rebind;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal = std::true_type;
        allocator() noexcept : __allocator_base<wchar_t>() {
        }
        allocator(const std::allocator<wchar_t> &__a) noexcept : __allocator_base<wchar_t>(__a) {
        }
        std::allocator<wchar_t> &operator=(const std::allocator<wchar_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<wchar_t>(const allocator<wchar_t> &) noexcept;
        ~allocator<wchar_t>() noexcept {
        }
        friend bool operator==(const std::allocator<wchar_t> &, const std::allocator<wchar_t> &) noexcept;
        friend bool operator!=(const std::allocator<wchar_t> &, const std::allocator<wchar_t> &) noexcept;
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
        static void _S_do_it(_Alloc &, _Alloc &) noexcept {
        }
    };
    template <typename _Alloc> struct __alloc_swap<_Alloc, false> {
        static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept {
            if (__one != __two)
                swap(__one, __two);
        }
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_neq {
        static bool _S_do_it(const _Alloc &, const _Alloc &) {
            return false;
        }
    };
    template <typename _Alloc> struct __alloc_neq<_Alloc, false> {
        static bool _S_do_it(const _Alloc &__one, const _Alloc &__two) {
            return __one != __two;
        }
    };
    template <typename _Tp, bool = __or_<is_copy_constructible<typename _Tp::value_type>, is_nothrow_move_constructible<typename _Tp::value_type>>::value> struct __shrink_to_fit_aux {
        static bool _S_do_it(_Tp &) noexcept {
            return false;
        }
    };
    template <typename _Tp> struct __shrink_to_fit_aux<_Tp, true> {
        static bool _S_do_it(_Tp &__c) noexcept {
            try {
                _Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c);
                return true;
            } catch (...) {
                return false;
            }
        }
    };
}
extern "C++" {
    namespace std {
        struct __true_type {
        };
        struct __false_type {
        };
        template <bool> struct __truth_type {
            typedef std::__false_type __type;
        };
        template<> struct __truth_type<true> {
            typedef std::__true_type __type;
        };
        template <class _Sp, class _Tp> struct __traitor {
            enum {
                __value = bool(_Sp::__value) || bool(_Tp::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template <typename, typename> struct __are_same {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __are_same<float, float> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __are_same<float, double> {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __are_same<double, float> {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __are_same<double, double> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __are_same<long double, float> {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __are_same<long double, double> {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __are_same<_Tp, _Tp> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_void {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_void<void> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_integer {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<long double> {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<double> {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<float> {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<bool> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<signed char> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned char> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<wchar_t> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char16_t> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char32_t> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<short> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned short> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<int> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned int> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long long> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long long> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<__int128> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned __int128> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_floating {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_floating<float> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<double> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<long double> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_pointer {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __is_pointer<_Tp *> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_arithmetic : public __traitor<__is_integer<_Tp>, __is_floating<_Tp>> {
        };
        template <typename _Tp> struct __is_scalar : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>> {
        };
        template <typename _Tp> struct __is_char {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_char<char> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_char<wchar_t> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_byte {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_byte<char> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<signed char> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<unsigned char> {
            enum {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename> struct iterator_traits
        template<> struct iterator_traits<char *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char value_type;
            typedef std::ptrdiff_t difference_type;
            typedef char *pointer;
            typedef char &reference;
        }
        template<> struct iterator_traits<const char *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const char *pointer;
            typedef const char &reference;
        }
        template<> struct iterator_traits<wchar_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef wchar_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef wchar_t &reference;
        }
        template<> struct iterator_traits<const wchar_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef wchar_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const wchar_t *pointer;
            typedef const wchar_t &reference;
        }
        template<> struct iterator_traits<const char16_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char16_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const char16_t *pointer;
            typedef const char16_t &reference;
        }
        template<> struct iterator_traits<char16_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char16_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef char16_t *pointer;
            typedef char16_t &reference;
        }
        template<> struct iterator_traits<const char32_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char32_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const char32_t *pointer;
            typedef const char32_t &reference;
        }
        template<> struct iterator_traits<char32_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char32_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef char32_t *pointer;
            typedef char32_t &reference;
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable {
            enum {
                __value = __is_trivially_copyable(_Tp)
            };
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
            enum {
                __value = 0
            };
        };
        template <typename _OutputIter, typename _InputIter> struct __memcpyable {
            enum {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcpyable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcpyable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Iter1, typename _Iter2> struct __memcmpable {
            enum {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcmpable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<const _Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp, bool _TreatAsBytes = __is_byte<_Tp>::__value> struct __is_memcmp_ordered {
            static const bool __value = _Tp(-1) > _Tp(1);
        };
        template <typename _Tp> struct __is_memcmp_ordered<_Tp, false> {
            static const bool __value = false;
        };
        template <typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)> struct __is_memcmp_ordered_with {
            static const bool __value = __is_memcmp_ordered<_Tp>::__value && __is_memcmp_ordered<_Up>::__value;
        };
        template <typename _Tp, typename _Up> struct __is_memcmp_ordered_with<_Tp, _Up, false> {
            static const bool __value = false;
        };
        template <typename _Tp> struct __is_move_iterator {
            enum {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Iterator> inline _Iterator __miter_base(_Iterator __it) {
            return __it;
        }
    }
}
namespace std {
    template <typename _CharT, typename _Traits> inline void __ostream_write(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n) {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }
    template <typename _CharT, typename _Traits> inline void __ostream_fill(basic_ostream<_CharT, _Traits> &__out, std::streamsize __n) {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (; __n > 0; --__n) {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof())) {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &__ostream_insert(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n) {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb) {
            try {
                const std::streamsize __w = __out.width();
                if (__w > __n) {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                } else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }
}
namespace std {
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : public std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : public std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : public std::bidirectional_iterator_tag {
    };
    template <typename _Category, typename _Tp, typename _Distance = std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp &> struct iterator {
        typedef _Category iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef _Pointer pointer;
        typedef _Reference reference;
    };
    template<> struct iterator<std::output_iterator_tag, void, void, void, void> {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
    };
    template <typename _Iterator> struct iterator_traits
    template<> struct iterator_traits<char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef char &reference;
    }
    template<> struct iterator_traits<const char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char *pointer;
        typedef const char &reference;
    }
    template<> struct iterator_traits<wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef wchar_t &reference;
    }
    template<> struct iterator_traits<const wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const wchar_t *pointer;
        typedef const wchar_t &reference;
    }
    template<> struct iterator_traits<const char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char16_t *pointer;
        typedef const char16_t &reference;
    }
    template<> struct iterator_traits<char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef char16_t &reference;
    }
    template<> struct iterator_traits<const char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char32_t *pointer;
        typedef const char32_t &reference;
    }
    template<> struct iterator_traits<char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef char32_t &reference;
    };
    template <typename _Iterator, typename = __void_t<>> struct __iterator_traits {
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, __void_t<typename _Iterator::iterator_category, typename _Iterator::value_type, typename _Iterator::difference_type, typename _Iterator::pointer, typename _Iterator::reference>> {
        typedef typename _Iterator::iterator_category iterator_category;
        typedef typename _Iterator::value_type value_type;
        typedef typename _Iterator::difference_type difference_type;
        typedef typename _Iterator::pointer pointer;
        typedef typename _Iterator::reference reference;
    };
    template <typename _Iterator> struct iterator_traits : public __iterator_traits<_Iterator> {
    };
    template<> struct iterator_traits<char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef char &reference;
    };
    template<> struct iterator_traits<const char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char *pointer;
        typedef const char &reference;
    };
    template<> struct iterator_traits<wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef wchar_t &reference;
    };
    template<> struct iterator_traits<const wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const wchar_t *pointer;
        typedef const wchar_t &reference;
    };
    template<> struct iterator_traits<const char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char16_t *pointer;
        typedef const char16_t &reference;
    };
    template<> struct iterator_traits<char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef char16_t &reference;
    };
    template<> struct iterator_traits<const char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char32_t *pointer;
        typedef const char32_t &reference;
    };
    template<> struct iterator_traits<char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef char32_t &reference;
    };
    template <typename _Tp> struct iterator_traits<_Tp *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef _Tp &reference;
    };
    template <typename _Tp> struct iterator_traits<const _Tp *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const _Tp *pointer;
        typedef const _Tp &reference;
    };
    template <typename _Iter> inline constexpr typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &) {
        return typename iterator_traits<_Iter>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<char *>::iterator_category __iterator_category<char *>(char *const &) {
        return typename iterator_traits<char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::iterator_category __iterator_category<wchar_t *>(wchar_t *const &) {
        return typename iterator_traits<wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char *>::iterator_category __iterator_category<const char *>(const char *const &) {
        return typename iterator_traits<const char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::iterator_category __iterator_category<const wchar_t *>(const wchar_t *const &) {
        return typename iterator_traits<const wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::iterator_category __iterator_category<const char16_t *>(const char16_t *const &) {
        return typename iterator_traits<const char16_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::iterator_category __iterator_category<const char32_t *>(const char32_t *const &) {
        return typename iterator_traits<const char32_t *>::iterator_category();
    }
    template <typename _Iter> using __iterator_category_t = typename iterator_traits<_Iter>::iterator_category;
    template <typename _InIter> using _RequireInputIter = __enable_if_t<is_convertible<__iterator_category_t<_InIter>, input_iterator_tag>::value>;
    template <typename _It, typename _Cat = __iterator_category_t<_It>> struct __is_random_access_iter : is_base_of<std::random_access_iterator_tag, _Cat> {
        typedef is_base_of<std::random_access_iterator_tag, _Cat> _Base;
        enum {
            __value = _Base::value
        };
    };
}
namespace std {
    template <typename> struct _List_iterator;
    template <typename> struct _List_const_iterator;
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        while (__first != __last)
            {
                ++__first;
                ++__n;
            }
        return __n;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, std::input_iterator_tag)    template <typename _RandomAccessIterator> inline constexpr typename iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, std::random_access_iterator_tag) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::random_access_iterator_tag) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::random_access_iterator_tag) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, std::random_access_iterator_tag) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, std::random_access_iterator_tag) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, std::random_access_iterator_tag) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, std::random_access_iterator_tag) {
        return __last - __first;
    }
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>, std::input_iterator_tag);
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_const_iterator<_Tp>, std::_List_const_iterator<_Tp>, std::input_iterator_tag);
    template <typename _OutputIterator> void __distance(_OutputIterator, _OutputIterator, std::output_iterator_tag) = delete
    template <typename _InputIterator> inline typename iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<char *>::difference_type distance<char *>(char *__first, char *__last) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<wchar_t *>::difference_type distance<wchar_t *>(wchar_t *__first, wchar_t *__last) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const char *>::difference_type distance<const char *>(const char *__first, const char *__last) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const wchar_t *>::difference_type distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const char16_t *>::difference_type distance<const char16_t *>(const char16_t *__first, const char16_t *__last) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const char32_t *>::difference_type distance<const char32_t *>(const char32_t *__first, const char32_t *__last) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void __advance(_InputIterator &__i, _Distance __n, std::input_iterator_tag) {
        do {
            if (std::__is_constant_evaluated() && !bool(__n >= 0))
                __builtin_unreachable();
        } while (false);
        while (__n--)
            ++__i;
    }
    template <typename _BidirectionalIterator, typename _Distance> inline constexpr void __advance(_BidirectionalIterator &__i, _Distance __n, std::bidirectional_iterator_tag) {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }
    template <typename _RandomAccessIterator, typename _Distance> inline constexpr void __advance(_RandomAccessIterator &__i, _Distance __n, std::random_access_iterator_tag) {
        if (__builtin_constant_p(__n) && __n == 1)
            ++__i;
        else if (__builtin_constant_p(__n) && __n == -1)
            --__i;
        else
            __i += __n;
    }
    template <typename _OutputIterator, typename _Distance> void __advance(_OutputIterator &, _Distance, std::output_iterator_tag) = delete
    template <typename _InputIterator, typename _Distance> inline void advance(_InputIterator &__i, _Distance __n) {
        typename iterator_traits<_InputIterator>::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }
    template <typename _InputIterator> inline _InputIterator next(_InputIterator __x, typename iterator_traits<_InputIterator>::difference_type __n = 1) {
        std::advance(__x, __n);
        return __x;
    }
    template <typename _BidirectionalIterator> inline _BidirectionalIterator prev(_BidirectionalIterator __x, typename iterator_traits<_BidirectionalIterator>::difference_type __n = 1) {
        std::advance(__x, -__n);
        return __x;
    }
}
extern "C++" {
    namespace __gnu_cxx {
        template <bool, typename> struct __enable_if {
        };
        template <typename _Tp> struct __enable_if<true, _Tp> {
            typedef _Tp __type;
        };
        template <bool _Cond, typename _Iftrue, typename _Iffalse> struct __conditional_type {
            typedef _Iftrue __type;
        };
        template<> struct __conditional_type<true, unsigned long, unsigned long long> {
            typedef unsigned long __type;
        };
        template <typename _Iftrue, typename _Iffalse> struct __conditional_type<false, _Iftrue, _Iffalse> {
            typedef _Iffalse __type;
        };
        template <typename _Tp> struct __add_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __add_unsigned<char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<signed char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<short> {
            typedef unsigned short __type;
        };
        template<> struct __add_unsigned<int> {
            typedef unsigned int __type;
        };
        template<> struct __add_unsigned<long> {
            typedef unsigned long __type;
        };
        template<> struct __add_unsigned<long long> {
            typedef unsigned long long __type;
        };
        template<> struct __add_unsigned<bool>;
        template<> struct __add_unsigned<wchar_t>;
        template <typename _Tp> struct __remove_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __remove_unsigned<char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned short> {
            typedef short __type;
        };
        template<> struct __remove_unsigned<unsigned int> {
            typedef int __type;
        };
        template<> struct __remove_unsigned<unsigned long> {
            typedef long __type;
        };
        template<> struct __remove_unsigned<unsigned long long> {
            typedef long long __type;
        };
        template<> struct __remove_unsigned<bool>;
        template<> struct __remove_unsigned<wchar_t>;
        template <typename _Type> inline constexpr bool __is_null_pointer(_Type *__ptr) {
            return __ptr == 0;
        }
        template <typename _Type> inline constexpr bool __is_null_pointer(_Type) {
            return false;
        }
        constexpr bool __is_null_pointer(std::nullptr_t) {
            return true;
        }
        template <typename _Tp, bool = std::__is_integer<_Tp>::__value> struct __promote {
            typedef double __type;
        };
        template <typename _Tp> struct __promote<_Tp, false> {
        };
        template<> struct __promote<long double> {
            typedef long double __type;
        };
        template<> struct __promote<double> {
            typedef double __type;
        };
        template<> struct __promote<float> {
            typedef float __type;
        };
        template <typename _Tp, typename _Up, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type> struct __promote_2 {
            typedef typeof (_Tp2() + _Up2()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type> struct __promote_3 {
            typedef typeof (_Tp2() + _Up2() + _Vp2()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type, typename _Wp2 = typename __promote<_Wp>::__type> struct __promote_4 {
            typedef typeof (_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
        };
    }
}
namespace std {
    class __undefined;
    template <typename _Tp> struct __get_first_arg {
        using type = std::__undefined;
    };
    template <template <typename, typename ...> class _SomeTemplate, typename _Tp, typename ..._Types> struct __get_first_arg<_SomeTemplate<_Tp, _Types...>> {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __replace_first_arg {
    };
    template <template <typename, typename ...> class _SomeTemplate, typename _Up, typename _Tp, typename ..._Types> struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up> {
        using type = _SomeTemplate<_Up, _Types...>;
    };
    template <typename _Ptr, typename = void> struct __ptr_traits_elem : __get_first_arg<_Ptr> {
    };
    template <typename _Ptr> struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>> {
        using type = typename _Ptr::element_type;
    };
    template <typename _Ptr> using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;
    template <typename _Ptr, typename _Elt, bool = is_void<_Elt>::value> struct __ptr_traits_ptr_to {
        using pointer = _Ptr;
        using element_type = _Elt;
        static std::__ptr_traits_ptr_to::pointer pointer_to(std::__ptr_traits_ptr_to::element_type &__e) {
            return pointer::pointer_to(__e);
        }
    };
    template<> struct __ptr_traits_ptr_to<char *, char, false> {
        using pointer = char *;
        using element_type = char;
        static std::__ptr_traits_ptr_to<char *, char, false>::pointer pointer_to(std::__ptr_traits_ptr_to<char *, char, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const char *, const char, false> {
        using pointer = const char *;
        using element_type = const char;
        static std::__ptr_traits_ptr_to<const char *, const char, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const char *, const char, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<wchar_t *, wchar_t, false> {
        using pointer = wchar_t *;
        using element_type = wchar_t;
        static std::__ptr_traits_ptr_to<wchar_t *, wchar_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<wchar_t *, wchar_t, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const wchar_t *, const wchar_t, false> {
        using pointer = const wchar_t *;
        using element_type = const wchar_t;
        static std::__ptr_traits_ptr_to<const wchar_t *, const wchar_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const wchar_t *, const wchar_t, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<char16_t *, char16_t, false> {
        using pointer = char16_t *;
        using element_type = char16_t;
        static std::__ptr_traits_ptr_to<char16_t *, char16_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<char16_t *, char16_t, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const char16_t *, const char16_t, false> {
        using pointer = const char16_t *;
        using element_type = const char16_t;
        static std::__ptr_traits_ptr_to<const char16_t *, const char16_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const char16_t *, const char16_t, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<char32_t *, char32_t, false> {
        using pointer = char32_t *;
        using element_type = char32_t;
        static std::__ptr_traits_ptr_to<char32_t *, char32_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<char32_t *, char32_t, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const char32_t *, const char32_t, false> {
        using pointer = const char32_t *;
        using element_type = const char32_t;
        static std::__ptr_traits_ptr_to<const char32_t *, const char32_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const char32_t *, const char32_t, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Elt> struct __ptr_traits_ptr_to<_Ptr, _Elt, true> {
    };
    template <typename _Tp> struct __ptr_traits_ptr_to<_Tp *, _Tp, false> {
        using pointer = _Tp *;
        using element_type = _Tp;
        static std::__ptr_traits_ptr_to<type-parameter-0-0 *, type-parameter-0-0, false>::pointer pointer_to(std::__ptr_traits_ptr_to<type-parameter-0-0 *, type-parameter-0-0, false>::element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Elt> struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt> {
    private:
        template <typename _Tp, typename = void> struct __difference {
            using type = std::ptrdiff_t;
        };
        template <typename _Tp> struct __difference<_Tp, __void_t<typename _Tp::difference_type>> {
            using type = typename _Tp::difference_type;
        };
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>> {
            using type = typename _Tp::template rebind<_Up>;
        };
    public:
        using pointer = _Ptr;
        using element_type = _Elt;
        using difference_type = typename __difference<_Ptr>::type;
        template <typename _Up> using rebind = typename __rebind<_Ptr, _Up>::type;
    };
    template <typename _Ptr> struct __ptr_traits_impl<_Ptr, std::__undefined> {
    };
    template <typename _Ptr> struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>> {
    };
    template<> struct pointer_traits<char *> : __ptr_traits_ptr_to<char *, char> {
        typedef char *pointer;
        typedef char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const char *> : __ptr_traits_ptr_to<const char *, const char> {
        typedef const char *pointer;
        typedef const char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<wchar_t *> : __ptr_traits_ptr_to<wchar_t *, wchar_t> {
        typedef wchar_t *pointer;
        typedef wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const wchar_t *> : __ptr_traits_ptr_to<const wchar_t *, const wchar_t> {
        typedef const wchar_t *pointer;
        typedef const wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<char16_t *> : __ptr_traits_ptr_to<char16_t *, char16_t> {
        typedef char16_t *pointer;
        typedef char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const char16_t *> : __ptr_traits_ptr_to<const char16_t *, const char16_t> {
        typedef const char16_t *pointer;
        typedef const char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<char32_t *> : __ptr_traits_ptr_to<char32_t *, char32_t> {
        typedef char32_t *pointer;
        typedef char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const char32_t *> : __ptr_traits_ptr_to<const char32_t *, const char32_t> {
        typedef const char32_t *pointer;
        typedef const char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template <typename _Tp> struct pointer_traits<_Tp *> : __ptr_traits_ptr_to<_Tp *, _Tp> {
        typedef _Tp *pointer;
        typedef _Tp element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template <typename _Ptr, typename _Tp> using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
    template <typename _Tp> constexpr _Tp *__to_address(_Tp *__ptr) noexcept {
        static_assert(!std::is_function<_Tp>::value, "not a function pointer");
        return __ptr;
    }
    template <typename _Ptr> constexpr typename std::pointer_traits<_Ptr>::element_type *__to_address(const _Ptr &__ptr) {
        return std::__to_address(__ptr.operator->());
    }
}
namespace std {
    template <typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference> {
        friend template <typename _Iter> class reverse_iterator;
    protected:
        _Iterator current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::pointer pointer;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        reverse_iterator<_Iterator>() noexcept(noexcept(_Iterator())) : current() {
        }
        explicit reverse_iterator<_Iterator>(std::reverse_iterator::iterator_type __x) noexcept(noexcept(_Iterator(__x))) : current(__x) {
        }
        reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) noexcept(noexcept(_Iterator(__x.current))) : current(__x.current) {
        }
        reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iterator> &) = default
        template <typename _Iter> reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) noexcept(noexcept(_Iterator(__x.current))) : current(__x.current) {
        }
        template <typename _Iter> reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iter> &__x) noexcept(noexcept(this->current = __x.current)) {
            this->current = __x.current;
            return *this;
        }
        std::reverse_iterator::iterator_type base() const noexcept(noexcept(_Iterator(this->current))) {
            return this->current;
        }
        std::reverse_iterator::reference operator*() const {
            _Iterator __tmp = this->current;
            return *--__tmp;
        }
        std::reverse_iterator::pointer operator->() const {
            _Iterator __tmp = this->current;
            --__tmp;
            return _S_to_pointer(__tmp);
        }
        reverse_iterator<_Iterator> &operator++() {
            --this->current;
            return *this;
        }
        reverse_iterator<_Iterator> operator++(int) {
            reverse_iterator<_Iterator> __tmp = *this;
            --this->current;
            return __tmp;
        }
        reverse_iterator<_Iterator> &operator--() {
            ++this->current;
            return *this;
        }
        reverse_iterator<_Iterator> operator--(int) {
            reverse_iterator<_Iterator> __tmp = *this;
            ++this->current;
            return __tmp;
        }
        reverse_iterator<_Iterator> operator+(std::reverse_iterator::difference_type __n) const {
            return reverse_iterator<_Iterator>(this->current - __n);
        }
        reverse_iterator<_Iterator> &operator+=(std::reverse_iterator::difference_type __n) {
            this->current -= __n;
            return *this;
        }
        reverse_iterator<_Iterator> operator-(std::reverse_iterator::difference_type __n) const {
            return reverse_iterator<_Iterator>(this->current + __n);
        }
        reverse_iterator<_Iterator> &operator-=(std::reverse_iterator::difference_type __n) {
            this->current += __n;
            return *this;
        }
        std::reverse_iterator::reference operator[](std::reverse_iterator::difference_type __n) const {
            return *(*this + __n);
        }
    private:
        template <typename _Tp> static _Tp *_S_to_pointer(_Tp *__p) {
            return __p;
        }
        template <typename _Tp> static std::reverse_iterator::pointer _S_to_pointer(_Tp __t) {
            return __t.operator->();
        }
    };
    template <typename _Iterator> inline bool operator==(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) {
        return __x.base() == __y.base();
    }
    template <typename _Iterator> inline bool operator<(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) {
        return __y.base() < __x.base();
    }
    template <typename _Iterator> inline bool operator!=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) {
        return !(__x == __y);
    }
    template <typename _Iterator> inline bool operator>(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) {
        return __y < __x;
    }
    template <typename _Iterator> inline bool operator<=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) {
        return !(__y < __x);
    }
    template <typename _Iterator> inline bool operator>=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator==(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) {
        return __x.base() > __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator!=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) {
        return __x.base() != __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) {
        return __x.base() >= __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) {
        return __x.base() <= __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline auto operator-(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base()) [[nodiscard("")]] {
        return __y.base() - __x.base();
    }
    template <typename _Iterator> inline reverse_iterator<_Iterator> operator+(typename reverse_iterator<_Iterator>::difference_type __n, const reverse_iterator<_Iterator> &__x) {
        return reverse_iterator<_Iterator>(__x.base() - __n);
    }
    template <typename _Iterator> inline reverse_iterator<_Iterator> __make_reverse_iterator(_Iterator __i) {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> inline reverse_iterator<_Iterator> make_reverse_iterator(_Iterator __i) [[nodiscard("")]] {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> auto __niter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__niter_base(__it.base()))) {
        return __make_reverse_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<reverse_iterator<_Iterator>> : __is_move_iterator<_Iterator> {
    };
    template <typename _Iterator> auto __miter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__miter_base(__it.base()))) {
        return __make_reverse_iterator(__miter_base(__it.base()));
    }
    template <typename _Container> class back_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x)) {
        }
        back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value) {
            this->container->push_back(__value);
            return *this;
        }
        back_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value) {
            this->container->push_back(std::move(__value));
            return *this;
        }
        back_insert_iterator<_Container> &operator*() {
            return *this;
        }
        back_insert_iterator<_Container> &operator++() {
            return *this;
        }
        back_insert_iterator<_Container> operator++(int) {
            return *this;
        }
    };
    template <typename _Container> inline back_insert_iterator<_Container> back_inserter(_Container &__x) {
        return back_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class front_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x)) {
        }
        front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value) {
            this->container->push_front(__value);
            return *this;
        }
        front_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value) {
            this->container->push_front(std::move(__value));
            return *this;
        }
        front_insert_iterator<_Container> &operator*() {
            return *this;
        }
        front_insert_iterator<_Container> &operator++() {
            return *this;
        }
        front_insert_iterator<_Container> operator++(int) {
            return *this;
        }
    };
    template <typename _Container> inline front_insert_iterator<_Container> front_inserter(_Container &__x) {
        return front_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
        typedef typename _Container::iterator _Iter;
    protected:
        _Container *container;
        std::insert_iterator::_Iter iter;
    public:
        typedef _Container container_type;
        insert_iterator<_Container>(_Container &__x, std::insert_iterator::_Iter __i) : container(std::__addressof(__x)), iter(__i) {
        }
        insert_iterator<_Container> &operator=(const typename _Container::value_type &__value) {
            this->iter = this->container->insert(this->iter, __value);
            ++this->iter;
            return *this;
        }
        insert_iterator<_Container> &operator=(typename _Container::value_type &&__value) {
            this->iter = this->container->insert(this->iter, std::move(__value));
            ++this->iter;
            return *this;
        }
        insert_iterator<_Container> &operator*() {
            return *this;
        }
        insert_iterator<_Container> &operator++() {
            return *this;
        }
        insert_iterator<_Container> &operator++(int) {
            return *this;
        }
    };
    template <typename _Container> inline insert_iterator<_Container> inserter(_Container &__x, typename _Container::iterator __i) {
        return insert_iterator<_Container>(__x, __i);
    }
}
namespace __gnu_cxx {
    template <typename _Iterator, typename _Container> class __normal_iterator {
    protected:
        _Iterator _M_current;
        typedef std::iterator_traits<_Iterator> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator<_Iterator, _Container>() noexcept : _M_current(_Iterator()) {
        }
        explicit __normal_iterator<_Iterator, _Container>(const _Iterator &__i) noexcept : _M_current(__i) {
        }
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator<_Iterator, _Container>(const __normal_iterator<_Iter, _Container> &__i) noexcept : _M_current(__i.base()) {
        }
        __gnu_cxx::__normal_iterator::reference operator*() const noexcept {
            return *this->_M_current;
        }
        __gnu_cxx::__normal_iterator::pointer operator->() const noexcept {
            return this->_M_current;
        }
        __normal_iterator<_Iterator, _Container> &operator++() noexcept {
            ++this->_M_current;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator++(int) noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current++);
        }
        __normal_iterator<_Iterator, _Container> &operator--() noexcept {
            --this->_M_current;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator--(int) noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current--);
        }
        __gnu_cxx::__normal_iterator::reference operator[](__gnu_cxx::__normal_iterator::difference_type __n) const noexcept {
            return this->_M_current[__n];
        }
        __normal_iterator<_Iterator, _Container> &operator+=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept {
            this->_M_current += __n;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator+(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current + __n);
        }
        __normal_iterator<_Iterator, _Container> &operator-=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept {
            this->_M_current -= __n;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator-(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current - __n);
        }
        const _Iterator &base() const noexcept {
            return this->_M_current;
        }
    };
    template<> class __normal_iterator<char *, std::basic_string<char>> {
    protected:
        char *_M_current;
        typedef std::iterator_traits<char *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char *>::value>;
    public:
        typedef char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char *const &__i) noexcept : _M_current(__i) {
        }
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<char>> &__i) noexcept;
        template<> __normal_iterator<char *, void>(const __normal_iterator<char *, std::basic_string<char>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::reference operator[](__gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> &operator+=(__gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> operator+(__gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> &operator-=(__gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::basic_string<char>> operator-(__gnu_cxx::__normal_iterator<char *, std::basic_string<char>>::difference_type __n) const noexcept;
        char *const &base() const noexcept {
            return this->_M_current;
        }
    };
    template<> class __normal_iterator<const char *, std::basic_string<char>> {
    protected:
        const char *_M_current;
        typedef std::iterator_traits<const char *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char *>::value>;
    public:
        typedef const char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<char>> &__i) noexcept;
        template<> __normal_iterator<char *, void>(const __normal_iterator<char *, std::basic_string<char>> &__i) noexcept : _M_current(__i.base()) {
        }
;
        template<> __normal_iterator<const char *, void>(const __normal_iterator<const char *, std::basic_string<char>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::reference operator[](__gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> &operator+=(__gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> operator+(__gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> &operator-=(__gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::basic_string<char>> operator-(__gnu_cxx::__normal_iterator<const char *, std::basic_string<char>>::difference_type __n) const noexcept;
        const char *const &base() const noexcept {
            return this->_M_current;
        }
    };
    template<> class __normal_iterator<wchar_t *, std::basic_string<wchar_t>> {
    protected:
        wchar_t *_M_current;
        typedef std::iterator_traits<wchar_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, wchar_t *>::value>;
    public:
        typedef wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(wchar_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<wchar_t>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::reference operator[](__gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> &operator+=(__gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> operator+(__gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> &operator-=(__gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>> operator-(__gnu_cxx::__normal_iterator<wchar_t *, std::basic_string<wchar_t>>::difference_type __n) const noexcept;
        wchar_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<const wchar_t *, std::basic_string<wchar_t>> {
    protected:
        const wchar_t *_M_current;
        typedef std::iterator_traits<const wchar_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const wchar_t *>::value>;
    public:
        typedef const wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const wchar_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<wchar_t>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::reference operator[](__gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> &operator+=(__gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> operator+(__gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> &operator-=(__gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>> operator-(__gnu_cxx::__normal_iterator<const wchar_t *, std::basic_string<wchar_t>>::difference_type __n) const noexcept;
        const wchar_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<char16_t *, std::basic_string<char16_t>> {
    protected:
        char16_t *_M_current;
        typedef std::iterator_traits<char16_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char16_t *>::value>;
    public:
        typedef char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char16_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<char16_t>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::reference operator[](__gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> &operator+=(__gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> operator+(__gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> &operator-=(__gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>> operator-(__gnu_cxx::__normal_iterator<char16_t *, std::basic_string<char16_t>>::difference_type __n) const noexcept;
        char16_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<const char16_t *, std::basic_string<char16_t>> {
    protected:
        const char16_t *_M_current;
        typedef std::iterator_traits<const char16_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char16_t *>::value>;
    public:
        typedef const char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char16_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<char16_t>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::reference operator[](__gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> &operator+=(__gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> operator+(__gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> &operator-=(__gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>> operator-(__gnu_cxx::__normal_iterator<const char16_t *, std::basic_string<char16_t>>::difference_type __n) const noexcept;
        const char16_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<char32_t *, std::basic_string<char32_t>> {
    protected:
        char32_t *_M_current;
        typedef std::iterator_traits<char32_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char32_t *>::value>;
    public:
        typedef char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char32_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<char32_t>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::reference operator[](__gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> &operator+=(__gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> operator+(__gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> &operator-=(__gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>> operator-(__gnu_cxx::__normal_iterator<char32_t *, std::basic_string<char32_t>>::difference_type __n) const noexcept;
        char32_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<const char32_t *, std::basic_string<char32_t>> {
    protected:
        const char32_t *_M_current;
        typedef std::iterator_traits<const char32_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char32_t *>::value>;
    public:
        typedef const char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char32_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> __normal_iterator(const __normal_iterator<_Iter, std::basic_string<char32_t>> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::reference operator[](__gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> &operator+=(__gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> operator+(__gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> &operator-=(__gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>> operator-(__gnu_cxx::__normal_iterator<const char32_t *, std::basic_string<char32_t>>::difference_type __n) const noexcept;
        const char32_t *const &base() const noexcept;
    };
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
        return __lhs.base() == __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator==(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
        return __lhs.base() == __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator!=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
        return __lhs.base() != __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator!=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
        return __lhs.base() != __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
        return __lhs.base() < __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator<(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
        return __lhs.base() < __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
        return __lhs.base() > __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator>(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
        return __lhs.base() > __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
        return __lhs.base() <= __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator<=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
        return __lhs.base() <= __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
        return __lhs.base() >= __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator>=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
        return __lhs.base() >= __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline auto operator-(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base()) [[nodiscard("")]] {
        return __lhs.base() - __rhs.base();
    }
    template<> inline auto operator-<const char *, char *, std::basic_string<char>>(const __normal_iterator<const char *, std::basic_string<char>> &__lhs, const __normal_iterator<char *, std::basic_string<char>> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base()) [[nodiscard("")]] {
        return __lhs.base() - __rhs.base();
    }
    template<> inline auto operator-<const char *, const char *, std::basic_string<char>>(const __normal_iterator<const char *, std::basic_string<char>> &__lhs, const __normal_iterator<const char *, std::basic_string<char>> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base()) [[nodiscard("")]]    template <typename _Iterator, typename _Container> inline typename __normal_iterator<_Iterator, _Container>::difference_type operator-(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
        return __lhs.base() - __rhs.base();
    }
    template<> inline typename __normal_iterator<const char *, basic_string<char>>::difference_type operator-<const char *, std::basic_string<char>>(const __normal_iterator<const char *, std::basic_string<char>> &__lhs, const __normal_iterator<const char *, std::basic_string<char>> &__rhs) noexcept {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline __normal_iterator<_Iterator, _Container> operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n, const __normal_iterator<_Iterator, _Container> &__i) noexcept {
        return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
    }
}
namespace std {
    template <typename _Iterator, typename _Container> _Iterator __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value) {
        return __it.base();
    }
    template <typename _Iterator, typename _Container> constexpr auto __to_address(const __gnu_cxx::__normal_iterator<_Iterator, _Container> &__it) noexcept -> decltype(std::__to_address(__it.base())) {
        return std::__to_address(__it.base());
    }
    namespace __detail {
    }
    template <typename _Iterator> class move_iterator {
        _Iterator _M_current;
        using __traits_type = iterator_traits<_Iterator>;
        using __base_ref = typename __traits_type::reference;
        friend template <typename _Iter2> class move_iterator;
    public:
        using iterator_type = _Iterator;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef _Iterator pointer;
        using reference = __conditional_t<is_reference<__base_ref>::value, typename remove_reference<__base_ref>::type &&, std::move_iterator::__base_ref>;
        move_iterator<_Iterator>() : _M_current() {
        }
        explicit move_iterator<_Iterator>(std::move_iterator::iterator_type __i) : _M_current(std::move(__i)) {
        }
        template <typename _Iter> move_iterator<_Iterator>(const move_iterator<_Iter> &__i) : _M_current(__i._M_current) {
        }
        template <typename _Iter> move_iterator<_Iterator> &operator=(const move_iterator<_Iter> &__i) {
            this->_M_current = __i._M_current;
            return *this;
        }
        std::move_iterator::iterator_type base() const [[nodiscard("")]] {
            return this->_M_current;
        }
        std::move_iterator::reference operator*() const [[nodiscard("")]] {
            return static_cast<std::move_iterator::reference>(*this->_M_current);
        }
        std::move_iterator::pointer operator->() const [[nodiscard("")]] {
            return this->_M_current;
        }
        move_iterator<_Iterator> &operator++() {
            ++this->_M_current;
            return *this;
        }
        move_iterator<_Iterator> operator++(int) {
            move_iterator<_Iterator> __tmp = *this;
            ++this->_M_current;
            return __tmp;
        }
        move_iterator<_Iterator> &operator--() {
            --this->_M_current;
            return *this;
        }
        move_iterator<_Iterator> operator--(int) {
            move_iterator<_Iterator> __tmp = *this;
            --this->_M_current;
            return __tmp;
        }
        move_iterator<_Iterator> operator+(std::move_iterator::difference_type __n) const [[nodiscard("")]] {
            return move_iterator<_Iterator>(this->_M_current + __n);
        }
        move_iterator<_Iterator> &operator+=(std::move_iterator::difference_type __n) {
            this->_M_current += __n;
            return *this;
        }
        move_iterator<_Iterator> operator-(std::move_iterator::difference_type __n) const [[nodiscard("")]] {
            return move_iterator<_Iterator>(this->_M_current - __n);
        }
        move_iterator<_Iterator> &operator-=(std::move_iterator::difference_type __n) {
            this->_M_current -= __n;
            return *this;
        }
        std::move_iterator::reference operator[](std::move_iterator::difference_type __n) const [[nodiscard("")]] {
            return std::move(this->_M_current[__n]);
        }
    };
    template <typename _IteratorL, typename _IteratorR> inline bool operator==(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator!=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return !(__x == __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return !(__x < __y);
    }
    template <typename _Iterator> inline bool operator==(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return __x.base() == __y.base();
    }
    template <typename _Iterator> inline bool operator!=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return !(__x == __y);
    }
    template <typename _Iterator> inline bool operator<(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return __x.base() < __y.base();
    }
    template <typename _Iterator> inline bool operator<=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return !(__y < __x);
    }
    template <typename _Iterator> inline bool operator>(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return __y < __x;
    }
    template <typename _Iterator> inline bool operator>=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline auto operator-(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base()) [[nodiscard("")]] {
        return __x.base() - __y.base();
    }
    template <typename _Iterator> inline move_iterator<_Iterator> operator+(typename move_iterator<_Iterator>::difference_type __n, const move_iterator<_Iterator> &__x) [[nodiscard("")]] {
        return __x + __n;
    }
    template <typename _Iterator> inline move_iterator<_Iterator> make_move_iterator(_Iterator __i) [[nodiscard("")]] {
        return move_iterator<_Iterator>(std::move(__i));
    }
    template <typename _Iterator, typename _ReturnType = __conditional_t<__move_if_noexcept_cond<typename iterator_traits<_Iterator>::value_type>::value, _Iterator, move_iterator<_Iterator>>> inline _ReturnType __make_move_if_noexcept_iterator(_Iterator __i) {
        return _ReturnType(__i);
    }
    template <typename _Tp, typename _ReturnType = __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp *, move_iterator<_Tp *>>> inline _ReturnType __make_move_if_noexcept_iterator(_Tp *__i) {
        return _ReturnType(__i);
    }
    template <typename _Iterator> auto __niter_base(move_iterator<_Iterator> __it) -> decltype(make_move_iterator(__niter_base(__it.base()))) {
        return make_move_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<move_iterator<_Iterator>> {
        enum {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Iterator> auto __miter_base(move_iterator<_Iterator> __it) -> decltype(__miter_base(__it.base())) {
        return __miter_base(__it.base());
    }
}
namespace std {
    template <typename _Arg, typename _Result> struct __attribute__((deprecated(""))) unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <typename _Arg1, typename _Arg2, typename _Result> struct __attribute__((deprecated(""))) binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
    template<> struct __attribute__((deprecated(""))) __attribute__((deprecated(""))) binary_function<const volatile void *, const volatile void *, bool> {
        typedef const volatile void *first_argument_type;
        typedef const volatile void *second_argument_type;
        typedef bool result_type;
    };
    template<> struct __attribute__((deprecated(""))) __attribute__((deprecated(""))) binary_function<const std::error_category *, const std::error_category *, bool> {
        typedef const std::error_category *first_argument_type;
        typedef const std::error_category *second_argument_type;
        typedef bool result_type;
    };
    struct __is_transparent;
    template <typename _Tp = void> struct plus;
    template <typename _Tp = void> struct minus;
    template <typename _Tp = void> struct multiplies;
    template <typename _Tp = void> struct divides;
    template <typename _Tp = void> struct modulus;
    template <typename _Tp = void> struct negate;
    template <typename _Tp = void> struct plus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x + __y;
        }
    };
    template <typename _Tp = void> struct minus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x - __y;
        }
    };
    template <typename _Tp = void> struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x * __y;
        }
    };
    template <typename _Tp = void> struct divides : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x / __y;
        }
    };
    template <typename _Tp = void> struct modulus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x % __y;
        }
    };
    template <typename _Tp = void> struct negate : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const {
            return - __x;
        }
    };
    template<> struct plus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct minus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct multiplies<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct divides<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct modulus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct negate<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))) -> decltype(- std::forward<_Tp>(__t)) {
            return - std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct equal_to;
    template <typename _Tp = void> struct not_equal_to;
    template <typename _Tp = void> struct greater
    template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less
    template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    }
    template<> struct less<const std::error_category *> : public binary_function<const std::error_category *, const std::error_category *, bool> {
        constexpr bool operator()(const std::error_category *__x, const std::error_category *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal
    template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal
    template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x == __y;
        }
    };
    template <typename _Tp = void> struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x != __y;
        }
    };
    template <typename _Tp = void> struct greater : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x > __y;
        }
    };
    template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x < __y;
        }
    };
    template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template<> struct less<const std::error_category *> : public binary_function<const std::error_category *, const std::error_category *, bool> {
        constexpr bool operator()(const std::error_category *__x, const std::error_category *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x >= __y;
        }
    };
    template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x <= __y;
        }
    };
    template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template<> struct equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct not_equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct greater<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return greater<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type) {
            return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept {
            return greater<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return less<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type) {
            return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept {
            return less<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct greater_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return greater_equal<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type) {
            return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept {
            return greater_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return less_equal<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type) {
            return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept {
            return less_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template <typename _Tp = void> struct logical_and;
    template <typename _Tp = void> struct logical_or;
    template <typename _Tp = void> struct logical_not;
    template <typename _Tp = void> struct logical_and : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x && __y;
        }
    };
    template <typename _Tp = void> struct logical_or : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x || __y;
        }
    };
    template <typename _Tp = void> struct logical_not : public unary_function<_Tp, bool> {
        constexpr bool operator()(const _Tp &__x) const {
            return !__x;
        }
    };
    template<> struct logical_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))) -> decltype(!std::forward<_Tp>(__t)) {
            return !std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct bit_and;
    template <typename _Tp = void> struct bit_or;
    template <typename _Tp = void> struct bit_xor;
    template <typename _Tp = void> struct bit_not;
    template <typename _Tp = void> struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x & __y;
        }
    };
    template <typename _Tp = void> struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x | __y;
        }
    };
    template <typename _Tp = void> struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x ^ __y;
        }
    };
    template <typename _Tp = void> struct bit_not : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const {
            return ~__x;
        }
    };
    template<> struct bit_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_xor<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))) -> decltype(~std::forward<_Tp>(__t)) {
            return ~std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Predicate> class unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit unary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x) {
        }
        constexpr bool operator()(const typename _Predicate::argument_type &__x) const {
            return !this->_M_pred(__x);
        }
    };
    template <typename _Predicate> inline constexpr unary_negate<_Predicate> not1(const _Predicate &__pred) {
        return unary_negate<_Predicate>(__pred);
    }
    template <typename _Predicate> class binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit binary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x) {
        }
        constexpr bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const {
            return !this->_M_pred(__x, __y);
        }
    };
    template <typename _Predicate> inline constexpr binary_negate<_Predicate> not2(const _Predicate &__pred) {
        return binary_negate<_Predicate>(__pred);
    }
    template <typename _Arg, typename _Result> class __attribute__((deprecated(""))) pointer_to_unary_function : public unary_function<_Arg, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg);
    public:
        pointer_to_unary_function<_Arg, _Result>() {
        }
        explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__x)(_Arg)) : _M_ptr(__x) {
        }
        _Result operator()(_Arg __x) const {
            return this->_M_ptr(__x);
        }
    };
    template <typename _Arg, typename _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg)) __attribute__((deprecated("use 'std::function' instead"))) {
        return pointer_to_unary_function<_Arg, _Result>(__x);
    }
    template <typename _Arg1, typename _Arg2, typename _Result> class __attribute__((deprecated(""))) pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
        pointer_to_binary_function<_Arg1, _Arg2, _Result>() {
        }
        explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x) {
        }
        _Result operator()(_Arg1 __x, _Arg2 __y) const {
            return this->_M_ptr(__x, __y);
        }
    };
    template <typename _Arg1, typename _Arg2, typename _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2)) __attribute__((deprecated("use 'std::function' instead"))) {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
    }
    template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
        _Tp &operator()(_Tp &__x) const {
            return __x;
        }
        const _Tp &operator()(const _Tp &__x) const {
            return __x;
        }
    };
    template <typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> {
    };
    template <typename _Pair> struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
        typename _Pair::first_type &operator()(_Pair &__x) const {
            return __x.first;
        }
        const typename _Pair::first_type &operator()(const _Pair &__x) const {
            return __x.first;
        }
        template <typename _Pair2> typename _Pair2::first_type &operator()(_Pair2 &__x) const {
            return __x.first;
        }
        template <typename _Pair2> const typename _Pair2::first_type &operator()(const _Pair2 &__x) const {
            return __x.first;
        }
    };
    template <typename _Pair> struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
        typename _Pair::second_type &operator()(_Pair &__x) const {
            return __x.second;
        }
        const typename _Pair::second_type &operator()(const _Pair &__x) const {
            return __x.second;
        }
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) mem_fun_t : public unary_function<_Tp *, _Ret> {
    public:
        explicit mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf) {
        }
        _Ret operator()(_Tp *__p) const {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
    public:
        explicit const_mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp *__p) const {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf) {
        }
        _Ret operator()(_Tp &__r) const {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit const_mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp &__r) const {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
    public:
        explicit mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {
        }
        _Ret operator()(_Tp *__p, _Arg __x) const {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp *__p, _Arg __x) const {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {
        }
        _Ret operator()(_Tp &__r, _Arg __x) const {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp &__r, _Arg __x) const {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp> inline mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)()) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)()) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg)) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Func, typename _SfinaeType, typename = __void_t<>> struct __has_is_transparent {
    };
    template <typename _Func, typename _SfinaeType> struct __has_is_transparent<_Func, _SfinaeType, __void_t<typename _Func::is_transparent>> {
        typedef void type;
    };
    template <typename _Func, typename _SfinaeType> using __has_is_transparent_t = typename __has_is_transparent<_Func, _SfinaeType>::type;
}
namespace std {
    template <typename _Operation> class __attribute__((deprecated("use 'std::bind' instead"))) binder1st : public unary_function<typename _Operation::second_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::first_argument_type value;
    public:
        binder1st<_Operation>(const _Operation &__x, const typename _Operation::first_argument_type &__y) : op(__x), value(__y) {
        }
        typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const {
            return this->op(this->value, __x);
        }
        typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const {
            return this->op(this->value, __x);
        }
    };
    template <typename _Operation, typename _Tp> inline binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x) __attribute__((deprecated("use 'std::bind' instead"))) {
        typedef typename _Operation::first_argument_type _Arg1_type;
        return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
    template <typename _Operation> class __attribute__((deprecated("use 'std::bind' instead"))) binder2nd : public unary_function<typename _Operation::first_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::second_argument_type value;
    public:
        binder2nd<_Operation>(const _Operation &__x, const typename _Operation::second_argument_type &__y) : op(__x), value(__y) {
        }
        typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const {
            return this->op(__x, this->value);
        }
        typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const {
            return this->op(__x, this->value);
        }
    };
    template <typename _Operation, typename _Tp> inline binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x) __attribute__((deprecated("use 'std::bind' instead"))) {
        typedef typename _Operation::second_argument_type _Arg2_type;
        return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
}
namespace __gnu_cxx {
    template <typename _Tp> struct __is_integer_nonstrict : public std::__is_integer<_Tp> {
        using std::__is_integer<_Tp>::__value;
        enum {
            __width = __value ? sizeof(_Tp) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<int> : public std::__is_integer<int> {
        using std::__is_integer<int>::__value;
        enum {
            __width = __value ? sizeof(int) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<unsigned long> : public std::__is_integer<unsigned long> {
        using std::__is_integer<unsigned long>::__value;
        enum {
            __width = __value ? sizeof(unsigned long) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<char> : public std::__is_integer<char> {
        using std::__is_integer<char>::__value;
        enum {
            __width = __value ? sizeof(char) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<long> : public std::__is_integer<long> {
        using std::__is_integer<long>::__value;
        enum {
            __width = __value ? sizeof(long) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<short> : public std::__is_integer<short> {
        using std::__is_integer<short>::__value;
        enum {
            __width = __value ? sizeof(short) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<unsigned long long> : public std::__is_integer<unsigned long long> {
        using std::__is_integer<unsigned long long>::__value;
        enum {
            __width = __value ? sizeof(unsigned long long) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<unsigned int> : public std::__is_integer<unsigned int> {
        using std::__is_integer<unsigned int>::__value;
        enum {
            __width = __value ? sizeof(unsigned int) * 8 : 0
        };
    };
    template <typename _Value> struct __numeric_traits_integer {
        static_assert(__is_integer_nonstrict<_Value>::__value, "invalid specialization");
        static const bool __is_signed = (_Value)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<_Value>::__width - __is_signed;
        static const _Value __max = __is_signed ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1) : ~(_Value)0;
        static const _Value __min = __is_signed ? - __max - 1 : (_Value)0;
    };
    template<> struct __numeric_traits_integer<int> {
        static_assert(__is_integer_nonstrict<int>::__value, "invalid specialization");
        static const bool __is_signed = (int)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<int>::__width - __is_signed;
        static const int __max = __is_signed ? (((((int)1 << (__digits - 1)) - 1) << 1) + 1) : ~(int)0;
        static const int __min = __is_signed ? -__max - 1 : (int)0;
    };
    template<> struct __numeric_traits_integer<unsigned long> {
        static_assert(__is_integer_nonstrict<unsigned long>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned long>::__width - __is_signed;
        static const unsigned long __max = __is_signed ? (((((unsigned long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned long)0;
        static const unsigned long __min = __is_signed ? -__max - 1 : (unsigned long)0;
    };
    template<> struct __numeric_traits_integer<char> {
        static_assert(__is_integer_nonstrict<char>::__value, "invalid specialization");
        static const bool __is_signed = (char)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<char>::__width - __is_signed;
        static const char __max = __is_signed ? (((((char)1 << (__digits - 1)) - 1) << 1) + 1) : ~(char)0;
        static const char __min = __is_signed ? -__max - 1 : (char)0;
    };
    template<> struct __numeric_traits_integer<long> {
        static_assert(__is_integer_nonstrict<long>::__value, "invalid specialization");
        static const bool __is_signed = (long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<long>::__width - __is_signed;
        static const long __max = __is_signed ? (((((long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(long)0;
        static const long __min = __is_signed ? -__max - 1 : (long)0;
    };
    template<> struct __numeric_traits_integer<short> {
        static_assert(__is_integer_nonstrict<short>::__value, "invalid specialization");
        static const bool __is_signed = (short)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<short>::__width - __is_signed;
        static const short __max = __is_signed ? (((((short)1 << (__digits - 1)) - 1) << 1) + 1) : ~(short)0;
        static const short __min = __is_signed ? -__max - 1 : (short)0;
    };
    template<> struct __numeric_traits_integer<unsigned long long> {
        static_assert(__is_integer_nonstrict<unsigned long long>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned long long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned long long>::__width - __is_signed;
        static const unsigned long long __max = __is_signed ? (((((unsigned long long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned long long)0;
        static const unsigned long long __min = __is_signed ? -__max - 1 : (unsigned long long)0;
    };
    template<> struct __numeric_traits_integer<unsigned int> {
        static_assert(__is_integer_nonstrict<unsigned int>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned int)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned int>::__width - __is_signed;
        static const unsigned int __max = __is_signed ? (((((unsigned int)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned int)0;
        static const unsigned int __min = __is_signed ? -__max - 1 : (unsigned int)0;
    };
    const _Value __min;
    const _Value __max;
    const bool __is_signed;
    const int __digits;
    template <typename _Tp> using __int_traits = __numeric_traits_integer<_Tp>;
    template <typename _Value> struct __numeric_traits_floating {
        static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
    template<> struct __numeric_traits_floating<float> {
        static const int __max_digits10 = (2 + (std::__are_same<float, float>::__value ? 24 : std::__are_same<float, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<float, float>::__value ? 6 : std::__are_same<float, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<float, float>::__value ? 38 : std::__are_same<float, double>::__value ? 308 : 4932);
    };
    template<> struct __numeric_traits_floating<double> {
        static const int __max_digits10 = (2 + (std::__are_same<double, float>::__value ? 24 : std::__are_same<double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<double, float>::__value ? 6 : std::__are_same<double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<double, float>::__value ? 38 : std::__are_same<double, double>::__value ? 308 : 4932);
    };
    template<> struct __numeric_traits_floating<long double> {
        static const int __max_digits10 = (2 + (std::__are_same<long double, float>::__value ? 24 : std::__are_same<long double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<long double, float>::__value ? 6 : std::__are_same<long double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<long double, float>::__value ? 38 : std::__are_same<long double, double>::__value ? 308 : 4932);
    };
    const int __max_digits10;
    const bool __is_signed;
    const int __digits10;
    const int __max_exponent10;
    template <typename _Value> struct __numeric_traits : public __numeric_traits_integer<_Value> {
    };
    template<> struct __numeric_traits<int> : public __numeric_traits_integer<int> {
    };
    template<> struct __numeric_traits<unsigned long> : public __numeric_traits_integer<unsigned long> {
    };
    template<> struct __numeric_traits<char> : public __numeric_traits_integer<char> {
    };
    template<> struct __numeric_traits<long> : public __numeric_traits_integer<long> {
    };
    template<> struct __numeric_traits<short> : public __numeric_traits_integer<short> {
    };
    template<> struct __numeric_traits<float> : public __numeric_traits_floating<float> {
    };
    template<> struct __numeric_traits<double> : public __numeric_traits_floating<double> {
    };
    template<> struct __numeric_traits<long double> : public __numeric_traits_floating<long double> {
    };
    const bool __is_signed;
    const int __digits;
    const int __max;
    const int __min;
    const int __max_exponent10;
    const int __max_exponent10;
    const int __max_exponent10;
    const bool __is_signed;
    const int __digits;
    const unsigned long __max;
    const bool __is_signed;
    const int __digits;
    const char __max;
    const bool __is_signed;
    const int __digits;
    const long __max;
    const bool __is_signed;
    const int __digits;
    const short __max;
    const short __min;
    const long __min;
    const bool __is_signed;
    const int __digits;
    const unsigned long long __max;
    const bool __is_signed;
    const int __digits;
    const unsigned int __max;
}
namespace std {
    template <typename _Tp> struct tuple_size;
    template <typename _Tp, typename _Up = typename remove_cv<_Tp>::type, typename = typename enable_if<is_same<_Tp, _Up>::value>::type, std::size_t = tuple_size<_Tp>::value> using __enable_if_has_tuple_size = _Tp;
    template <typename _Tp> struct tuple_size<const __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <std::size_t __i, typename _Tp> struct tuple_element;
    template <std::size_t __i, typename _Tp> using __tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, const _Tp> {
        typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, volatile _Tp> {
        typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, const volatile _Tp> {
        typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <typename _Tp, typename ..._Types> constexpr std::size_t __find_uniq_type_in_pack() {
        constexpr std::size_t __sz = sizeof...(_Types);
        constexpr bool __found[__sz] = {__is_same(_Tp, _Types)...};
        std::size_t __n = __sz;
        for (std::size_t __i = 0; __i < __sz; ++__i) {
            if (__found[__i]) {
                if (__n < __sz)
                    return __sz;
                __n = __i;
            }
        }
        return __n;
    }
    template <std::size_t __i, typename _Tp> using tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <std::size_t ..._Indexes> struct _Index_tuple {
    };
    template <std::size_t _Num> struct _Build_index_tuple {
        template <typename, std::size_t ..._Indices> using _IdxTuple = _Index_tuple<_Indices...>;
        using __type = __make_integer_seq<_IdxTuple, std::size_t, _Num>;
    };
    template <typename _Tp, _Tp ..._Idx> struct integer_sequence {
        typedef _Tp value_type;
        static constexpr std::size_t size() noexcept {
            return sizeof...(_Idx);
        }
    };
    template <typename _Tp, _Tp _Num> using make_integer_sequence = __make_integer_seq<std::integer_sequence, _Tp, _Num>;
    template <std::size_t ..._Idx> using index_sequence = integer_sequence<std::size_t, _Idx...>;
    template <std::size_t _Num> using make_index_sequence = make_integer_sequence<std::size_t, _Num>;
    template <typename ..._Types> using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
    template <std::size_t _Np, typename ..._Types> struct _Nth_type {
    };
    template <typename _Tp0, typename ..._Rest> struct _Nth_type<0, _Tp0, _Rest...> {
        using type = _Tp0;
    };
    template <typename _Tp0, typename _Tp1, typename ..._Rest> struct _Nth_type<1, _Tp0, _Tp1, _Rest...> {
        using type = _Tp1;
    };
    template <typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...> {
        using type = _Tp2;
    };
    template <std::size_t _Np, typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...> : _Nth_type<_Np - 3, _Rest...> {
    };
    template <typename _Tp0, typename _Tp1, typename ..._Rest> struct _Nth_type<0, _Tp0, _Tp1, _Rest...> {
        using type = _Tp0;
    };
    template <typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<0, _Tp0, _Tp1, _Tp2, _Rest...> {
        using type = _Tp0;
    };
    template <typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<1, _Tp0, _Tp1, _Tp2, _Rest...> {
        using type = _Tp1;
    };
}
namespace std {
    struct piecewise_construct_t {
        explicit piecewise_construct_t() noexcept = default
    };
    constexpr std::piecewise_construct_t piecewise_construct = std::piecewise_construct_t();
    template <typename ...> class tuple;
    template <std::size_t ...> struct _Index_tuple;
    template <bool, typename _T1, typename _T2> struct _PCC {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair() {
            return __and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, const _U2 &>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair() {
            return __and_<is_convertible<const _U1 &, _T1>, is_convertible<const _U2 &, _T2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair() {
            return __and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, _U2 &&>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair() {
            return __and_<is_convertible<_U1 &&, _T1>, is_convertible<_U2 &&, _T2>>::value;
        }
    };
    template <typename _T1, typename _T2> struct _PCC<false, _T1, _T2> {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair() {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair() {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair() {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair() {
            return false;
        }
    };
    template <typename _U1, typename _U2> class __pair_base {
        friend template <typename _T1, typename _T2> struct pair;
        __pair_base<_U1, _U2>() = default
        ~__pair_base<_U1, _U2>() = default
        __pair_base<_U1, _U2>(const __pair_base<_U1, _U2> &) = default
        __pair_base<_U1, _U2> &operator=(const __pair_base<_U1, _U2> &) = delete
    };
    template <typename _T1, typename _T2> struct pair : public __pair_base<_T1, _T2> {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        pair<_T1, _T2>(const pair<_T1, _T2> &) = default
        pair<_T1, _T2>(pair<_T1, _T2> &&) = default
        template <typename ..._Args1, typename ..._Args2> pair<_T1, _T2>(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        void swap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value) {
            using std::swap;
            swap(this->first, __p.first);
            swap(this->second, __p.second);
        }
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> pair<_T1, _T2>(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>::value, bool>::type = true> constexpr pair<_T1, _T2>() : first(), second() {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>>>::value, bool>::type = false> constexpr explicit pair<_T1, _T2>() : first(), second() {
        }
        using _PCCP = _PCC<true, _T1, _T2>;
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b) {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b) {
        }
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<_T1, _U1>::value || !is_same<_T2, _U2>::value, _T1, _T2>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second) {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second) {
        }
    private:
        struct __zero_as_null_pointer_constant {
            __zero_as_null_pointer_constant(int std::pair::__zero_as_null_pointer_constant::*) {
            }
            template <typename _Tp, typename = __enable_if_t<is_null_pointer<_Tp>::value>> __zero_as_null_pointer_constant(_Tp) = delete
        };
    public:
        template <typename _U1, __enable_if_t<__and_<__not_<is_reference<_U1>>, is_pointer<_T2>, is_constructible<_T1, _U1>, __not_<is_constructible<_T1, const _U1 &>>, is_convertible<_U1, _T1>>::value, bool> = true> constexpr pair<_T1, _T2>(_U1 &&__x, std::pair::__zero_as_null_pointer_constant, ...) : first(std::forward<_U1>(__x)), second(nullptr) __attribute__((deprecated("use 'nullptr' instead of '0' to initialize std::pair of move-only type and pointer"))) {
        }
        template <typename _U1, __enable_if_t<__and_<__not_<is_reference<_U1>>, is_pointer<_T2>, is_constructible<_T1, _U1>, __not_<is_constructible<_T1, const _U1 &>>, __not_<is_convertible<_U1, _T1>>>::value, bool> = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, std::pair::__zero_as_null_pointer_constant, ...) : first(std::forward<_U1>(__x)), second(nullptr) __attribute__((deprecated("use 'nullptr' instead of '0' to initialize std::pair of move-only type and pointer"))) {
        }
        template <typename _U2, __enable_if_t<__and_<is_pointer<_T1>, __not_<is_reference<_U2>>, is_constructible<_T2, _U2>, __not_<is_constructible<_T2, const _U2 &>>, is_convertible<_U2, _T2>>::value, bool> = true> constexpr pair<_T1, _T2>(std::pair::__zero_as_null_pointer_constant, _U2 &&__y, ...) : first(nullptr), second(std::forward<_U2>(__y)) __attribute__((deprecated("use 'nullptr' instead of '0' to initialize std::pair of move-only type and pointer"))) {
        }
        template <typename _U2, __enable_if_t<__and_<is_pointer<_T1>, __not_<is_reference<_U2>>, is_constructible<_T2, _U2>, __not_<is_constructible<_T2, const _U2 &>>, __not_<is_convertible<_U2, _T2>>>::value, bool> = false> constexpr explicit pair<_T1, _T2>(std::pair::__zero_as_null_pointer_constant, _U2 &&__y, ...) : first(nullptr), second(std::forward<_U2>(__y)) __attribute__((deprecated("use 'nullptr' instead of '0' to initialize std::pair of move-only type and pointer"))) {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {
        }
        pair<_T1, _T2> &operator=(__conditional_t<__and_<is_copy_assignable<_T1>, is_copy_assignable<_T2>>::value, const pair<_T1, _T2> &, const std::__nonesuch &> __p) {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        pair<_T1, _T2> &operator=(__conditional_t<__and_<is_move_assignable<_T1>, is_move_assignable<_T2>>::value, pair<_T1, _T2> &&, std::__nonesuch &&> __p) noexcept(__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2>>::value) {
            this->first = std::forward<std::pair::first_type>(__p.first);
            this->second = std::forward<std::pair::second_type>(__p.second);
            return *this;
        }
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<_T1 &, const _U1 &>, is_assignable<_T2 &, const _U2 &>>::value, pair<_T1, _T2> &>::type operator=(const pair<_U1, _U2> &__p) {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<_T1 &, _U1 &&>, is_assignable<_T2 &, _U2 &&>>::value, pair<_T1, _T2> &>::type operator=(pair<_U1, _U2> &&__p) {
            this->first = std::forward<_U1>(__p.first);
            this->second = std::forward<_U2>(__p.second);
            return *this;
        }
    };
    template <typename _T1, typename _T2> inline constexpr bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        return __x.first == __y.first && __x.second == __y.second;
    }
    template <typename _T1, typename _T2> inline constexpr bool operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        return !(__x == __y);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        return __y < __x;
    }
    template <typename _T1, typename _T2> inline constexpr bool operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        return !(__y < __x);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        return !(__x < __y);
    }
    template <typename _T1, typename _T2> inline typename enable_if<__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y))) {
        __x.swap(__y);
    }
    template <typename _T1, typename _T2> typename enable_if<!__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete
    template <typename _T1, typename _T2> constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y) {
        typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        typedef pair<__ds_type1, __ds_type2> __pair_type;
        return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
    template <typename _T1, typename _T2> struct __is_tuple_like_impl<pair<_T1, _T2>> : std::true_type {
    };
    template <class _Tp1, class _Tp2> struct tuple_size<pair<_Tp1, _Tp2>> : public integral_constant<std::size_t, 2> {
    };
    template <class _Tp1, class _Tp2> struct tuple_element<0, pair<_Tp1, _Tp2>> {
        typedef _Tp1 type;
    };
    template <class _Tp1, class _Tp2> struct tuple_element<1, pair<_Tp1, _Tp2>> {
        typedef _Tp2 type;
    };
    template <std::size_t _Int> struct __pair_get;
    template<> struct __pair_get<0> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<_Tp1>(__pair.first);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &&__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<const _Tp1>(__pair.first);
        }
    };
    template<> struct __pair_get<1> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<_Tp2>(__pair.second);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &&__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<const _Tp2>(__pair.second);
        }
    };
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(pair<_Tp1, _Tp2> &__in) noexcept {
        return __pair_get<_Int>::__get(__in);
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(pair<_Tp1, _Tp2> &&__in) noexcept {
        return __pair_get<_Int>::__move_get(std::move(__in));
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(const pair<_Tp1, _Tp2> &__in) noexcept {
        return __pair_get<_Int>::__const_get(__in);
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(const pair<_Tp1, _Tp2> &&__in) noexcept {
        return __pair_get<_Int>::__const_move_get(std::move(__in));
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Tp, _Up> &__p) noexcept {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Tp, _Up> &__p) noexcept {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Tp, _Up> &&__p) noexcept {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Tp, _Up> &&__p) noexcept {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Up, _Tp> &__p) noexcept {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Up, _Tp> &__p) noexcept {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Up, _Tp> &&__p) noexcept {
        return std::move(__p.second);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Up, _Tp> &&__p) noexcept {
        return std::move(__p.second);
    }
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
    template <typename _Ite, typename _Seq, typename _Cat> struct _Safe_iterator;
}
namespace __gnu_cxx {
    namespace __ops {
        struct _Iter_less_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
                return *__it1 < *__it2;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_less_iter __iter_less_iter() {
            return __gnu_cxx::__ops::_Iter_less_iter();
        }
        struct _Iter_less_val {
            _Iter_less_val() noexcept = default
            explicit _Iter_less_val(__gnu_cxx::__ops::_Iter_less_iter) {
            }
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const {
                return *__it < __val;
            }
        };
        inline __gnu_cxx::__ops::_Iter_less_val __iter_less_val() {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        inline __gnu_cxx::__ops::_Iter_less_val __iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter) {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        struct _Val_less_iter {
            _Val_less_iter() noexcept = default
            explicit _Val_less_iter(__gnu_cxx::__ops::_Iter_less_iter) {
            }
            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it) const {
                return __val < *__it;
            }
        };
        inline __gnu_cxx::__ops::_Val_less_iter __val_less_iter() {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        inline __gnu_cxx::__ops::_Val_less_iter __val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter) {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        struct _Iter_equal_to_iter {
            template <typename _Iterator1, typename _Iterator2> bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
                return *__it1 == *__it2;
            }
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter() {
            return __gnu_cxx::__ops::_Iter_equal_to_iter();
        }
        struct _Iter_equal_to_val {
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const {
                return *__it == __val;
            }
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val() {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter) {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        template <typename _Compare> struct _Iter_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp)) {
            }
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) {
                return bool(this->_M_comp(*__it1, *__it2));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp) {
            return _Iter_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Iter_comp_val {
            _Compare _M_comp;
            explicit _Iter_comp_val<_Compare>(_Compare __comp) : _M_comp(std::move(__comp)) {
            }
            explicit _Iter_comp_val<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp) {
            }
            explicit _Iter_comp_val<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp)) {
            }
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) {
                return bool(this->_M_comp(*__it, __val));
            }
        };
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp) {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Iter_comp_iter<_Compare> __comp) {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Val_comp_iter {
            _Compare _M_comp;
            explicit _Val_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp)) {
            }
            explicit _Val_comp_iter<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp) {
            }
            explicit _Val_comp_iter<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp)) {
            }
            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it) {
                return bool(this->_M_comp(__val, *__it));
            }
        };
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp) {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Iter_comp_iter<_Compare> __comp) {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Value> struct _Iter_equals_val {
            _Value &_M_value;
            explicit _Iter_equals_val<_Value>(_Value &__value) : _M_value(__value) {
            }
            template <typename _Iterator> bool operator()(_Iterator __it) {
                return *__it == this->_M_value;
            }
        };
        template <typename _Value> inline _Iter_equals_val<_Value> __iter_equals_val(_Value &__val) {
            return _Iter_equals_val<_Value>(__val);
        }
        template <typename _Iterator1> struct _Iter_equals_iter {
            _Iterator1 _M_it1;
            explicit _Iter_equals_iter<_Iterator1>(_Iterator1 __it1) : _M_it1(__it1) {
            }
            template <typename _Iterator2> bool operator()(_Iterator2 __it2) {
                return *__it2 == *this->_M_it1;
            }
        };
        template <typename _Iterator> inline _Iter_equals_iter<_Iterator> __iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it) {
            return _Iter_equals_iter<_Iterator>(__it);
        }
        template <typename _Predicate> struct _Iter_pred {
            _Predicate _M_pred;
            explicit _Iter_pred<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred)) {
            }
            template <typename _Iterator> bool operator()(_Iterator __it) {
                return bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline _Iter_pred<_Predicate> __pred_iter(_Predicate __pred) {
            return _Iter_pred<_Predicate>(std::move(__pred));
        }
        template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
            _Compare _M_comp;
            _Value &_M_value;
            _Iter_comp_to_val<_Compare, _Value>(_Compare __comp, _Value &__value) : _M_comp(std::move(__comp)), _M_value(__value) {
            }
            template <typename _Iterator> bool operator()(_Iterator __it) {
                return bool(this->_M_comp(*__it, this->_M_value));
            }
        };
        template <typename _Compare, typename _Value> _Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val) {
            return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
        }
        template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
            _Compare _M_comp;
            _Iterator1 _M_it1;
            _Iter_comp_to_iter<_Compare, _Iterator1>(_Compare __comp, _Iterator1 __it1) : _M_comp(std::move(__comp)), _M_it1(__it1) {
            }
            template <typename _Iterator2> bool operator()(_Iterator2 __it2) {
                return bool(this->_M_comp(*__it2, *this->_M_it1));
            }
        };
        template <typename _Compare, typename _Iterator> inline _Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it) {
            return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp), __it);
        }
        template <typename _Predicate> struct _Iter_negate {
            _Predicate _M_pred;
            explicit _Iter_negate<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred)) {
            }
            template <typename _Iterator> bool operator()(_Iterator __it) {
                return !bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred) {
            return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
        }
    }
}
namespace std {
    template <typename _Tp, typename _Up> inline constexpr int __memcmp(const _Tp *__first1, const _Up *__first2, std::size_t __num) {
        static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
        return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) {
        swap(*__a, *__b);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            std::iter_swap(__first1, __first2);
        return __first2;
    }
    template <typename _Tp> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b) {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const unsigned long &min<unsigned long>(const unsigned long &__a, const unsigned long &__b) {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const long &min<long>(const long &__a, const long &__b) {
        if (__b < __a)
            return __b;
        return __a;
    }
    template <typename _Tp> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b) {
        if (__a < __b)
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp) {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp) {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }
    template <typename _Iterator> inline _Iterator __niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value) {
        return __it;
    }
    template <typename _Ite, typename _Seq> _Ite __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, std::random_access_iterator_tag> &);
    template <typename _From, typename _To> inline _From __niter_wrap(_From __from, _To __res) {
        return __from + (__res - std::__niter_base(__from));
    }
    template <typename _Iterator> inline _Iterator __niter_wrap(const _Iterator &, _Iterator __res) {
        return __res;
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result) {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = *__first;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move<true, false, _Category> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result) {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = std::move(*__first);
            return __result;
        }
    };
    template<> struct __copy_move<false, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result) {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template<> struct __copy_move<true, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result) {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = std::move(*__first);
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result) {
            using __assignable = __conditional_t<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::value, "type must be assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
            return __result + _Num;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr> struct _Deque_iterator;
    struct _Bit_iterator;
    template <typename _CharT> struct char_traits;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, _CharT *);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, std::_Deque_iterator<_CharT, _CharT &, _CharT *>);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a2(_II __first, _II __last, _OI __result) {
        typedef typename iterator_traits<_II>::iterator_category _Category;
        return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a1(_II __first, _II __last, _OI __result) {
        return std::__copy_move_a2<_IsMove>(__first, __last, __result);
    }
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a(_II __first, _II __last, _OI __result) {
        return std::__niter_wrap(__result, std::__copy_move_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _InputIterator, typename _Size, typename _OutputIterator> _OutputIterator __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result, bool) {
        if (__n > 0) {
            while (true)
                {
                    *__result = *__first;
                    ++__result;
                    if (--__n > 0)
                        ++__first;
                    else
                        break;
                }
        }
        return __result;
    }
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, _CharT *, bool);
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, std::_Deque_iterator<_CharT, _CharT &, _CharT *>, bool);
    template <typename _II, typename _OI> inline _OI copy(_II __first, _II __last, _OI __result) {
        ;
        return std::__copy_move_a<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _II, typename _OI> inline _OI move(_II __first, _II __last, _OI __result) {
        ;
        return std::__copy_move_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move_backward<true, false, _Category> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            while (__first != __last)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template<> struct __copy_move_backward<false, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
    };
    template<> struct __copy_move_backward<true, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move_backward<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result) {
            using __assignable = __conditional_t<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::value, "type must be assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
            return __result - _Num;
        }
    };
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result) {
        typedef typename iterator_traits<_BI1>::iterator_category _Category;
        return std::__copy_move_backward<_IsMove, __memcpyable<_BI2, _BI1>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result) {
        return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_backward_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_backward_a(_II __first, _II __last, _OI __result) {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _BI1, typename _BI2> inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _BI1, typename _BI2> inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result) {
        ;
        return std::__copy_move_backward_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) {
        for (; __first != __last; ++__first)
            *__first = __value;
    }
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) {
        const _Tp __tmp = __value;
        for (; __first != __last; ++__first)
            *__first = __tmp;
    }
    template <typename _Tp> inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a1(_Tp *__first, _Tp *__last, const _Tp &__c) {
        const _Tp __tmp = __c;
        if (const std::size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template <typename _Ite, typename _Cont, typename _Tp> inline void __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first, ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last, const _Tp &__value) {
        std::__fill_a1(__first.base(), __last.base(), __value);
    }
    template <typename _Tp, typename _VTp> void __fill_a1(const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const _VTp &);
    void __fill_a1(std::_Bit_iterator, std::_Bit_iterator, const bool &);
    template <typename _FIte, typename _Tp> inline void __fill_a(_FIte __first, _FIte __last, const _Tp &__value) {
        std::__fill_a1(__first, __last, __value);
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Tp> void __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const _Tp &);
    template <typename _ForwardIterator, typename _Tp> inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) {
        ;
        std::__fill_a(__first, __last, __value);
    }
    inline constexpr int __size_to_integer(int __n) {
        return __n;
    }
    inline constexpr unsigned int __size_to_integer(unsigned int __n) {
        return __n;
    }
    inline constexpr long __size_to_integer(long __n) {
        return __n;
    }
    inline constexpr unsigned long __size_to_integer(unsigned long __n) {
        return __n;
    }
    inline constexpr long long __size_to_integer(long long __n) {
        return __n;
    }
    inline constexpr unsigned long long __size_to_integer(unsigned long long __n) {
        return __n;
    }
    inline constexpr __int128 __size_to_integer(__int128 __n) {
        return __n;
    }
    inline constexpr unsigned __int128 __size_to_integer(unsigned __int128 __n) {
        return __n;
    }
    inline constexpr long long __size_to_integer(float __n) {
        return (long long)__n;
    }
    inline constexpr long long __size_to_integer(double __n) {
        return (long long)__n;
    }
    inline constexpr long long __size_to_integer(long double __n) {
        return (long long)__n;
    }
    inline constexpr long long __size_to_integer(__float128 __n) {
        return (long long)__n;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
        for (; __n > 0; --__n , (void)++__first)
            *__first = __value;
        return __first;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
        const _Tp __tmp = __value;
        for (; __n > 0; --__n , (void)++__first)
            *__first = __tmp;
        return __first;
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Size, typename _Tp> ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first, _Size __n, const _Tp &__value, std::input_iterator_tag);
    template <typename _OutputIterator, typename _Size, typename _Tp> inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::output_iterator_tag) {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::input_iterator_tag) {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::random_access_iterator_tag) {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template <typename _OI, typename _Size, typename _Tp> inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value) {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template <bool _BoolType> struct __equal {
        template <typename _II1, typename _II2> static bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!(*__first1 == *__first2))
                    return false;
            return true;
        }
    };
    template<> struct __equal<true> {
        template <typename _Tp> static bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2) {
            if (const std::size_t __len = (__last1 - __first1))
                return !std::__memcmp(__first1, __first2, __len);
            return true;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr, typename _II> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _II);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II, typename _Tp, typename _Ref, typename _Ptr> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(_II, _II, std::_Deque_iterator<_Tp, _Ref, _Ptr>);
    template <typename _II1, typename _II2> inline bool __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2) {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        const bool __simple = ((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __memcmpable<_II1, _II2>::__value);
        return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
    template <typename _II1, typename _II2> inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2) {
        return std::__equal_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
    }
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, _II2);
    template <typename _II1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename, typename> struct __lc_rai {
        template <typename _II1, typename _II2> static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2) {
            return __last1;
        }
        template <typename _II> static bool __cnd2(_II __first, _II __last) {
            return __first != __last;
        }
    };
    template<> struct __lc_rai<std::random_access_iterator_tag, std::random_access_iterator_tag> {
        template <typename _RAI1, typename _RAI2> static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2) {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }
        template <typename _RAI> static bool __cnd2(_RAI, _RAI) {
            return true;
        }
    };
    template <typename _II1, typename _II2, typename _Compare> bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp) {
        typedef typename iterator_traits<_II1>::iterator_category _Category1;
        typedef typename iterator_traits<_II2>::iterator_category _Category2;
        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ++__first1 , (void)++__first2) {
            if (__comp(__first1, __first2))
                return true;
            if (__comp(__first2, __first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template <bool _BoolType> struct __lexicographical_compare {
        template <typename _II1, typename _II2> static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
            using __gnu_cxx::__ops::__iter_less_iter;
            return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __iter_less_iter());
        }
        template <typename _II1, typename _II2> static int __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
            while (__first1 != __last1)
                {
                    if (__first2 == __last2)
                        return +1;
                    if (*__first1 < *__first2)
                        return -1;
                    if (*__first2 < *__first1)
                        return +1;
                    ++__first1;
                    ++__first2;
                }
            return int(__first2 == __last2) - 1;
        }
    };
    template<> struct __lexicographical_compare<true> {
        template <typename _Tp, typename _Up> static bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2) {
            return __3way(__first1, __last1, __first2, __last2) < 0;
        }
        template <typename _Tp, typename _Up> static std::ptrdiff_t __3way(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2) {
            const std::size_t __len1 = __last1 - __first1;
            const std::size_t __len2 = __last2 - __first2;
            if (const std::size_t __len = std::min(__len1, __len2))
                if (int __result = std::__memcmp(__first1, __first2, __len))
                    return __result;
            return std::ptrdiff_t(__len1 - __len2);
        }
    };
    template <typename _II1, typename _II2> inline bool __lexicographical_compare_aux1(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value);
        return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
    }
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2> bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, _Tp2 *, _Tp2 *);
    template <typename _Tp1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __lexicographical_compare_aux1(_Tp1 *, _Tp1 *, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II1, typename _II2> inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        return std::__lexicographical_compare_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
    }
    template <typename _Iter1, typename _Seq1, typename _Cat1, typename _II2> bool __lexicographical_compare_aux(const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, _II2, _II2);
    template <typename _II1, typename _Iter2, typename _Seq2, typename _Cat2> bool __lexicographical_compare_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
    template <typename _Iter1, typename _Seq1, typename _Cat1, typename _Iter2, typename _Seq2, typename _Cat2> bool __lexicographical_compare_aux(const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
    template <typename _ForwardIterator, typename _Tp, typename _Compare> _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp) {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else
                    __len = __half;
            }
        return __first;
    }
    template <typename _ForwardIterator, typename _Tp> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    }
    inline constexpr int __lg(int __n) {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr unsigned int __lg(unsigned int __n) {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr long __lg(long __n) {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr unsigned long __lg(unsigned long __n) {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr long long __lg(long long __n) {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    inline constexpr unsigned long long __lg(unsigned long long __n) {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    template <typename _II1, typename _II2> inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {
        ;
        return std::__equal_aux(__first1, __last1, __first2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred) {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return true;
    }
    template <typename _II1, typename _II2> inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!(*__first1 == *__first2))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2, typename _BinaryPredicate> inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _BinaryPredicate __binary_pred) {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2, __binary_pred);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2> inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred) {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
    }
    template <typename _II1, typename _II2> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        ;
        ;
        return std::__lexicographical_compare_aux(__first1, __last1, __first2, __last2);
    }
    template <typename _II1, typename _II2, typename _Compare> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp) {
        ;
        ;
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred) {
        while (__first1 != __last1 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred) {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred) {
        while (__first1 != __last1 && __first2 != __last2 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred) {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator, typename _Predicate> inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, std::input_iterator_tag) {
        while (__first != __last && !__pred(__first))
            ++__first;
        return __first;
    }
    template <typename _RandomAccessIterator, typename _Predicate> _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, std::random_access_iterator_tag) {
        typename iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
        for (; __trip_count > 0; --__trip_count) {
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
        }
        switch (__last - __first) {
          case 3:
            if (__pred(__first))
                return __first;
            ++__first;
          case 2:
            if (__pred(__first))
                return __first;
            ++__first;
          case 1:
            if (__pred(__first))
                return __first;
            ++__first;
          case 0:
          default:
            return __last;
        }
    }
    template <typename _Iterator, typename _Predicate> inline _Iterator __find_if(_Iterator __first, _Iterator __last, _Predicate __pred) {
        return __find_if(__first, __last, __pred, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Predicate> typename iterator_traits<_InputIterator>::difference_type __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        for (; __first != __last; ++__first)
            if (__pred(__first))
                ++__n;
        return __n;
    }
    template <typename _ForwardIterator, typename _Predicate> _ForwardIterator __remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
        __first = std::__find_if(__first, __last, __pred);
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        ++__first;
        for (; __first != __last; ++__first)
            if (!__pred(__first)) {
                *__result = std::move(*__first);
                ++__result;
            }
        return __result;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred) {
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!__pred(__first1, __first2))
                break;
        if (__first1 == __last1)
            return true;
        _ForwardIterator2 __last2 = __first2;
        std::advance(__last2, std::distance(__first1, __last1));
        for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
            if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                continue;
            auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
            if (0 == __matches || std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)
                return false;
        }
        return true;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
        ;
        return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
}
namespace std {
    template <typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type> constexpr _Up &&__invfwd(typename remove_reference<_Tp>::type &__t) noexcept {
        return static_cast<_Up &&>(__t);
    }
    template <typename _Res, typename _Fn, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_other, _Fn &&__f, _Args &&...__args) {
        return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_memfun_ref, _MemFun &&__f, _Tp &&__t, _Args &&...__args) {
        return (__invfwd<_Tp>(__t) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_memfun_deref, _MemFun &&__f, _Tp &&__t, _Args &&...__args) {
        return ((*std::forward<_Tp>(__t)) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(std::__invoke_memobj_ref, _MemPtr &&__f, _Tp &&__t) {
        return __invfwd<_Tp>(__t) .* __f;
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(std::__invoke_memobj_deref, _MemPtr &&__f, _Tp &&__t) {
        return (*std::forward<_Tp>(__t)) .* __f;
    }
    template <typename _Callable, typename ..._Args> constexpr typename __invoke_result<_Callable, _Args...>::type __invoke(_Callable &&__fn, _Args &&...__args) noexcept(__is_nothrow_invocable<_Callable, _Args...>::value) {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        return std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _Callable, typename ..._Args> using __can_invoke_as_void = __enable_if_t<__and_<is_void<_Res>, __is_invocable<_Callable, _Args...>>::value, _Res>;
    template <typename _Res, typename _Callable, typename ..._Args> using __can_invoke_as_nonvoid = __enable_if_t<__and_<__not_<is_void<_Res>>, is_convertible<typename __invoke_result<_Callable, _Args...>::type, _Res>>::value, _Res>;
    template <typename _Res, typename _Callable, typename ..._Args> constexpr __can_invoke_as_nonvoid<_Res, _Callable, _Args...> __invoke_r(_Callable &&__fn, _Args &&...__args) {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        return std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _Callable, typename ..._Args> constexpr __can_invoke_as_void<_Res, _Callable, _Args...> __invoke_r(_Callable &&__fn, _Args &&...__args) {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
}
namespace std {
    template <typename _Res, typename ..._ArgTypes> struct _Maybe_unary_or_binary_function {
    };
    template <typename _Res, typename _T1> struct _Maybe_unary_or_binary_function<_Res, _T1> : std::unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Maybe_unary_or_binary_function<_Res, _T1, _T2> : std::binary_function<_T1, _T2, _Res> {
    };
    template <typename _Signature> struct _Mem_fn_traits;
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits_base {
        using __result_type = _Res;
        using __maybe_type = _Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes...>;
        using __arity = integral_constant<std::size_t, sizeof...(_ArgTypes)>;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Functor, typename = __void_t<>> struct _Maybe_get_result_type {
    };
    template <typename _Functor> struct _Maybe_get_result_type<_Functor, __void_t<typename _Functor::result_type>> {
        typedef typename _Functor::result_type result_type;
    };
    template <typename _Functor> struct _Weak_result_type_impl : _Maybe_get_result_type<_Functor> {
    };
    template <typename _Res, typename ..._ArgTypes> struct _Weak_result_type_impl<_Res (_ArgTypes...)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes> struct _Weak_result_type_impl<_Res (_ArgTypes..., ...)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes> struct _Weak_result_type_impl<_Res (*)(_ArgTypes...)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes> struct _Weak_result_type_impl<_Res (*)(_ArgTypes..., ...)> {
        typedef _Res result_type;
    };
    template <typename _Functor, bool = is_member_function_pointer<_Functor>::value> struct _Weak_result_type_memfun : _Weak_result_type_impl<_Functor> {
    };
    template <typename _MemFunPtr> struct _Weak_result_type_memfun<_MemFunPtr, true> {
        using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };
    template <typename _Func, typename _Class> struct _Weak_result_type_memfun<_Func _Class::*, false> {
    };
    template <typename _Functor> struct _Weak_result_type : _Weak_result_type_memfun<typename remove_cv<_Functor>::type> {
    };
    template <typename _Tp, typename = __void_t<>> struct _Refwrap_base_arg1 {
    };
    template <typename _Tp> struct _Refwrap_base_arg1<_Tp, __void_t<typename _Tp::argument_type>> {
        typedef typename _Tp::argument_type argument_type;
    };
    template <typename _Tp, typename = __void_t<>> struct _Refwrap_base_arg2 {
    };
    template <typename _Tp> struct _Refwrap_base_arg2<_Tp, __void_t<typename _Tp::first_argument_type, typename _Tp::second_argument_type>> {
        typedef typename _Tp::first_argument_type first_argument_type;
        typedef typename _Tp::second_argument_type second_argument_type;
    };
    template <typename _Tp> struct _Reference_wrapper_base : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp> {
    };
    template <typename _Res, typename _T1> struct _Reference_wrapper_base<_Res (_T1)> : unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1> struct _Reference_wrapper_base<_Res (_T1) const> : unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1> struct _Reference_wrapper_base<_Res (_T1) volatile> : unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1> struct _Reference_wrapper_base<_Res (_T1) const volatile> : unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Reference_wrapper_base<_Res (_T1, _T2)> : binary_function<_T1, _T2, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Reference_wrapper_base<_Res (_T1, _T2) const> : binary_function<_T1, _T2, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Reference_wrapper_base<_Res (_T1, _T2) volatile> : binary_function<_T1, _T2, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Reference_wrapper_base<_Res (_T1, _T2) const volatile> : binary_function<_T1, _T2, _Res> {
    };
    template <typename _Res, typename _T1> struct _Reference_wrapper_base<_Res (*)(_T1)> : unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Reference_wrapper_base<_Res (*)(_T1, _T2)> : binary_function<_T1, _T2, _Res> {
    };
    template <typename _Tp, bool = is_member_function_pointer<_Tp>::value> struct _Reference_wrapper_base_memfun : _Reference_wrapper_base<_Tp> {
    };
    template <typename _MemFunPtr> struct _Reference_wrapper_base_memfun<_MemFunPtr, true> : _Mem_fn_traits<_MemFunPtr>::__maybe_type {
        using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };
    template <typename _Tp> class reference_wrapper : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type> {
        _Tp *_M_data;
        static _Tp *_S_fun(_Tp &__r) noexcept {
            return std::__addressof(__r);
        }
        static void _S_fun(_Tp &&) = delete
        template <typename _Up, typename _Up2 = __remove_cvref_t<_Up>> using __not_same = typename enable_if<!is_same<reference_wrapper<_Tp>, _Up2>::value>::type;
    public:
        typedef _Tp type;
        template <typename _Up, typename = __not_same<_Up>, typename = decltype(reference_wrapper<_Tp>::_S_fun(std::declval<_Up>()))> reference_wrapper<_Tp>(_Up &&__uref) noexcept(noexcept(reference_wrapper<_Tp>::_S_fun(std::declval<_Up>()))) : _M_data(reference_wrapper<_Tp>::_S_fun(std::forward<_Up>(__uref))) {
        }
        reference_wrapper<_Tp>(const reference_wrapper<_Tp> &) = default
        reference_wrapper<_Tp> &operator=(const reference_wrapper<_Tp> &) = default
        operator _Tp &() const noexcept {
            return this->get();
        }
        _Tp &get() const noexcept {
            return *this->_M_data;
        }
        template <typename ..._Args> typename result_of<_Tp &(_Args &&...)>::type operator()(_Args &&...__args) const {
            return std::__invoke(this->get(), std::forward<_Args>(__args)...);
        }
    };
    template <typename _Tp> inline reference_wrapper<_Tp> ref(_Tp &__t) noexcept {
        return reference_wrapper<_Tp>(__t);
    }
    template <typename _Tp> inline reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept {
        return reference_wrapper<const _Tp>(__t);
    }
    template <typename _Tp> void ref(const _Tp &&) = delete
    template <typename _Tp> void cref(const _Tp &&) = delete
    template <typename _Tp> inline reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) noexcept {
        return __t;
    }
    template <typename _Tp> inline reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t) noexcept {
        return {__t.get()};
    }
}
namespace std {
    template <class _E> class initializer_list {
    public:
        typedef _E value_type;
        typedef const _E &reference;
        typedef const _E &const_reference;
        typedef std::size_t size_type;
        typedef const _E *iterator;
        typedef const _E *const_iterator;
    private:
        std::initializer_list::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list<_E>(std::initializer_list::const_iterator __a, std::initializer_list::size_type __l) : _M_array(__a), _M_len(__l) {
        }
    public:
        constexpr initializer_list<_E>() noexcept : _M_array(0), _M_len(0) {
        }
        constexpr std::initializer_list::size_type size() const noexcept {
            return this->_M_len;
        }
        constexpr std::initializer_list::const_iterator begin() const noexcept {
            return this->_M_array;
        }
        constexpr std::initializer_list::const_iterator end() const noexcept {
            return this->begin() + this->size();
        }
    };
    template<> class initializer_list<char> {
    public:
        typedef char value_type;
        typedef const char &reference;
        typedef const char &const_reference;
        typedef std::size_t size_type;
        typedef const char *iterator;
        typedef const char *const_iterator;
    private:
        std::initializer_list<char>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char>::const_iterator end() const noexcept;
    };
    template<> class initializer_list<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef const wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef std::size_t size_type;
        typedef const wchar_t *iterator;
        typedef const wchar_t *const_iterator;
    private:
        std::initializer_list<wchar_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<wchar_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator end() const noexcept;
    };
    template<> class initializer_list<char16_t> {
    public:
        typedef char16_t value_type;
        typedef const char16_t &reference;
        typedef const char16_t &const_reference;
        typedef std::size_t size_type;
        typedef const char16_t *iterator;
        typedef const char16_t *const_iterator;
    private:
        std::initializer_list<char16_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char16_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator end() const noexcept;
    };
    template<> class initializer_list<char32_t> {
    public:
        typedef char32_t value_type;
        typedef const char32_t &reference;
        typedef const char32_t &const_reference;
        typedef std::size_t size_type;
        typedef const char32_t *iterator;
        typedef const char32_t *const_iterator;
    private:
        std::initializer_list<char32_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char32_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator end() const noexcept;
    };
    template <class _Tp> constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept {
        return __ils.begin();
    }
    template <class _Tp> constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept {
        return __ils.end();
    }
}
namespace std {
    template <typename _Container> inline auto begin(_Container &__cont) -> decltype(__cont.begin()) [[nodiscard("")]] {
        return __cont.begin();
    }
    template <typename _Container> inline auto begin(const _Container &__cont) -> decltype(__cont.begin()) [[nodiscard("")]] {
        return __cont.begin();
    }
    template <typename _Container> inline auto end(_Container &__cont) -> decltype(__cont.end()) [[nodiscard("")]] {
        return __cont.end();
    }
    template <typename _Container> inline auto end(const _Container &__cont) -> decltype(__cont.end()) [[nodiscard("")]] {
        return __cont.end();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *begin(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] {
        return __arr;
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *end(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] {
        return __arr + _Nm;
    }
    template <typename _Tp> class valarray;
    template <typename _Tp> _Tp *begin(valarray<_Tp> &) noexcept;
    template <typename _Tp> const _Tp *begin(const valarray<_Tp> &) noexcept;
    template <typename _Tp> _Tp *end(valarray<_Tp> &) noexcept;
    template <typename _Tp> const _Tp *end(const valarray<_Tp> &) noexcept;
    template <typename _Container> constexpr auto cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))) -> decltype(std::begin(__cont)) [[nodiscard("")]] {
        return std::begin(__cont);
    }
    template <typename _Container> constexpr auto cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))) -> decltype(std::end(__cont)) [[nodiscard("")]] {
        return std::end(__cont);
    }
    template <typename _Container> inline auto rbegin(_Container &__cont) -> decltype(__cont.rbegin()) [[nodiscard("")]] {
        return __cont.rbegin();
    }
    template <typename _Container> inline auto rbegin(const _Container &__cont) -> decltype(__cont.rbegin()) [[nodiscard("")]] {
        return __cont.rbegin();
    }
    template <typename _Container> inline auto rend(_Container &__cont) -> decltype(__cont.rend()) [[nodiscard("")]] {
        return __cont.rend();
    }
    template <typename _Container> inline auto rend(const _Container &__cont) -> decltype(__cont.rend()) [[nodiscard("")]] {
        return __cont.rend();
    }
    template <typename _Tp, std::size_t _Nm> inline reverse_iterator<_Tp *> rbegin(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] {
        return reverse_iterator<_Tp *>(__arr + _Nm);
    }
    template <typename _Tp, std::size_t _Nm> inline reverse_iterator<_Tp *> rend(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] {
        return reverse_iterator<_Tp *>(__arr);
    }
    template <typename _Tp> inline reverse_iterator<const _Tp *> rbegin(initializer_list<_Tp> __il) noexcept [[nodiscard("")]] {
        return reverse_iterator<const _Tp *>(__il.end());
    }
    template <typename _Tp> inline reverse_iterator<const _Tp *> rend(initializer_list<_Tp> __il) noexcept [[nodiscard("")]] {
        return reverse_iterator<const _Tp *>(__il.begin());
    }
    template <typename _Container> inline auto crbegin(const _Container &__cont) -> decltype(std::rbegin(__cont)) [[nodiscard("")]] {
        return std::rbegin(__cont);
    }
    template <typename _Container> inline auto crend(const _Container &__cont) -> decltype(std::rend(__cont)) [[nodiscard("")]] {
        return std::rend(__cont);
    }
}
namespace std {
    template <typename _Tp, typename ..._Args> inline void _Construct(_Tp *__p, _Args &&...__args) {
        ::new ((void *)__p) _Tp((std::forward<_Args>(__args)...));
    }
    template <typename _T1> inline void _Construct_novalue(_T1 *__p) {
        ::new ((void *)__p) _T1;
    }
    template <typename _ForwardIterator> void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
    template <typename _Tp> inline constexpr void _Destroy(_Tp *__pointer) {
        __pointer->~_Tp();
    }
    template <bool> struct _Destroy_aux {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator __first, _ForwardIterator __last) {
            for (; __first != __last; ++__first)
                std::_Destroy(std::__addressof(*__first));
        }
    };
    template<> struct _Destroy_aux<true> {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator, _ForwardIterator) {
        }
    };
    template <typename _ForwardIterator> inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
    }
    template <bool> struct _Destroy_n_aux {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count) {
            for (; __count > 0; (void)++__first , --__count)
                std::_Destroy(std::__addressof(*__first));
            return __first;
        }
    };
    template<> struct _Destroy_n_aux<true> {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count) {
            std::advance(__first, __count);
            return __first;
        }
    };
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator _Destroy_n(_ForwardIterator __first, _Size __count) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::__destroy_n(__first, __count);
    }
}
namespace std {
    struct __allocator_traits_base {
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other>> {
            using type = typename _Tp::template rebind<_Up>::other;
        };
    protected:
        template <typename _Tp> using __pointer = typename _Tp::pointer;
        template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;
        template <typename _Tp> using __v_pointer = typename _Tp::void_pointer;
        template <typename _Tp> using __cv_pointer = typename _Tp::const_void_pointer;
        template <typename _Tp> using __pocca = typename _Tp::propagate_on_container_copy_assignment;
        template <typename _Tp> using __pocma = typename _Tp::propagate_on_container_move_assignment;
        template <typename _Tp> using __pocs = typename _Tp::propagate_on_container_swap;
        template <typename _Tp> using __equal = typename _Tp::is_always_equal;
    };
    template <typename _Alloc, typename _Up> using __alloc_rebind = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
    template <typename _Alloc> struct allocator_traits : std::__allocator_traits_base {
        typedef _Alloc allocator_type;
        typedef typename _Alloc::value_type value_type;
        using pointer = __detected_or_t<std::allocator_traits::value_type *, std::__allocator_traits_base::__pointer, _Alloc>;
    private:
        template <template <typename> class _Func, typename _Tp, typename = void> struct _Ptr {
            using type = typename pointer_traits<pointer>::template rebind<_Tp>;
        };
        template <template <typename> class _Func, typename _Tp> struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>> {
            using type = _Func<_Alloc>;
        };
        template <typename _A2, typename _PtrT, typename = void> struct _Diff {
            using type = typename pointer_traits<_PtrT>::difference_type;
        };
        template <typename _A2, typename _PtrT> struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>> {
            using type = typename _A2::difference_type;
        };
        template <typename _A2, typename _DiffT, typename = void> struct _Size : make_unsigned<_DiffT> {
        };
        template <typename _A2, typename _DiffT> struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
            using type = typename _A2::size_type;
        };
    public:
        using const_pointer = typename _Ptr<std::__allocator_traits_base::__c_pointer, const value_type>::type;
        using void_pointer = typename _Ptr<std::__allocator_traits_base::__v_pointer, void>::type;
        using const_void_pointer = typename _Ptr<std::__allocator_traits_base::__cv_pointer, const void>::type;
        using difference_type = typename _Diff<_Alloc, pointer>::type;
        using size_type = typename _Size<_Alloc, difference_type>::type;
        using propagate_on_container_copy_assignment = __detected_or_t<std::false_type, std::__allocator_traits_base::__pocca, _Alloc>;
        using propagate_on_container_move_assignment = __detected_or_t<std::false_type, std::__allocator_traits_base::__pocma, _Alloc>;
        using propagate_on_container_swap = __detected_or_t<std::false_type, std::__allocator_traits_base::__pocs, _Alloc>;
        using is_always_equal = __detected_or_t<typename is_empty<_Alloc>::type, std::__allocator_traits_base::__equal, _Alloc>;
        template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
        template <typename _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
    private:
        template <typename _Alloc2> static constexpr auto _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint, int) -> decltype(__a.allocate(__n, __hint)) {
            return __a.allocate(__n, __hint);
        }
        template <typename _Alloc2> static constexpr std::allocator_traits::pointer _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer, ...) {
            return __a.allocate(__n);
        }
        template <typename _Tp, typename ..._Args> struct __construct_helper {
            template <typename _Alloc2, typename = decltype(std::declval<_Alloc2 *>()->construct(std::declval<_Tp *>(), std::declval<_Args>()...))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
            using type = decltype(__test<_Alloc>(0));
        };
        template <typename _Tp, typename ..._Args> using __has_construct = typename __construct_helper<_Tp, _Args...>::type;
        template <typename _Tp, typename ..._Args> static constexpr _Require<__has_construct<_Tp, _Args...>> _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...))) {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp, typename ..._Args> static constexpr _Require<__and_<__not_<__has_construct<_Tp, _Args...>>, is_constructible<_Tp, _Args...>>> _S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value) {
            ::new ((void *)__p) _Tp((std::forward<_Args>(__args)...));
        }
        template <typename _Alloc2, typename _Tp> static constexpr auto _S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))) -> decltype(__a.destroy(__p)) {
            __a.destroy(__p);
        }
        template <typename _Alloc2, typename _Tp> static constexpr void _S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(std::is_nothrow_destructible<_Tp>::value) {
            std::_Destroy(__p);
        }
        template <typename _Alloc2> static constexpr auto _S_max_size(_Alloc2 &__a, int) -> decltype(__a.max_size()) {
            return __a.max_size();
        }
        template <typename _Alloc2> static constexpr std::allocator_traits::size_type _S_max_size(_Alloc2 &, ...) {
            return __gnu_cxx::__numeric_traits<size_type>::__max / sizeof(std::allocator_traits::value_type);
        }
        template <typename _Alloc2> static constexpr auto _S_select(_Alloc2 &__a, int) -> decltype(__a.select_on_container_copy_construction()) {
            return __a.select_on_container_copy_construction();
        }
        template <typename _Alloc2> static constexpr _Alloc2 _S_select(_Alloc2 &__a, ...) {
            return __a;
        }
    public:
        static std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint) {
            return _S_allocate(__a, __n, __hint, 0);
        }
        static void deallocate(_Alloc &__a, std::allocator_traits::pointer __p, std::allocator_traits::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Tp, typename ..._Args> static auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))) -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...)) {
            _S_construct(__a, __p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp> static void destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))) {
            _S_destroy(__a, __p, 0);
        }
        static std::allocator_traits::size_type max_size(const _Alloc &__a) noexcept {
            return _S_max_size(__a, 0);
        }
        static _Alloc select_on_container_copy_construction(const _Alloc &__rhs) {
            return _S_select(__rhs, 0);
        }
    };
    template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<std::allocator<char>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char>>::size_type max_size(const std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused))) noexcept {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char>>::allocator_type &__rhs) {
            return __rhs;
        }
    };
    template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n);
        static std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<std::allocator<wchar_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<wchar_t>>::size_type max_size(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static std::allocator_traits<std::allocator<wchar_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__rhs);
    };
    template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char16_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char16_t>>::size_type max_size(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused))) noexcept {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char16_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__rhs);
    };
    template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char32_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char32_t>>::size_type max_size(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused))) noexcept {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char32_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__rhs);
    };
    template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
        using allocator_type = allocator<_Tp>;
        using value_type = _Tp;
        using pointer = _Tp *;
        using const_pointer = const _Tp *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<allocator<type-parameter-0-0>>::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            return __a.allocate(__n);
        }
        static std::allocator_traits<allocator<type-parameter-0-0>>::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) {
            return __a.allocate(__n, __hint);
        }
        static void deallocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value) {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static void destroy(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {
            __a.destroy(__p);
        }
        static std::allocator_traits<allocator<type-parameter-0-0>>::size_type max_size(const std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused))) noexcept {
            return __a.max_size();
        }
        static std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__rhs) {
            return __rhs;
        }
    };
    template<> struct allocator_traits<allocator<void>> {
        using allocator_type = allocator<void>;
        using value_type = void;
        using pointer = void *;
        using const_pointer = const void *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static void *allocate(std::allocator_traits<std::allocator<void>>::allocator_type &, std::allocator_traits<std::allocator<void>>::size_type, const void * = nullptr) = delete
        static void deallocate(std::allocator_traits<std::allocator<void>>::allocator_type &, void *, std::allocator_traits<std::allocator<void>>::size_type) = delete
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<void>>::allocator_type &, _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value) {
            std::_Construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<void>>::allocator_type &, _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {
            std::_Destroy(__p);
        }
        static std::allocator_traits<std::allocator<void>>::size_type max_size(const std::allocator_traits<std::allocator<void>>::allocator_type &) = delete
        static std::allocator_traits<std::allocator<void>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<void>>::allocator_type &__rhs) {
            return __rhs;
        }
    };
    template <typename _Alloc> inline void __do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, std::true_type) {
        __one = __two;
    }
    template <typename _Alloc> inline void __do_alloc_on_copy(_Alloc &, const _Alloc &, std::false_type) {
    }
    template<> inline void __do_alloc_on_copy<std::allocator<char>>(std::allocator<char> &, const std::allocator<char> &, std::false_type) {
    }
    template <typename _Alloc> inline constexpr void __alloc_on_copy(_Alloc &__one, const _Alloc &__two) {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_copy_assignment __pocca;
        __do_alloc_on_copy(__one, __two, __pocca());
    }
    template<> inline constexpr void __alloc_on_copy<std::allocator<char>>(std::allocator<char> &__one, const std::allocator<char> &__two) {
        typedef allocator_traits<std::allocator<char>> __traits;
        typedef typename __traits::propagate_on_container_copy_assignment __pocca;
        __do_alloc_on_copy(__one, __two, __pocca());
    }
    template <typename _Alloc> constexpr _Alloc __alloc_on_copy(const _Alloc &__a) {
        typedef allocator_traits<_Alloc> __traits;
        return __traits::select_on_container_copy_construction(__a);
    }
    template <typename _Alloc> inline void __do_alloc_on_move(_Alloc &__one, _Alloc &__two, std::true_type) {
        __one = std::move(__two);
    }
    template <typename _Alloc> inline void __do_alloc_on_move(_Alloc &, _Alloc &, std::false_type) {
    }
    template <typename _Alloc> inline constexpr void __alloc_on_move(_Alloc &__one, _Alloc &__two) {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_move_assignment __pocma;
        __do_alloc_on_move(__one, __two, __pocma());
    }
    template <typename _Alloc> inline void __do_alloc_on_swap(_Alloc &__one, _Alloc &__two, std::true_type) {
        using std::swap;
        swap(__one, __two);
    }
    template <typename _Alloc> inline void __do_alloc_on_swap(_Alloc &, _Alloc &, std::false_type) {
    }
    template <typename _Alloc> inline constexpr void __alloc_on_swap(_Alloc &__one, _Alloc &__two) {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_swap __pocs;
        __do_alloc_on_swap(__one, __two, __pocs());
    }
    template <typename _Alloc, typename _Tp, typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>, typename = void> struct __is_alloc_insertable_impl : std::false_type {
    };
    template <typename _Alloc, typename _Tp, typename _ValueT> struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, __void_t<decltype(allocator_traits<_Alloc>::construct(std::declval<_Alloc &>(), std::declval<_ValueT *>(), std::declval<_Tp>()))>> : std::true_type {
    };
    template <typename _Alloc> struct __is_copy_insertable : __is_alloc_insertable_impl<_Alloc, const typename _Alloc::value_type &>::type {
    };
    template <typename _Tp> struct __is_copy_insertable<allocator<_Tp>> : is_copy_constructible<_Tp> {
    };
    template <typename _Alloc> struct __is_move_insertable : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type {
    };
    template <typename _Tp> struct __is_move_insertable<allocator<_Tp>> : is_move_constructible<_Tp> {
    };
    template <typename _Alloc, typename = void> struct __is_allocator : std::false_type {
    };
    template <typename _Alloc> struct __is_allocator<_Alloc, __void_t<typename _Alloc::value_type, decltype(std::declval<_Alloc &>().allocate(std::size_t{}))>> : std::true_type {
    };
    template <typename _Alloc> using _RequireAllocator = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _Alloc> using _RequireNotAllocator = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _ForwardIterator, typename _Allocator> void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc) {
        for (; __first != __last; ++__first)
            allocator_traits<_Allocator>::destroy(__alloc, std::__addressof(*__first));
    }
    template <typename _ForwardIterator, typename _Tp> inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &) {
        _Destroy(__first, __last);
    }
}
namespace __gnu_cxx {
    template <typename _Alloc, typename = typename _Alloc::value_type> struct __alloc_traits : std::allocator_traits<_Alloc> {
        typedef _Alloc allocator_type;
        typedef std::allocator_traits<_Alloc> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...))) {
            _Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...);
        }
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p)))) {
            _Base_type::destroy(__a, std::__to_address(__p));
        }
        static constexpr _Alloc _S_select_on_copy(const _Alloc &__a) {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(_Alloc &__a, _Alloc &__b) {
            std::__alloc_on_swap(__a, __b);
        }
        static constexpr bool _S_propagate_on_copy_assign() {
            return _Base_type::propagate_on_container_copy_assignment::value;
        }
        static constexpr bool _S_propagate_on_move_assign() {
            return _Base_type::propagate_on_container_move_assignment::value;
        }
        static constexpr bool _S_propagate_on_swap() {
            return _Base_type::propagate_on_container_swap::value;
        }
        static constexpr bool _S_always_equal() {
            return _Base_type::is_always_equal::value;
        }
        static constexpr bool _S_nothrow_move() {
            return _S_propagate_on_move_assign() || _S_always_equal();
        }
        template <typename _Tp> struct rebind {
            typedef typename _Base_type::template rebind_alloc<_Tp> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<char>, char> : std::allocator_traits<allocator<char>> {
        typedef std::allocator<char> allocator_type;
        typedef std::allocator_traits<allocator<char>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char> &__a, _Ptr __p);
        static constexpr std::allocator<char> _S_select_on_copy(const std::allocator<char> &__a) {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(std::allocator<char> &__a, std::allocator<char> &__b);
        static constexpr bool _S_propagate_on_copy_assign() {
            return _Base_type::propagate_on_container_copy_assignment::value;
        }
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal() {
            return _Base_type::is_always_equal::value;
        }
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
        template<> struct rebind<char> {
            typedef typename _Base_type::rebind_alloc<char> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<wchar_t>, wchar_t> : std::allocator_traits<allocator<wchar_t>> {
        typedef std::allocator<wchar_t> allocator_type;
        typedef std::allocator_traits<allocator<wchar_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<wchar_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<wchar_t> &__a, _Ptr __p);
        static constexpr std::allocator<wchar_t> _S_select_on_copy(const std::allocator<wchar_t> &__a);
        static constexpr void _S_on_swap(std::allocator<wchar_t> &__a, std::allocator<wchar_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
        template<> struct rebind<wchar_t> {
            typedef typename _Base_type::rebind_alloc<wchar_t> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<char16_t>, char16_t> : std::allocator_traits<allocator<char16_t>> {
        typedef std::allocator<char16_t> allocator_type;
        typedef std::allocator_traits<allocator<char16_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char16_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char16_t> &__a, _Ptr __p);
        static constexpr std::allocator<char16_t> _S_select_on_copy(const std::allocator<char16_t> &__a);
        static constexpr void _S_on_swap(std::allocator<char16_t> &__a, std::allocator<char16_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
        template<> struct rebind<char16_t> {
            typedef typename _Base_type::rebind_alloc<char16_t> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<char32_t>, char32_t> : std::allocator_traits<allocator<char32_t>> {
        typedef std::allocator<char32_t> allocator_type;
        typedef std::allocator_traits<allocator<char32_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char32_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char32_t> &__a, _Ptr __p);
        static constexpr std::allocator<char32_t> _S_select_on_copy(const std::allocator<char32_t> &__a);
        static constexpr void _S_on_swap(std::allocator<char32_t> &__a, std::allocator<char32_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
        template<> struct rebind<char32_t> {
            typedef typename _Base_type::rebind_alloc<char32_t> other;
        };
    };
}
namespace std {
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef _Traits traits_type;
            typedef typename _Traits::char_type value_type;
            typedef std::basic_string::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::basic_string::size_type npos = static_cast<std::basic_string::size_type>(-1);
        protected:
            typedef std::basic_string::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::basic_string::allocator_type {
                _Alloc_hider(std::basic_string::pointer __dat, const _Alloc &__a) : std::basic_string::allocator_type(__a), _M_p(__dat) {
                }
                _Alloc_hider(std::basic_string::pointer __dat, _Alloc &&__a = _Alloc()) : std::basic_string::allocator_type(std::move(__a)), _M_p(__dat) {
                }
                std::basic_string::pointer _M_p;
            };
            std::basic_string::_Alloc_hider _M_dataplus;
            std::basic_string::size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(_CharT)
            };
            union {
                _CharT _M_local_buf[_S_local_capacity + 1];
                std::basic_string::size_type _M_allocated_capacity;
            };
            void _M_data(std::basic_string::pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::basic_string::size_type __length) {
                this->_M_string_length = __length;
            }
            std::basic_string::pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            std::basic_string::pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::basic_string::const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::basic_string::size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::basic_string::size_type __n) {
                this->_M_length(__n);
                traits_type::assign(_M_data()[__n], _CharT());
            }
            bool _M_is_local() const {
                return _M_data() == _M_local_data();
            }
            std::basic_string::pointer _M_create(std::basic_string::size_type &, std::basic_string::size_type);
            void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::basic_string::size_type __size) throw() {
                _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(std::basic_string::size_type __req, _CharT __c);
            std::basic_string::allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            const std::basic_string::allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr std::basic_string::pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                return _M_local_data();
            }
        private:
            std::basic_string::size_type _M_check(std::basic_string::size_type __pos, const char *__s) const {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            void _M_check_length(std::basic_string::size_type __n1, std::basic_string::size_type __n2, const char *__s) const {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            std::basic_string::size_type _M_limit(std::basic_string::size_type __pos, std::basic_string::size_type __off) const noexcept {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const _CharT *__s) const noexcept {
                return (less<const _CharT *>()(__s, _M_data()) || less<const _CharT *>()(_M_data() + this->size(), __s));
            }
            static void _S_copy(_CharT *__d, const _CharT *__s, std::basic_string::size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(_CharT *__d, const _CharT *__s, std::basic_string::size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static void _S_assign(_CharT *__d, std::basic_string::size_type __n, _CharT __c) {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template <class _Iterator> static void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2) {
                for (; __k1 != __k2; ++__k1 , (void)++__p)
                    traits_type::assign(*__p, *__k1);
            }
            static void _S_copy_chars(_CharT *__p, std::basic_string::iterator __k1, std::basic_string::iterator __k2) noexcept {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT *__p, std::basic_string::const_iterator __k1, std::basic_string::const_iterator __k2) noexcept {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::basic_string::size_type __n1, std::basic_string::size_type __n2) noexcept {
                const std::basic_string::difference_type __d = std::basic_string::difference_type(__n1 - __n2);
                if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                    return __gnu_cxx::__numeric_traits<int>::__max;
                else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                    return __gnu_cxx::__numeric_traits<int>::__min;
                else
                    return int(__d);
            }
            void _M_assign(const basic_string<_CharT, _Traits, _Alloc> &);
            void _M_mutate(std::basic_string::size_type __pos, std::basic_string::size_type __len1, const _CharT *__s, std::basic_string::size_type __len2);
            void _M_erase(std::basic_string::size_type __pos, std::basic_string::size_type __n);
        public:
            basic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::value) : _M_dataplus(_M_local_data()) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            explicit basic_string<_CharT, _Traits, _Alloc>(const _Alloc &__a) noexcept : _M_dataplus(_M_local_data(), __a) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str) : _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator())) {
                _M_construct(__str._M_data(), __str._M_data() + __str.length(), std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, npos), std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos, std::basic_string::size_type __n) : _M_dataplus(_M_local_data()) {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n), std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos, std::basic_string::size_type __n, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a) {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n), std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, std::basic_string::size_type __n, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                _M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                if (__s == 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                const _CharT *__end = __s + traits_type::length(__s);
                _M_construct(__s, __end, std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(std::basic_string::size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                _M_construct(__n, __c);
            }
            basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    _M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string<_CharT, _Traits, _Alloc>(initializer_list<_CharT> __l, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                _M_construct(__l.begin(), __l.end(), std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a) {
                _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
            }
            basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()) : _M_dataplus(_M_local_data(), __a) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                    this->_M_length(__str.length());
                    __str._M_set_length(0);
                } else if (_Alloc_traits::_S_always_equal() || __str.get_allocator() == __a) {
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    __str._M_data(__str._M_local_buf);
                    __str._M_set_length(0);
                } else
                    _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
            }
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc>(_InputIterator __beg, _InputIterator __end, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                _M_construct(__beg, __end, std::__iterator_category(__beg));
            }
            ~basic_string<_CharT, _Traits, _Alloc>() {
                this->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->assign(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(const _CharT *__s) {
                return this->assign(__s);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(_CharT __c) {
                this->assign(1, __c);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {
                if (!this->_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign() && !_Alloc_traits::_S_always_equal() && _M_get_allocator() != __str._M_get_allocator()) {
                    this->_M_destroy(this->_M_allocated_capacity);
                    _M_data(_M_local_data());
                    this->_M_set_length(0);
                }
                std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
                if (__str._M_is_local()) {
                    if (__builtin_expect(std::__addressof(__str) != this, true)) {
                        if (__str.size())
                            this->_S_copy(_M_data(), __str._M_data(), __str.size());
                        this->_M_set_length(__str.size());
                    }
                } else if (_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal() || _M_get_allocator() == __str._M_get_allocator()) {
                    std::basic_string::pointer __data = nullptr;
                    std::basic_string::size_type __capacity;
                    if (!this->_M_is_local()) {
                        if (_Alloc_traits::_S_always_equal()) {
                            __data = _M_data();
                            __capacity = this->_M_allocated_capacity;
                        } else
                            this->_M_destroy(this->_M_allocated_capacity);
                    }
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    if (__data) {
                        __str._M_data(__data);
                        __str._M_capacity(__capacity);
                    } else
                        __str._M_data(__str._M_local_buf);
                } else
                    assign(__str);
                __str.clear();
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(initializer_list<_CharT> __l) {
                this->assign(__l.begin(), __l.size());
                return *this;
            }
            std::basic_string::iterator begin() noexcept {
                return std::basic_string::iterator(_M_data());
            }
            std::basic_string::const_iterator begin() const noexcept {
                return std::basic_string::const_iterator(_M_data());
            }
            std::basic_string::iterator end() noexcept {
                return std::basic_string::iterator(_M_data() + this->size());
            }
            std::basic_string::const_iterator end() const noexcept {
                return std::basic_string::const_iterator(_M_data() + this->size());
            }
            std::basic_string::reverse_iterator rbegin() noexcept {
                return std::basic_string::reverse_iterator(this->end());
            }
            std::basic_string::const_reverse_iterator rbegin() const noexcept {
                return std::basic_string::const_reverse_iterator(this->end());
            }
            std::basic_string::reverse_iterator rend() noexcept {
                return std::basic_string::reverse_iterator(this->begin());
            }
            std::basic_string::const_reverse_iterator rend() const noexcept {
                return std::basic_string::const_reverse_iterator(this->begin());
            }
            std::basic_string::const_iterator cbegin() const noexcept {
                return std::basic_string::const_iterator(this->_M_data());
            }
            std::basic_string::const_iterator cend() const noexcept {
                return std::basic_string::const_iterator(this->_M_data() + this->size());
            }
            std::basic_string::const_reverse_iterator crbegin() const noexcept {
                return std::basic_string::const_reverse_iterator(this->end());
            }
            std::basic_string::const_reverse_iterator crend() const noexcept {
                return std::basic_string::const_reverse_iterator(this->begin());
            }
        public:
            std::basic_string::size_type size() const noexcept {
                return this->_M_string_length;
            }
            std::basic_string::size_type length() const noexcept {
                return this->_M_string_length;
            }
            std::basic_string::size_type max_size() const noexcept {
                return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
            }
            void resize(std::basic_string::size_type __n, _CharT __c);
            void resize(std::basic_string::size_type __n) {
                this->resize(__n, _CharT());
            }
            void shrink_to_fit() noexcept {
                reserve();
            }
            std::basic_string::size_type capacity() const noexcept {
                return this->_M_is_local() ? std::basic_string::size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            void reserve(std::basic_string::size_type __res_arg);
            void reserve();
            void clear() noexcept {
                this->_M_set_length(0);
            }
            bool empty() const noexcept {
                return this->size() == 0;
            }
            std::basic_string::const_reference operator[](std::basic_string::size_type __pos) const noexcept {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                return _M_data()[__pos];
            }
            std::basic_string::reference operator[](std::basic_string::size_type __pos) {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                ;
                return _M_data()[__pos];
            }
            std::basic_string::const_reference at(std::basic_string::size_type __n) const {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            std::basic_string::reference at(std::basic_string::size_type __n) {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            std::basic_string::reference front() noexcept {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](0);
            }
            std::basic_string::const_reference front() const noexcept {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](0);
            }
            std::basic_string::reference back() noexcept {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](this->size() - 1);
            }
            std::basic_string::const_reference back() const noexcept {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](this->size() - 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->append(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(const _CharT *__s) {
                return this->append(__s);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(_CharT __c) {
                this->push_back(__c);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(initializer_list<_CharT> __l) {
                return this->append(__l.begin(), __l.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->append(__str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos, std::basic_string::size_type __n = npos) {
                return this->append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, std::basic_string::size_type __n) {
                ;
                this->_M_check_length(std::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s) {
                ;
                const std::basic_string::size_type __n = traits_type::length(__s);
                this->_M_check_length(std::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(std::basic_string::size_type __n, _CharT __c) {
                return this->_M_replace_aux(this->size(), std::basic_string::size_type(0), __n, __c);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(initializer_list<_CharT> __l) {
                return this->append(__l.begin(), __l.size());
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last) {
                return this->replace(end(), end(), __first, __last);
            }
            void push_back(_CharT __c) {
                const std::basic_string::size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, std::basic_string::size_type(0), 0, std::basic_string::size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                if (_Alloc_traits::_S_propagate_on_copy_assign()) {
                    if (!_Alloc_traits::_S_always_equal() && !this->_M_is_local() && _M_get_allocator() != __str._M_get_allocator()) {
                        if (__str.size() <= _S_local_capacity) {
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(this->_M_use_local_data());
                            this->_M_set_length(0);
                        } else {
                            const auto __len = __str.size();
                            auto __alloc = __str._M_get_allocator();
                            auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(__ptr);
                            this->_M_capacity(__len);
                            this->_M_set_length(__len);
                        }
                    }
                    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
                }
                this->_M_assign(__str);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {
                return *this = std::move(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos, std::basic_string::size_type __n = npos) {
                return this->_M_replace(std::basic_string::size_type(0), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, std::basic_string::size_type __n) {
                ;
                return this->_M_replace(std::basic_string::size_type(0), this->size(), __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s) {
                ;
                return this->_M_replace(std::basic_string::size_type(0), this->size(), __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(std::basic_string::size_type __n, _CharT __c) {
                return this->_M_replace_aux(std::basic_string::size_type(0), this->size(), __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last) {
                return this->replace(begin(), end(), __first, __last);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(initializer_list<_CharT> __l) {
                return this->assign(__l.begin(), __l.size());
            }
            std::basic_string::iterator insert(std::basic_string::const_iterator __p, std::basic_string::size_type __n, _CharT __c) {
                ;
                const std::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __n, __c);
                return std::basic_string::iterator(this->_M_data() + __pos);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string::iterator insert(std::basic_string::const_iterator __p, _InputIterator __beg, _InputIterator __end) {
                ;
                const std::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __beg, __end);
                return std::basic_string::iterator(this->_M_data() + __pos);
            }
            std::basic_string::iterator insert(std::basic_string::const_iterator __p, initializer_list<_CharT> __l) {
                return this->insert(__p, __l.begin(), __l.end());
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->replace(__pos1, std::basic_string::size_type(0), __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos2, std::basic_string::size_type __n = npos) {
                return this->replace(__pos1, std::basic_string::size_type(0), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::basic_string::size_type __pos, const _CharT *__s, std::basic_string::size_type __n) {
                return this->replace(__pos, std::basic_string::size_type(0), __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::basic_string::size_type __pos, const _CharT *__s) {
                ;
                return this->replace(__pos, std::basic_string::size_type(0), __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::basic_string::size_type __pos, std::basic_string::size_type __n, _CharT __c) {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::insert"), std::basic_string::size_type(0), __n, __c);
            }
            std::basic_string::iterator insert(std::basic_string::__const_iterator __p, _CharT __c) {
                ;
                const std::basic_string::size_type __pos = __p - begin();
                this->_M_replace_aux(__pos, std::basic_string::size_type(0), std::basic_string::size_type(1), __c);
                return std::basic_string::iterator(_M_data() + __pos);
            }
            basic_string<_CharT, _Traits, _Alloc> &erase(std::basic_string::size_type __pos = 0, std::basic_string::size_type __n = npos) {
                this->_M_check(__pos, "basic_string::erase");
                if (__n == npos)
                    this->_M_set_length(__pos);
                else if (__n != 0)
                    this->_M_erase(__pos, this->_M_limit(__pos, __n));
                return *this;
            }
            std::basic_string::iterator erase(std::basic_string::__const_iterator __position) {
                ;
                const std::basic_string::size_type __pos = __position - begin();
                this->_M_erase(__pos, std::basic_string::size_type(1));
                return std::basic_string::iterator(_M_data() + __pos);
            }
            std::basic_string::iterator erase(std::basic_string::__const_iterator __first, std::basic_string::__const_iterator __last) {
                ;
                const std::basic_string::size_type __pos = __first - begin();
                if (__last == end())
                    this->_M_set_length(__pos);
                else
                    this->_M_erase(__pos, __last - __first);
                return std::basic_string::iterator(this->_M_data() + __pos);
            }
            void pop_back() noexcept {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                this->_M_erase(this->size() - 1, 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::size_type __pos, std::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->replace(__pos, __n, __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::size_type __pos1, std::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos2, std::basic_string::size_type __n2 = npos) {
                return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::size_type __pos, std::basic_string::size_type __n1, const _CharT *__s, std::basic_string::size_type __n2) {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::size_type __pos, std::basic_string::size_type __n1, const _CharT *__s) {
                ;
                return this->replace(__pos, __n1, __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::size_type __pos, std::basic_string::size_type __n1, std::basic_string::size_type __n2, _CharT __c) {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __n2, __c);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->replace(__i1, __i2, __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, const _CharT *__s, std::basic_string::size_type __n) {
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, const _CharT *__s) {
                ;
                return this->replace(__i1, __i2, __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, std::basic_string::size_type __n, _CharT __c) {
                ;
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::const_iterator __i1, std::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2) {
                ;
                ;
                return this->_M_replace_dispatch(__i1, __i2, __k1, __k2, std::__false_type());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, _CharT *__k1, _CharT *__k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, const _CharT *__k1, const _CharT *__k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, std::basic_string::iterator __k1, std::basic_string::iterator __k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::__const_iterator __i1, std::basic_string::__const_iterator __i2, std::basic_string::const_iterator __k1, std::basic_string::const_iterator __k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::basic_string::const_iterator __i1, std::basic_string::const_iterator __i2, initializer_list<_CharT> __l) {
                return this->replace(__i1, __i2, __l.begin(), __l.size());
            }
        private:
            template <class _Integer> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::basic_string::const_iterator __i1, std::basic_string::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type) {
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
            }
            template <class _InputIterator> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::basic_string::const_iterator __i1, std::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(std::basic_string::size_type __pos1, std::basic_string::size_type __n1, std::basic_string::size_type __n2, _CharT __c);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace(std::basic_string::size_type __pos, std::basic_string::size_type __len1, const _CharT *__s, const std::basic_string::size_type __len2);
            basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, std::basic_string::size_type __n);
        public:
            std::basic_string::size_type copy(_CharT *__s, std::basic_string::size_type __n, std::basic_string::size_type __pos = 0) const;
            void swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept;
            const _CharT *c_str() const noexcept {
                return _M_data();
            }
            const _CharT *data() const noexcept {
                return _M_data();
            }
            std::basic_string::allocator_type get_allocator() const noexcept {
                return _M_get_allocator();
            }
            std::basic_string::size_type find(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept;
            std::basic_string::size_type find(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos = 0) const noexcept {
                return this->find(__str.data(), __pos, __str.size());
            }
            std::basic_string::size_type find(const _CharT *__s, std::basic_string::size_type __pos = 0) const noexcept {
                ;
                return this->find(__s, __pos, traits_type::length(__s));
            }
            std::basic_string::size_type find(_CharT __c, std::basic_string::size_type __pos = 0) const noexcept;
            std::basic_string::size_type rfind(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos = npos) const noexcept {
                return this->rfind(__str.data(), __pos, __str.size());
            }
            std::basic_string::size_type rfind(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept;
            std::basic_string::size_type rfind(const _CharT *__s, std::basic_string::size_type __pos = npos) const {
                ;
                return this->rfind(__s, __pos, traits_type::length(__s));
            }
            std::basic_string::size_type rfind(_CharT __c, std::basic_string::size_type __pos = npos) const noexcept;
            std::basic_string::size_type find_first_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos = 0) const noexcept {
                return this->find_first_of(__str.data(), __pos, __str.size());
            }
            std::basic_string::size_type find_first_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept;
            std::basic_string::size_type find_first_of(const _CharT *__s, std::basic_string::size_type __pos = 0) const noexcept {
                ;
                return this->find_first_of(__s, __pos, traits_type::length(__s));
            }
            std::basic_string::size_type find_first_of(_CharT __c, std::basic_string::size_type __pos = 0) const noexcept {
                return this->find(__c, __pos);
            }
            std::basic_string::size_type find_last_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos = npos) const noexcept {
                return this->find_last_of(__str.data(), __pos, __str.size());
            }
            std::basic_string::size_type find_last_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept;
            std::basic_string::size_type find_last_of(const _CharT *__s, std::basic_string::size_type __pos = npos) const noexcept {
                ;
                return this->find_last_of(__s, __pos, traits_type::length(__s));
            }
            std::basic_string::size_type find_last_of(_CharT __c, std::basic_string::size_type __pos = npos) const noexcept {
                return this->rfind(__c, __pos);
            }
            std::basic_string::size_type find_first_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos = 0) const noexcept {
                return this->find_first_not_of(__str.data(), __pos, __str.size());
            }
            std::basic_string::size_type find_first_not_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept;
            std::basic_string::size_type find_first_not_of(const _CharT *__s, std::basic_string::size_type __pos = 0) const noexcept {
                ;
                return this->find_first_not_of(__s, __pos, traits_type::length(__s));
            }
            std::basic_string::size_type find_first_not_of(_CharT __c, std::basic_string::size_type __pos = 0) const noexcept;
            std::basic_string::size_type find_last_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos = npos) const noexcept {
                return this->find_last_not_of(__str.data(), __pos, __str.size());
            }
            std::basic_string::size_type find_last_not_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept;
            std::basic_string::size_type find_last_not_of(const _CharT *__s, std::basic_string::size_type __pos = npos) const noexcept {
                ;
                return this->find_last_not_of(__s, __pos, traits_type::length(__s));
            }
            std::basic_string::size_type find_last_not_of(_CharT __c, std::basic_string::size_type __pos = npos) const noexcept;
            basic_string<_CharT, _Traits, _Alloc> substr(std::basic_string::size_type __pos = 0, std::basic_string::size_type __n = npos) const {
                return basic_string<_CharT, _Traits, _Alloc>(*this, this->_M_check(__pos, "basic_string::substr"), __n);
            }
            int compare(const basic_string<_CharT, _Traits, _Alloc> &__str) const {
                const std::basic_string::size_type __size = this->size();
                const std::basic_string::size_type __osize = __str.size();
                const std::basic_string::size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            int compare(std::basic_string::size_type __pos, std::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const;
            int compare(std::basic_string::size_type __pos1, std::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos2, std::basic_string::size_type __n2 = npos) const;
            int compare(const _CharT *__s) const noexcept;
            int compare(std::basic_string::size_type __pos, std::basic_string::size_type __n1, const _CharT *__s) const;
            int compare(std::basic_string::size_type __pos, std::basic_string::size_type __n1, const _CharT *__s, std::basic_string::size_type __n2) const;
            friend template <typename, typename, typename> class basic_stringbuf;
        };
        template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::basic_string<char16_t>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::basic_string<char16_t>::size_type npos = static_cast<std::basic_string<char16_t>::size_type>(-1);
        protected:
            typedef std::basic_string<char16_t>::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::basic_string<char16_t>::allocator_type {
                std::basic_string<char16_t>::pointer _M_p;
            };
            std::basic_string<char16_t>::_Alloc_hider _M_dataplus;
            std::basic_string<char16_t>::size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::basic_string<char16_t>::size_type _M_allocated_capacity;
            };
            void _M_data(std::basic_string<char16_t>::pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::basic_string<char16_t>::size_type __length) {
                this->_M_string_length = __length;
            }
            std::basic_string<char16_t>::pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            std::basic_string<char16_t>::pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::basic_string<char16_t>::const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::basic_string<char16_t>::size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::basic_string<char16_t>::size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            bool _M_is_local() const {
                return this->_M_data() == this->_M_local_data();
            }
            std::basic_string<char16_t>::pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_create(std::basic_string<char16_t>::size_type &__capacity, std::basic_string<char16_t>::size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::basic_string<char16_t>::size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag) {
                std::basic_string<char16_t>::size_type __dnew = static_cast<std::basic_string<char16_t>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::basic_string<char16_t>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::basic_string<char16_t>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char16_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::basic_string<char16_t>::size_type __req, char16_t __c);
            std::basic_string<char16_t>::allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            const std::basic_string<char16_t>::allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr std::basic_string<char16_t>::pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                return this->_M_local_data();
            }
        private:
            std::basic_string<char16_t>::size_type _M_check(std::basic_string<char16_t>::size_type __pos, const char *__s) const;
            void _M_check_length(std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2, const char *__s) const;
            std::basic_string<char16_t>::size_type _M_limit(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static void _S_copy(char16_t *__d, const char16_t *__s, std::basic_string<char16_t>::size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char16_t *__d, const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            static void _S_assign(char16_t *__d, std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _Iterator> static void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static void _S_copy_chars(char16_t *__p, std::basic_string<char16_t>::iterator __k1, std::basic_string<char16_t>::iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, std::basic_string<char16_t>::const_iterator __k1, std::basic_string<char16_t>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2) noexcept;
            void _M_assign(const std::basic_string<char16_t> &);
            void _M_mutate(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __len1, const char16_t *__s, std::basic_string<char16_t>::size_type __len2);
            void _M_erase(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            basic_string(const std::basic_string<char16_t> &__str);
            basic_string(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, const std::allocator<char16_t> &__a);
            basic_string(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            basic_string(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, const std::allocator<char16_t> &__a);
            basic_string(const char16_t *__s, std::basic_string<char16_t>::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            basic_string(std::basic_string<char16_t>::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            basic_string(std::basic_string<char16_t> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            basic_string(const std::basic_string<char16_t> &__str, const std::allocator<char16_t> &__a);
            basic_string(std::basic_string<char16_t> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            ~basic_string<char16_t>() noexcept {
                this->_M_dispose();
            }
            std::basic_string<char16_t> &operator=(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &operator=(const char16_t *__s);
            std::basic_string<char16_t> &operator=(char16_t __c);
            std::basic_string<char16_t> &operator=(std::basic_string<char16_t> &&__str);
            std::basic_string<char16_t> &operator=(initializer_list<char16_t> __l);
            std::basic_string<char16_t>::iterator begin() noexcept;
            std::basic_string<char16_t>::const_iterator begin() const noexcept;
            std::basic_string<char16_t>::iterator end() noexcept;
            std::basic_string<char16_t>::const_iterator end() const noexcept;
            std::basic_string<char16_t>::reverse_iterator rbegin() noexcept;
            std::basic_string<char16_t>::const_reverse_iterator rbegin() const noexcept;
            std::basic_string<char16_t>::reverse_iterator rend() noexcept;
            std::basic_string<char16_t>::const_reverse_iterator rend() const noexcept;
            std::basic_string<char16_t>::const_iterator cbegin() const noexcept;
            std::basic_string<char16_t>::const_iterator cend() const noexcept;
            std::basic_string<char16_t>::const_reverse_iterator crbegin() const noexcept;
            std::basic_string<char16_t>::const_reverse_iterator crend() const noexcept;
        public:
            std::basic_string<char16_t>::size_type size() const noexcept;
            std::basic_string<char16_t>::size_type length() const noexcept {
                return this->_M_string_length;
            }
            std::basic_string<char16_t>::size_type max_size() const noexcept {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::basic_string<char16_t>::size_type __n, char16_t __c);
            void resize(std::basic_string<char16_t>::size_type __n);
            void shrink_to_fit() noexcept;
            std::basic_string<char16_t>::size_type capacity() const noexcept;
            void reserve(std::basic_string<char16_t>::size_type __res_arg);
            void reserve();
            void clear() noexcept;
            bool empty() const noexcept;
            std::basic_string<char16_t>::const_reference operator[](std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::reference operator[](std::basic_string<char16_t>::size_type __pos);
            std::basic_string<char16_t>::const_reference at(std::basic_string<char16_t>::size_type __n) const;
            std::basic_string<char16_t>::reference at(std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t>::reference front() noexcept;
            std::basic_string<char16_t>::const_reference front() const noexcept;
            std::basic_string<char16_t>::reference back() noexcept;
            std::basic_string<char16_t>::const_reference back() const noexcept;
            std::basic_string<char16_t> &operator+=(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &operator+=(const char16_t *__s);
            std::basic_string<char16_t> &operator+=(char16_t __c);
            std::basic_string<char16_t> &operator+=(initializer_list<char16_t> __l);
            std::basic_string<char16_t> &append(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &append(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &append(const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &append(const char16_t *__s);
            std::basic_string<char16_t> &append(std::basic_string<char16_t>::size_type __n, char16_t __c);
            std::basic_string<char16_t> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t> &append(_InputIterator __first, _InputIterator __last);
            void push_back(char16_t __c);
            std::basic_string<char16_t> &assign(const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &assign(std::basic_string<char16_t> &&__str);
            std::basic_string<char16_t> &assign(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &assign(const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &assign(const char16_t *__s);
            std::basic_string<char16_t> &assign(std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t> &assign(_InputIterator __first, _InputIterator __last);
            std::basic_string<char16_t> &assign(initializer_list<char16_t> __l);
            std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::const_iterator __p, std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::const_iterator __p, initializer_list<char16_t> __l);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos1, const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos1, const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos2, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos, const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos, const char16_t *__s);
            std::basic_string<char16_t> &insert(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, char16_t __c);
            std::basic_string<char16_t>::iterator insert(std::basic_string<char16_t>::__const_iterator __p, char16_t __c);
            std::basic_string<char16_t> &erase(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t>::iterator erase(std::basic_string<char16_t>::__const_iterator __position);
            std::basic_string<char16_t>::iterator erase(std::basic_string<char16_t>::__const_iterator __first, std::basic_string<char16_t>::__const_iterator __last);
            void pop_back() noexcept;
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos1, std::basic_string<char16_t>::size_type __n1, const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos2, std::basic_string<char16_t>::size_type __n2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s, std::basic_string<char16_t>::size_type __n2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2, char16_t __c);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const std::basic_string<char16_t> &__str);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const char16_t *__s, std::basic_string<char16_t>::size_type __n);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const char16_t *__s);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, std::basic_string<char16_t>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char16_t> &replace(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, std::basic_string<char16_t>::iterator __k1, std::basic_string<char16_t>::iterator __k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::__const_iterator __i1, std::basic_string<char16_t>::__const_iterator __i2, std::basic_string<char16_t>::const_iterator __k1, std::basic_string<char16_t>::const_iterator __k2);
            std::basic_string<char16_t> &replace(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, initializer_list<char16_t> __l);
        private:
            template <class _Integer> std::basic_string<char16_t> &_M_replace_dispatch(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::basic_string<char16_t> &_M_replace_dispatch(std::basic_string<char16_t>::const_iterator __i1, std::basic_string<char16_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::basic_string<char16_t> &_M_replace_aux(std::basic_string<char16_t>::size_type __pos1, std::basic_string<char16_t>::size_type __n1, std::basic_string<char16_t>::size_type __n2, char16_t __c);
            std::basic_string<char16_t> &_M_replace(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __len1, const char16_t *__s, const std::basic_string<char16_t>::size_type __len2);
            std::basic_string<char16_t> &_M_append(const char16_t *__s, std::basic_string<char16_t>::size_type __n);
        public:
            std::basic_string<char16_t>::size_type copy(char16_t *__s, std::basic_string<char16_t>::size_type __n, std::basic_string<char16_t>::size_type __pos) const;
            void swap(std::basic_string<char16_t> &__s) noexcept;
            const char16_t *c_str() const noexcept;
            const char16_t *data() const noexcept {
                return this->_M_data();
            }
            std::basic_string<char16_t>::allocator_type get_allocator() const noexcept;
            std::basic_string<char16_t>::size_type find(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type rfind(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type rfind(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type rfind(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const;
            std::basic_string<char16_t>::size_type rfind(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_first_not_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(const char16_t *__s, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t>::size_type find_last_not_of(char16_t __c, std::basic_string<char16_t>::size_type __pos) const noexcept;
            std::basic_string<char16_t> substr(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n) const;
            int compare(const std::basic_string<char16_t> &__str) const;
            int compare(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n, const std::basic_string<char16_t> &__str) const;
            int compare(std::basic_string<char16_t>::size_type __pos1, std::basic_string<char16_t>::size_type __n1, const std::basic_string<char16_t> &__str, std::basic_string<char16_t>::size_type __pos2, std::basic_string<char16_t>::size_type __n2) const;
            int compare(const char16_t *__s) const noexcept;
            int compare(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s) const;
            int compare(std::basic_string<char16_t>::size_type __pos, std::basic_string<char16_t>::size_type __n1, const char16_t *__s, std::basic_string<char16_t>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
        template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::basic_string<char32_t>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::basic_string<char32_t>::size_type npos = static_cast<std::basic_string<char32_t>::size_type>(-1);
        protected:
            typedef std::basic_string<char32_t>::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::basic_string<char32_t>::allocator_type {
                std::basic_string<char32_t>::pointer _M_p;
            };
            std::basic_string<char32_t>::_Alloc_hider _M_dataplus;
            std::basic_string<char32_t>::size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::basic_string<char32_t>::size_type _M_allocated_capacity;
            };
            void _M_data(std::basic_string<char32_t>::pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::basic_string<char32_t>::size_type __length) {
                this->_M_string_length = __length;
            }
            std::basic_string<char32_t>::pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            std::basic_string<char32_t>::pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::basic_string<char32_t>::const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::basic_string<char32_t>::size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::basic_string<char32_t>::size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            bool _M_is_local() const {
                return this->_M_data() == this->_M_local_data();
            }
            std::basic_string<char32_t>::pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_create(std::basic_string<char32_t>::size_type &__capacity, std::basic_string<char32_t>::size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::basic_string<char32_t>::size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag) {
                std::basic_string<char32_t>::size_type __dnew = static_cast<std::basic_string<char32_t>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::basic_string<char32_t>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::basic_string<char32_t>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char32_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::basic_string<char32_t>::size_type __req, char32_t __c);
            std::basic_string<char32_t>::allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            const std::basic_string<char32_t>::allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr std::basic_string<char32_t>::pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                return this->_M_local_data();
            }
        private:
            std::basic_string<char32_t>::size_type _M_check(std::basic_string<char32_t>::size_type __pos, const char *__s) const;
            void _M_check_length(std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2, const char *__s) const;
            std::basic_string<char32_t>::size_type _M_limit(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static void _S_copy(char32_t *__d, const char32_t *__s, std::basic_string<char32_t>::size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char32_t *__d, const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            static void _S_assign(char32_t *__d, std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _Iterator> static void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static void _S_copy_chars(char32_t *__p, std::basic_string<char32_t>::iterator __k1, std::basic_string<char32_t>::iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, std::basic_string<char32_t>::const_iterator __k1, std::basic_string<char32_t>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2) noexcept;
            void _M_assign(const std::basic_string<char32_t> &);
            void _M_mutate(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __len1, const char32_t *__s, std::basic_string<char32_t>::size_type __len2);
            void _M_erase(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            basic_string(const std::basic_string<char32_t> &__str);
            basic_string(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, const std::allocator<char32_t> &__a);
            basic_string(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            basic_string(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, const std::allocator<char32_t> &__a);
            basic_string(const char32_t *__s, std::basic_string<char32_t>::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            basic_string(std::basic_string<char32_t>::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            basic_string(std::basic_string<char32_t> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            basic_string(const std::basic_string<char32_t> &__str, const std::allocator<char32_t> &__a);
            basic_string(std::basic_string<char32_t> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            ~basic_string<char32_t>() noexcept {
                this->_M_dispose();
            }
            std::basic_string<char32_t> &operator=(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &operator=(const char32_t *__s);
            std::basic_string<char32_t> &operator=(char32_t __c);
            std::basic_string<char32_t> &operator=(std::basic_string<char32_t> &&__str);
            std::basic_string<char32_t> &operator=(initializer_list<char32_t> __l);
            std::basic_string<char32_t>::iterator begin() noexcept;
            std::basic_string<char32_t>::const_iterator begin() const noexcept;
            std::basic_string<char32_t>::iterator end() noexcept;
            std::basic_string<char32_t>::const_iterator end() const noexcept;
            std::basic_string<char32_t>::reverse_iterator rbegin() noexcept;
            std::basic_string<char32_t>::const_reverse_iterator rbegin() const noexcept;
            std::basic_string<char32_t>::reverse_iterator rend() noexcept;
            std::basic_string<char32_t>::const_reverse_iterator rend() const noexcept;
            std::basic_string<char32_t>::const_iterator cbegin() const noexcept;
            std::basic_string<char32_t>::const_iterator cend() const noexcept;
            std::basic_string<char32_t>::const_reverse_iterator crbegin() const noexcept;
            std::basic_string<char32_t>::const_reverse_iterator crend() const noexcept;
        public:
            std::basic_string<char32_t>::size_type size() const noexcept;
            std::basic_string<char32_t>::size_type length() const noexcept {
                return this->_M_string_length;
            }
            std::basic_string<char32_t>::size_type max_size() const noexcept {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::basic_string<char32_t>::size_type __n, char32_t __c);
            void resize(std::basic_string<char32_t>::size_type __n);
            void shrink_to_fit() noexcept;
            std::basic_string<char32_t>::size_type capacity() const noexcept;
            void reserve(std::basic_string<char32_t>::size_type __res_arg);
            void reserve();
            void clear() noexcept;
            bool empty() const noexcept;
            std::basic_string<char32_t>::const_reference operator[](std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::reference operator[](std::basic_string<char32_t>::size_type __pos);
            std::basic_string<char32_t>::const_reference at(std::basic_string<char32_t>::size_type __n) const;
            std::basic_string<char32_t>::reference at(std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t>::reference front() noexcept;
            std::basic_string<char32_t>::const_reference front() const noexcept;
            std::basic_string<char32_t>::reference back() noexcept;
            std::basic_string<char32_t>::const_reference back() const noexcept;
            std::basic_string<char32_t> &operator+=(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &operator+=(const char32_t *__s);
            std::basic_string<char32_t> &operator+=(char32_t __c);
            std::basic_string<char32_t> &operator+=(initializer_list<char32_t> __l);
            std::basic_string<char32_t> &append(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &append(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &append(const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &append(const char32_t *__s);
            std::basic_string<char32_t> &append(std::basic_string<char32_t>::size_type __n, char32_t __c);
            std::basic_string<char32_t> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t> &append(_InputIterator __first, _InputIterator __last);
            void push_back(char32_t __c);
            std::basic_string<char32_t> &assign(const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &assign(std::basic_string<char32_t> &&__str);
            std::basic_string<char32_t> &assign(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &assign(const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &assign(const char32_t *__s);
            std::basic_string<char32_t> &assign(std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t> &assign(_InputIterator __first, _InputIterator __last);
            std::basic_string<char32_t> &assign(initializer_list<char32_t> __l);
            std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::const_iterator __p, std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::const_iterator __p, initializer_list<char32_t> __l);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos1, const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos1, const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos2, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos, const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos, const char32_t *__s);
            std::basic_string<char32_t> &insert(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, char32_t __c);
            std::basic_string<char32_t>::iterator insert(std::basic_string<char32_t>::__const_iterator __p, char32_t __c);
            std::basic_string<char32_t> &erase(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t>::iterator erase(std::basic_string<char32_t>::__const_iterator __position);
            std::basic_string<char32_t>::iterator erase(std::basic_string<char32_t>::__const_iterator __first, std::basic_string<char32_t>::__const_iterator __last);
            void pop_back() noexcept;
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos1, std::basic_string<char32_t>::size_type __n1, const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos2, std::basic_string<char32_t>::size_type __n2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s, std::basic_string<char32_t>::size_type __n2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2, char32_t __c);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const std::basic_string<char32_t> &__str);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const char32_t *__s, std::basic_string<char32_t>::size_type __n);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const char32_t *__s);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, std::basic_string<char32_t>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char32_t> &replace(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, std::basic_string<char32_t>::iterator __k1, std::basic_string<char32_t>::iterator __k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::__const_iterator __i1, std::basic_string<char32_t>::__const_iterator __i2, std::basic_string<char32_t>::const_iterator __k1, std::basic_string<char32_t>::const_iterator __k2);
            std::basic_string<char32_t> &replace(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, initializer_list<char32_t> __l);
        private:
            template <class _Integer> std::basic_string<char32_t> &_M_replace_dispatch(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::basic_string<char32_t> &_M_replace_dispatch(std::basic_string<char32_t>::const_iterator __i1, std::basic_string<char32_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::basic_string<char32_t> &_M_replace_aux(std::basic_string<char32_t>::size_type __pos1, std::basic_string<char32_t>::size_type __n1, std::basic_string<char32_t>::size_type __n2, char32_t __c);
            std::basic_string<char32_t> &_M_replace(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __len1, const char32_t *__s, const std::basic_string<char32_t>::size_type __len2);
            std::basic_string<char32_t> &_M_append(const char32_t *__s, std::basic_string<char32_t>::size_type __n);
        public:
            std::basic_string<char32_t>::size_type copy(char32_t *__s, std::basic_string<char32_t>::size_type __n, std::basic_string<char32_t>::size_type __pos) const;
            void swap(std::basic_string<char32_t> &__s) noexcept;
            const char32_t *c_str() const noexcept;
            const char32_t *data() const noexcept {
                return this->_M_data();
            }
            std::basic_string<char32_t>::allocator_type get_allocator() const noexcept;
            std::basic_string<char32_t>::size_type find(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type rfind(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type rfind(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type rfind(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const;
            std::basic_string<char32_t>::size_type rfind(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_first_not_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(const char32_t *__s, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t>::size_type find_last_not_of(char32_t __c, std::basic_string<char32_t>::size_type __pos) const noexcept;
            std::basic_string<char32_t> substr(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n) const;
            int compare(const std::basic_string<char32_t> &__str) const;
            int compare(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n, const std::basic_string<char32_t> &__str) const;
            int compare(std::basic_string<char32_t>::size_type __pos1, std::basic_string<char32_t>::size_type __n1, const std::basic_string<char32_t> &__str, std::basic_string<char32_t>::size_type __pos2, std::basic_string<char32_t>::size_type __n2) const;
            int compare(const char32_t *__s) const noexcept;
            int compare(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s) const;
            int compare(std::basic_string<char32_t>::size_type __pos, std::basic_string<char32_t>::size_type __n1, const char32_t *__s, std::basic_string<char32_t>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
}
namespace std {
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, const char *__rhs) {
        basic_string<char, std::char_traits<char>, std::allocator<char>> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs) {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str(__lhs);
        __str.append(__size_type(1), __rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
        using _Alloc_traits = allocator_traits<_Alloc>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal({}))
            __use_rhs = true;
        else if (__lhs.get_allocator() == __rhs.get_allocator())
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs) {
        using _Alloc_traits = allocator_traits<std::allocator<char>>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal{})
            __use_rhs = true;
        else if (__lhs.get_allocator() == __rhs.get_allocator())
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs) {
        return std::move(__rhs.insert(0, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
        return std::move(__rhs.insert(0, 1, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs) {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, const char *__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs) {
        return std::move(__lhs.append(1, __rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT> inline typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator==(const basic_string<_CharT> &__lhs, const basic_string<_CharT> &__rhs) noexcept {
        return (__lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size()));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        return __rhs.compare(__lhs) == 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
        return __lhs.compare(__rhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
        return __lhs.compare(__rhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        return __rhs.compare(__lhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
        return __lhs.compare(__rhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
        return __lhs.compare(__rhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        return __rhs.compare(__lhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
        return __lhs.compare(__rhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
        return __lhs.compare(__rhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        return __rhs.compare(__lhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
        return __lhs.compare(__rhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
        return __lhs.compare(__rhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        return __rhs.compare(__lhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline void swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))) {
        __lhs.swap(__rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str);
    template<> basic_istream<char> &operator>><char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__is, basic_string<char> &__str);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Alloc> &__str) {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str) {
        return std::getline(__is, __str, __is.widen('\n'));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim) {
        return std::getline(__is, __str, __delim);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str) {
        return std::getline(__is, __str);
    }
    template<> basic_istream<char> &getline<char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__in, basic_string<char> &__str, char __delim);
    template<> basic_istream<wchar_t> &getline<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim);
}
extern "C" {
    typedef struct {
        int quot;
        int rem;
    } div_t;
    typedef struct {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct {
        long long quot;
        long long rem;
    } lldiv_t;
    extern size_t __ctype_get_mb_cur_max() noexcept(true);
    extern double atof(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern int atoi(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern long atol(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern long long atoll(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float32 strtof32(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float64 strtof64(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float32x strtof32x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float64x strtof64x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern int strfromd(char *__dest, size_t __size, const char *__format, double __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf(char *__dest, size_t __size, const char *__format, float __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfroml(char *__dest, size_t __size, const char *__format, long double __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf32(char *__dest, size_t __size, const char *__format, _Float32 __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf64(char *__dest, size_t __size, const char *__format, _Float64 __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf32x(char *__dest, size_t __size, const char *__format, _Float32x __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf64x(char *__dest, size_t __size, const char *__format, _Float64x __f) noexcept(true) __attribute__((nonnull(3)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float32 strtof32_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float64 strtof64_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float32x strtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float64x strtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern char *l64a(long __n) noexcept(true);
    extern long a64l(const char *__s) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern "C" {
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __off_t off_t;
        typedef __off64_t off64_t;
        typedef __id_t id_t;
        typedef __ssize_t ssize_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long ulong;
        typedef unsigned short ushort;
        typedef unsigned int uint;
        typedef __uint8_t u_int8_t;
        typedef __uint16_t u_int16_t;
        typedef __uint32_t u_int32_t;
        typedef __uint64_t u_int64_t;
        typedef int register_t __attribute__((mode(__word__)));
        static inline __uint16_t __bswap_16(__uint16_t __bsx) {
            return ((__uint16_t)((((__bsx) >> 8) & 255) | (((__bsx) & 255) << 8)));
        }
        static inline __uint32_t __bswap_32(__uint32_t __bsx) {
            return ((((__bsx) & 4278190080U) >> 24) | (((__bsx) & 16711680U) >> 8) | (((__bsx) & 65280U) << 8) | (((__bsx) & 255U) << 24));
        }
        static inline __uint64_t __bswap_64(__uint64_t __bsx) {
            return ((((__bsx) & 18374686479671623680ULL) >> 56) | (((__bsx) & 71776119061217280ULL) >> 40) | (((__bsx) & 280375465082880ULL) >> 24) | (((__bsx) & 1095216660480ULL) >> 8) | (((__bsx) & 4278190080ULL) << 8) | (((__bsx) & 16711680ULL) << 24) | (((__bsx) & 65280ULL) << 40) | (((__bsx) & 255ULL) << 56));
        }
        static inline __uint16_t __uint16_identity(__uint16_t __x) {
            return __x;
        }
        static inline __uint32_t __uint32_identity(__uint32_t __x) {
            return __x;
        }
        static inline __uint64_t __uint64_identity(__uint64_t __x) {
            return __x;
        }
        typedef __sigset_t sigset_t;
        typedef long __fd_mask;
        typedef struct {
            __fd_mask fds_bits[16];
        } fd_set;
        typedef __fd_mask fd_mask;
        extern "C" {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
    }
    extern long random() noexcept(true);
    extern void srandom(unsigned int __seed) noexcept(true);
    extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen) noexcept(true) __attribute__((nonnull(2)));
    extern char *setstate(char *__statebuf) noexcept(true) __attribute__((nonnull(1)));
    struct random_data {
        int32_t *fptr;
        int32_t *rptr;
        int32_t *state;
        int rand_type;
        int rand_deg;
        int rand_sep;
        int32_t *end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int srandom_r(unsigned int __seed, struct random_data *__buf) noexcept(true) __attribute__((nonnull(2)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) noexcept(true) __attribute__((nonnull(2, 4)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int rand() noexcept(true);
    extern void srand(unsigned int __seed) noexcept(true);
    extern int rand_r(unsigned int *__seed) noexcept(true);
    extern double drand48() noexcept(true);
    extern double erand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern long lrand48() noexcept(true);
    extern long nrand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern long mrand48() noexcept(true);
    extern long jrand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern void srand48(long __seedval) noexcept(true);
    extern unsigned short *seed48(unsigned short __seed16v[3]) noexcept(true) __attribute__((nonnull(1)));
    extern void lcong48(unsigned short __param[7]) noexcept(true) __attribute__((nonnull(1)));
    struct drand48_data {
        unsigned short __x[3];
        unsigned short __old_x[3];
        unsigned short __c;
        unsigned short __init;
        unsigned long long __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int srand48_r(long __seedval, struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(2)));
    extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(1, 2)));
    extern void *malloc(size_t __size) noexcept(true) __attribute__((malloc));
    extern void *calloc(size_t __nmemb, size_t __size) noexcept(true) __attribute__((malloc));
    extern void *realloc(void *__ptr, size_t __size) noexcept(true) __attribute__((warn_unused_result("")));
    extern void free(void *__ptr) noexcept(true);
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(true) __attribute__((warn_unused_result("")));
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(true);
    extern "C" {
        extern void *alloca(size_t __size) noexcept(true);
    }
    extern void *valloc(size_t __size) noexcept(true) __attribute__((malloc));
    extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size) noexcept(true) __attribute__((nonnull(1)));
    extern void *aligned_alloc(size_t __alignment, size_t __size) noexcept(true) __attribute__((malloc)) __attribute__((alloc_align(1)));
    extern void abort() noexcept(true);
    extern int atexit(void (*__func)()) noexcept(true) __attribute__((nonnull(1)));
    extern "C++" int at_quick_exit(void (*__func)()) noexcept(true) asm("at_quick_exit") __attribute__((nonnull(1)))
    extern int on_exit(void (*__func)(int, void *), void *__arg) noexcept(true) __attribute__((nonnull(1)));
    extern void exit(int __status) noexcept(true);
    extern void quick_exit(int __status) noexcept(true);
    extern void _Exit(int __status) noexcept(true);
    extern char *getenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern char *secure_getenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern int putenv(char *__string) noexcept(true) __attribute__((nonnull(1)));
    extern int setenv(const char *__name, const char *__value, int __replace) noexcept(true) __attribute__((nonnull(2)));
    extern int unsetenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern int clearenv() noexcept(true);
    extern char *mktemp(char *__template) noexcept(true) __attribute__((nonnull(1)));
    extern int mkstemp(char *__template) __attribute__((nonnull(1)));
    extern int mkstemp64(char *__template) __attribute__((nonnull(1)));
    extern int mkstemps(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern int mkstemps64(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern char *mkdtemp(char *__template) noexcept(true) __attribute__((nonnull(1)));
    extern int mkostemp(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemp64(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int system(const char *__command);
    extern char *canonicalize_file_name(const char *__name) noexcept(true) __attribute__((nonnull(1))) __attribute__((malloc));
    extern char *realpath(const char *__restrict __name, char *__restrict __resolved) noexcept(true);
    typedef int (*__compar_fn_t)(const void *, const void *);
    typedef __compar_fn_t comparison_fn_t;
    typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
    extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 2, 5)));
    extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 4)));
    extern void qsort_r(void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg) __attribute__((nonnull(1, 4)));
    extern int abs(int __x) noexcept(true) __attribute__((const));
    extern long labs(long __x) noexcept(true) __attribute__((const));
    extern long long llabs(long long __x) noexcept(true) __attribute__((const));
    extern div_t div(int __numer, int __denom) noexcept(true) __attribute__((const));
    extern ldiv_t ldiv(long __numer, long __denom) noexcept(true) __attribute__((const));
    extern lldiv_t lldiv(long long __numer, long long __denom) noexcept(true) __attribute__((const));
    extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *gcvt(double __value, int __ndigit, char *__buf) noexcept(true) __attribute__((nonnull(3)));
    extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *qgcvt(long double __value, int __ndigit, char *__buf) noexcept(true) __attribute__((nonnull(3)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int mblen(const char *__s, size_t __n) noexcept(true);
    extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) noexcept(true);
    extern int wctomb(char *__s, wchar_t __wchar) noexcept(true);
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) noexcept(true);
    extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) noexcept(true);
    extern int rpmatch(const char *__response) noexcept(true) __attribute__((nonnull(1)));
    extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) noexcept(true) __attribute__((nonnull(1, 2, 3)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) noexcept(true);
    extern int unlockpt(int __fd) noexcept(true);
    extern char *ptsname(int __fd) noexcept(true);
    extern int ptsname_r(int __fd, char *__buf, size_t __buflen) noexcept(true) __attribute__((nonnull(2)));
    extern int getpt();
    extern int getloadavg(double __loadavg[], int __nelem) noexcept(true) __attribute__((nonnull(1)));
}
extern "C++" {
    namespace std {
        using ::abs;
        inline long abs(long __i) {
            return __builtin_labs(__i);
        }
        inline long long abs(long long __x) {
            return __builtin_llabs(__x);
        }
        inline constexpr double abs(double __x) {
            return __builtin_fabs(__x);
        }
        inline constexpr float abs(float __x) {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double abs(long double __x) {
            return __builtin_fabsl(__x);
        }
        inline constexpr __int128 abs(__int128 __x) {
            return __x >= 0 ? __x : -__x;
        }
        inline constexpr __float128 abs(__float128 __x) {
            return __x < 0 ? -__x : __x;
        }
    }
}
extern "C++" {
    namespace std {
        using ::div_t;
        using ::ldiv_t;
        using ::abort;
        using ::atexit;
        using ::at_quick_exit;
        using ::atof;
        using ::atoi;
        using ::atol;
        using ::bsearch;
        using ::calloc;
        using ::div;
        using ::exit;
        using ::free;
        using ::getenv;
        using ::labs;
        using ::ldiv;
        using ::malloc;
        using ::mblen;
        using ::mbstowcs;
        using ::mbtowc;
        using ::qsort;
        using ::quick_exit;
        using ::rand;
        using ::realloc;
        using ::srand;
        using ::strtod;
        using ::strtol;
        using ::strtoul;
        using ::system;
        using ::wcstombs;
        using ::wctomb;
        inline ldiv_t div(long __i, long __j) {
            return ldiv(__i, __j);
        }
    }
    namespace __gnu_cxx {
        using ::lldiv_t;
        using ::_Exit;
        using ::llabs;
        inline lldiv_t div(long long __n, long long __d) {
            lldiv_t __q;
            __q.quot = __n / __d;
            __q.rem = __n % __d;
            return __q;
        }
        using ::lldiv;
        using ::atoll;
        using ::strtoll;
        using ::strtoull;
        using ::strtof;
        using ::strtold;
    }
    namespace std {
        using ::__gnu_cxx::lldiv_t;
        using ::__gnu_cxx::_Exit;
        using ::__gnu_cxx::llabs;
        using ::__gnu_cxx::div;
        using ::__gnu_cxx::lldiv;
        using ::__gnu_cxx::atoll;
        using ::__gnu_cxx::strtof;
        using ::__gnu_cxx::strtoll;
        using ::__gnu_cxx::strtoull;
        using ::__gnu_cxx::strtold;
    }
}
extern "C" {
    typedef struct _G_fpos_t {
        __off_t __pos;
        __mbstate_t __state;
    } __fpos_t;
    typedef struct _G_fpos64_t {
        __off64_t __pos;
        __mbstate_t __state;
    } __fpos64_t;
    struct _IO_FILE;
    struct _IO_marker;
    struct _IO_codecvt;
    struct _IO_wide_data;
    typedef void _IO_lock_t;
    struct _IO_FILE {
        int _flags;
        char *_IO_read_ptr;
        char *_IO_read_end;
        char *_IO_read_base;
        char *_IO_write_base;
        char *_IO_write_ptr;
        char *_IO_write_end;
        char *_IO_buf_base;
        char *_IO_buf_end;
        char *_IO_save_base;
        char *_IO_backup_base;
        char *_IO_save_end;
        struct _IO_marker *_markers;
        struct _IO_FILE *_chain;
        int _fileno;
        int _flags2;
        __off_t _old_offset;
        unsigned short _cur_column;
        signed char _vtable_offset;
        char _shortbuf[1];
        _IO_lock_t *_lock;
        __off64_t _offset;
        struct _IO_codecvt *_codecvt;
        struct _IO_wide_data *_wide_data;
        struct _IO_FILE *_freeres_list;
        void *_freeres_buf;
        size_t __pad5;
        int _mode;
        char _unused2[20];
    };
    typedef __ssize_t (cookie_read_function_t)(void *, char *, size_t);
    typedef __ssize_t (cookie_write_function_t)(void *, const char *, size_t);
    typedef int (cookie_seek_function_t)(void *, __off64_t *, int);
    typedef int (cookie_close_function_t)(void *);
    typedef struct _IO_cookie_io_functions_t {
        cookie_read_function_t *read;
        cookie_write_function_t *write;
        cookie_seek_function_t *seek;
        cookie_close_function_t *close;
    } cookie_io_functions_t;
    typedef __gnuc_va_list va_list;
    typedef __fpos_t fpos_t;
    typedef __fpos64_t fpos64_t;
    extern FILE *stdin;
    extern FILE *stdout;
    extern FILE *stderr;
    extern int remove(const char *__filename) noexcept(true);
    extern int rename(const char *__old, const char *__new) noexcept(true);
    extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) noexcept(true);
    extern int renameat2(int __oldfd, const char *__old, int __newfd, const char *__new, unsigned int __flags) noexcept(true);
    extern int fclose(FILE *__stream);
    extern FILE *tmpfile() __attribute__((malloc));
    extern FILE *tmpfile64() __attribute__((malloc));
    extern char *tmpnam(char[20]) noexcept(true);
    extern char *tmpnam_r(char __s[20]) noexcept(true);
    extern char *tempnam(const char *__dir, const char *__pfx) noexcept(true) __attribute__((malloc));
    extern int fflush(FILE *__stream);
    extern int fflush_unlocked(FILE *__stream);
    extern int fcloseall();
    extern FILE *fopen(const char *__restrict __filename, const char *__restrict __modes) __attribute__((malloc));
    extern FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes) __attribute__((malloc));
    extern FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fdopen(int __fd, const char *__modes) noexcept(true) __attribute__((malloc));
    extern FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, cookie_io_functions_t __io_funcs) noexcept(true) __attribute__((malloc));
    extern FILE *fmemopen(void *__s, size_t __len, const char *__modes) noexcept(true) __attribute__((malloc));
    extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern void setbuf(FILE *__restrict __stream, char *__restrict __buf) noexcept(true);
    extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) noexcept(true);
    extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf, size_t __size) noexcept(true);
    extern void setlinebuf(FILE *__stream) noexcept(true);
    extern int fprintf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int printf(const char *__restrict __format, ...);
    extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) noexcept(true);
    extern int vfprintf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg);
    extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);
    extern int vsprintf(char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int snprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, ...) noexcept(true) __attribute__((format(printf, 3, 4)));
    extern int vsnprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) __attribute__((format(printf, 3, 0)));
    extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, __gnuc_va_list __arg) noexcept(true) __attribute__((format(printf, 2, 0)));
    extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int vdprintf(int __fd, const char *__restrict __fmt, __gnuc_va_list __arg) __attribute__((format(printf, 2, 0)));
    extern int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((format(printf, 2, 3)));
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int scanf(const char *__restrict __format, ...);
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(true);
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...) asm("__isoc99_fscanf");
    extern int scanf(const char *__restrict __format, ...) asm("__isoc99_scanf");
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(true) asm("__isoc99_sscanf");
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) __attribute__((format(scanf, 2, 0)));
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vfscanf") __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vscanf") __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) asm("__isoc99_vsscanf") __attribute__((format(scanf, 2, 0)));
    extern int fgetc(FILE *__stream);
    extern int getc(FILE *__stream);
    extern int getchar();
    extern int getc_unlocked(FILE *__stream);
    extern int getchar_unlocked();
    extern int fgetc_unlocked(FILE *__stream);
    extern int fputc(int __c, FILE *__stream);
    extern int putc(int __c, FILE *__stream);
    extern int putchar(int __c);
    extern int fputc_unlocked(int __c, FILE *__stream);
    extern int putc_unlocked(int __c, FILE *__stream);
    extern int putchar_unlocked(int __c);
    extern int getw(FILE *__stream);
    extern int putw(int __w, FILE *__stream);
    extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern char *fgets_unlocked(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream);
    extern int fputs(const char *__restrict __s, FILE *__restrict __stream);
    extern int puts(const char *__s);
    extern int ungetc(int __c, FILE *__stream);
    extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);
    extern int fputs_unlocked(const char *__restrict __s, FILE *__restrict __stream);
    extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern int fseek(FILE *__stream, long __off, int __whence);
    extern long ftell(FILE *__stream);
    extern void rewind(FILE *__stream);
    extern int fseeko(FILE *__stream, __off_t __off, int __whence);
    extern __off_t ftello(FILE *__stream);
    extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos);
    extern int fsetpos(FILE *__stream, const fpos_t *__pos);
    extern int fseeko64(FILE *__stream, __off64_t __off, int __whence);
    extern __off64_t ftello64(FILE *__stream);
    extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos);
    extern int fsetpos64(FILE *__stream, const fpos64_t *__pos);
    extern void clearerr(FILE *__stream) noexcept(true);
    extern int feof(FILE *__stream) noexcept(true);
    extern int ferror(FILE *__stream) noexcept(true);
    extern void clearerr_unlocked(FILE *__stream) noexcept(true);
    extern int feof_unlocked(FILE *__stream) noexcept(true);
    extern int ferror_unlocked(FILE *__stream) noexcept(true);
    extern void perror(const char *__s);
    extern int fileno(FILE *__stream) noexcept(true);
    extern int fileno_unlocked(FILE *__stream) noexcept(true);
    extern int pclose(FILE *__stream);
    extern FILE *popen(const char *__command, const char *__modes) __attribute__((malloc));
    extern char *ctermid(char *__s) noexcept(true);
    extern char *cuserid(char *__s);
    struct obstack;
    extern int obstack_printf(struct obstack *__restrict __obstack, const char *__restrict __format, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int obstack_vprintf(struct obstack *__restrict __obstack, const char *__restrict __format, __gnuc_va_list __args) noexcept(true) __attribute__((format(printf, 2, 0)));
    extern void flockfile(FILE *__stream) noexcept(true);
    extern int ftrylockfile(FILE *__stream) noexcept(true);
    extern void funlockfile(FILE *__stream) noexcept(true);
    extern int __uflow(FILE *);
    extern int __overflow(FILE *, int);
}
namespace std {
    using ::FILE;
    using ::fpos_t;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::printf;
    using ::putc;
    using ::putchar;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
}
namespace __gnu_cxx {
    using ::snprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsnprintf;
    using ::vsscanf;
}
namespace std {
    using ::__gnu_cxx::snprintf;
    using ::__gnu_cxx::vfscanf;
    using ::__gnu_cxx::vscanf;
    using ::__gnu_cxx::vsnprintf;
    using ::__gnu_cxx::vsscanf;
}
extern "C" {
    extern int *__errno_location() noexcept(true) __attribute__((const));
    extern char *program_invocation_name;
    extern char *program_invocation_short_name;
    typedef int error_t;
}
namespace __gnu_cxx {
    template <typename _TRet, typename _Ret = _TRet, typename _CharT, typename ..._Base> _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base...), const char *__name, const _CharT *__str, std::size_t *__idx, _Base ...__base) {
        _Ret __ret;
        _CharT *__endptr;
        const struct _Save_errno {
            _Save_errno() : _M_errno((*__errno_location())) {
                (*__errno_location()) = 0;
            }
            ~_Save_errno() {
                if ((*__errno_location()) == 0)
                    (*__errno_location()) = this->_M_errno;
            }
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
            static bool _S_chk(_TRet, std::false_type) {
                return false;
            }
            static bool _S_chk(_TRet __val, std::true_type) {
                return __val < _TRet(__numeric_traits<int>::__min) || __val > _TRet(__numeric_traits<int>::__max);
            }
        };
        const _TRet __tmp = __convf(__str, &__endptr, __base...);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>({})))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        int __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, char, <int>>(unsigned long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        unsigned long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, char, <int>>(long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, char, <int>>(unsigned long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        unsigned long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, char, <>>(float (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx) {
        float __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, char, <>>(double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx) {
        double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, char, <>>(long double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx) {
        long double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        int __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, wchar_t, <int>>(unsigned long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        unsigned long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, wchar_t, <int>>(long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, wchar_t, <int>>(unsigned long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        unsigned long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, wchar_t, <>>(float (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx) {
        float __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, wchar_t, <>>(double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx) {
        double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, wchar_t, <>>(long double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx) {
        long double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template <typename _String, typename _CharT = typename _String::value_type> _String __to_xstring(int (*__convf)(_CharT *, std::size_t, const _CharT *, __va_list_tag *), std::size_t __n, const _CharT *__fmt, ...) {
        _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return _String(__s, __s + __len);
    }
    template<> std::basic_string<char> __to_xstring<std::basic_string<char>, char>(int (*__convf)(char *, std::size_t, const char *, __va_list_tag *), std::size_t __n, const char *__fmt, ...) {
        char *__s = static_cast<char *>(__builtin_alloca(sizeof(char) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::basic_string<char>(__s, __s + __len);
    }
    template<> std::basic_string<wchar_t> __to_xstring<std::basic_string<wchar_t>, wchar_t>(int (*__convf)(wchar_t *, std::size_t, const wchar_t *, __va_list_tag *), std::size_t __n, const wchar_t *__fmt, ...) {
        wchar_t *__s = static_cast<wchar_t *>(__builtin_alloca(sizeof(wchar_t) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::basic_string<wchar_t>(__s, __s + __len);
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp> constexpr unsigned int __to_chars_len(_Tp __value, int __base = 10) noexcept {
            static_assert(is_integral<_Tp>::value, "implementation bug");
            static_assert(is_unsigned<_Tp>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned int>(unsigned int __value, int __base = 10) noexcept {
            static_assert(is_integral<unsigned int>::value, "implementation bug");
            static_assert(is_unsigned<unsigned int>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long>(unsigned long __value, int __base = 10) noexcept {
            static_assert(is_integral<unsigned long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long long>(unsigned long long __value, int __base = 10) noexcept {
            static_assert(is_integral<unsigned long long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long long>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template <typename _Tp> void __to_chars_10_impl(char *__first, unsigned int __len, _Tp __val) noexcept {
            static_assert(is_integral<_Tp>::value, "implementation bug");
            static_assert(is_unsigned<_Tp>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned int>(char *__first, unsigned int __len, unsigned int __val) noexcept {
            static_assert(is_integral<unsigned int>::value, "implementation bug");
            static_assert(is_unsigned<unsigned int>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long>(char *__first, unsigned int __len, unsigned long __val) noexcept {
            static_assert(is_integral<unsigned long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long long>(char *__first, unsigned int __len, unsigned long long __val) noexcept {
            static_assert(is_integral<unsigned long long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long long>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
    }
}
namespace std {
    inline namespace __cxx11 {
        inline int stoi(const std::string &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::string &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::string &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::string &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::string &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::string &__str, std::size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::string &__str, std::size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::string &__str, std::size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx);
        }
        inline std::string to_string(int __val) noexcept {
            const bool __neg = __val < 0;
            const unsigned int __uval = __neg ? (unsigned int)~__val + 1U : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned int __val) noexcept {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(long __val) {
            const bool __neg = __val < 0;
            const unsigned long __uval = __neg ? (unsigned long)~__val + 1UL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned long __val) {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(long long __val) {
            const bool __neg = __val < 0;
            const unsigned long long __uval = __neg ? (unsigned long long)~__val + 1ULL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned long long __val) {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(float __val) {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(double __val) {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(long double __val) {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%Lf", __val);
        }
        inline int stoi(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::wstring &__str, std::size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::wstring &__str, std::size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::wstring &__str, std::size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx);
        }
        inline std::wstring to_wstring(int __val) {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(int), L"%d", __val);
        }
        inline std::wstring to_wstring(unsigned int __val) {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned int), L"%u", __val);
        }
        inline std::wstring to_wstring(long __val) {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long), L"%ld", __val);
        }
        inline std::wstring to_wstring(unsigned long __val) {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long), L"%lu", __val);
        }
        inline std::wstring to_wstring(long long __val) {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long long), L"%lld", __val);
        }
        inline std::wstring to_wstring(unsigned long long __val) {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long long), L"%llu", __val);
        }
        inline std::wstring to_wstring(float __val) {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(double __val) {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(long double __val) {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%Lf", __val);
        }
    }
}
namespace std {
    template <typename _Result, typename _Arg> struct __hash_base {
        typedef _Result result_type;
        typedef _Arg argument_type;
    };
    template<> struct __hash_base<unsigned long, bool> {
        typedef unsigned long result_type;
        typedef bool argument_type;
    };
    template<> struct __hash_base<unsigned long, char> {
        typedef unsigned long result_type;
        typedef char argument_type;
    };
    template<> struct __hash_base<unsigned long, signed char> {
        typedef unsigned long result_type;
        typedef signed char argument_type;
    };
    template<> struct __hash_base<unsigned long, unsigned char> {
        typedef unsigned long result_type;
        typedef unsigned char argument_type;
    };
    template<> struct __hash_base<unsigned long, wchar_t> {
        typedef unsigned long result_type;
        typedef wchar_t argument_type;
    };
    template<> struct __hash_base<unsigned long, char16_t> {
        typedef unsigned long result_type;
        typedef char16_t argument_type;
    };
    template<> struct __hash_base<unsigned long, char32_t> {
        typedef unsigned long result_type;
        typedef char32_t argument_type;
    };
    template<> struct __hash_base<unsigned long, short> {
        typedef unsigned long result_type;
        typedef short argument_type;
    };
    template<> struct __hash_base<unsigned long, int> {
        typedef unsigned long result_type;
        typedef int argument_type;
    };
    template<> struct __hash_base<unsigned long, long> {
        typedef unsigned long result_type;
        typedef long argument_type;
    };
    template<> struct __hash_base<unsigned long, long long> {
        typedef unsigned long result_type;
        typedef long long argument_type;
    };
    template<> struct __hash_base<unsigned long, unsigned short> {
        typedef unsigned long result_type;
        typedef unsigned short argument_type;
    };
    template<> struct __hash_base<unsigned long, unsigned int> {
        typedef unsigned long result_type;
        typedef unsigned int argument_type;
    };
    template<> struct __hash_base<unsigned long, unsigned long> {
        typedef unsigned long result_type;
        typedef unsigned long argument_type;
    };
    template<> struct __hash_base<unsigned long, unsigned long long> {
        typedef unsigned long result_type;
        typedef unsigned long long argument_type;
    };
    template<> struct __hash_base<unsigned long, __int128> {
        typedef unsigned long result_type;
        typedef __int128 argument_type;
    };
    template<> struct __hash_base<unsigned long, unsigned __int128> {
        typedef unsigned long result_type;
        typedef unsigned __int128 argument_type;
    };
    template<> struct __hash_base<unsigned long, float> {
        typedef unsigned long result_type;
        typedef float argument_type;
    };
    template<> struct __hash_base<unsigned long, double> {
        typedef unsigned long result_type;
        typedef double argument_type;
    };
    template<> struct __hash_base<unsigned long, long double> {
        typedef unsigned long result_type;
        typedef long double argument_type;
    };
    template<> struct __hash_base<unsigned long, std::basic_string<char>> {
        typedef unsigned long result_type;
        typedef std::basic_string<char> argument_type;
    };
    template<> struct __hash_base<unsigned long, std::basic_string<wchar_t>> {
        typedef unsigned long result_type;
        typedef std::basic_string<wchar_t> argument_type;
    };
    template<> struct __hash_base<unsigned long, std::basic_string<char16_t>> {
        typedef unsigned long result_type;
        typedef std::basic_string<char16_t> argument_type;
    };
    template<> struct __hash_base<unsigned long, std::basic_string<char32_t>> {
        typedef unsigned long result_type;
        typedef std::basic_string<char32_t> argument_type;
    };
    template<> struct __hash_base<unsigned long, std::error_code> {
        typedef unsigned long result_type;
        typedef std::error_code argument_type;
    };
    template <typename _Tp> struct hash;
    template <typename _Tp, typename = void> struct __poison_hash {
        static constexpr bool __enable_hash_call = false;
    private:
        __poison_hash<_Tp, type-parameter-0-1>(__poison_hash<_Tp, type-parameter-0-1> &&);
        ~__poison_hash<_Tp, type-parameter-0-1>();
    };
    template <typename _Tp> struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
        static constexpr bool __enable_hash_call = true;
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
    private:
        __hash_enum<_Tp, >(__hash_enum<_Tp, > &&);
        ~__hash_enum<_Tp, >();
    };
    template <typename _Tp> struct __hash_enum<_Tp, true> : public __hash_base<std::size_t, _Tp> {
        std::size_t operator()(_Tp __val) const noexcept {
            using __type = typename underlying_type<_Tp>::type;
            return hash<__type>({})(static_cast<__type>(__val));
        }
    };
    template <typename _Tp> struct hash : __hash_enum<_Tp> {
    };
    template <typename _Tp> struct hash<_Tp *> : public __hash_base<std::size_t, _Tp *> {
        std::size_t operator()(_Tp *__p) const noexcept {
            return reinterpret_cast<std::size_t>(__p);
        }
    };
    template<> struct hash<bool> : public __hash_base<std::size_t, bool> {
        std::size_t operator()(bool __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char> : public __hash_base<std::size_t, char> {
        std::size_t operator()(char __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<signed char> : public __hash_base<std::size_t, signed char> {
        std::size_t operator()(signed char __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned char> : public __hash_base<std::size_t, unsigned char> {
        std::size_t operator()(unsigned char __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<wchar_t> : public __hash_base<std::size_t, wchar_t> {
        std::size_t operator()(wchar_t __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char16_t> : public __hash_base<std::size_t, char16_t> {
        std::size_t operator()(char16_t __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char32_t> : public __hash_base<std::size_t, char32_t> {
        std::size_t operator()(char32_t __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<short> : public __hash_base<std::size_t, short> {
        std::size_t operator()(short __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<int> : public __hash_base<std::size_t, int> {
        std::size_t operator()(int __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long> : public __hash_base<std::size_t, long> {
        std::size_t operator()(long __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long long> : public __hash_base<std::size_t, long long> {
        std::size_t operator()(long long __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned short> : public __hash_base<std::size_t, unsigned short> {
        std::size_t operator()(unsigned short __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned int> : public __hash_base<std::size_t, unsigned int> {
        std::size_t operator()(unsigned int __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long> : public __hash_base<std::size_t, unsigned long> {
        std::size_t operator()(unsigned long __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long long> : public __hash_base<std::size_t, unsigned long long> {
        std::size_t operator()(unsigned long long __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<__int128> : public __hash_base<std::size_t, __int128> {
        std::size_t operator()(__int128 __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned __int128> : public __hash_base<std::size_t, unsigned __int128> {
        std::size_t operator()(unsigned __int128 __val) const noexcept {
            return static_cast<std::size_t>(__val);
        }
    };
    struct _Hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(3339675911UL)) {
            return _Hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val) {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<float>(const float &__val) {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<double>(const double &__val) {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<int>(const int &__val) {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash) {
            return hash(&__val, sizeof (__val), __hash);
        }
        template<> static std::size_t __hash_combine<const std::error_category *>(const std::error_category *const &__val, std::size_t __hash) {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    struct _Fnv_hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(2166136261UL)) {
            return _Fnv_hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val) {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash) {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    template<> struct hash<float> : public __hash_base<std::size_t, float> {
        std::size_t operator()(float __val) const noexcept {
            return __val != 0.F ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<double> : public __hash_base<std::size_t, double> {
        std::size_t operator()(double __val) const noexcept {
            return __val != 0. ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<long double> : public __hash_base<std::size_t, long double> {
        std::size_t operator()(long double __val) const noexcept __attribute__((pure));
    };
    template <typename _Hash> struct __is_fast_hash : public std::true_type {
    };
    template<> struct __is_fast_hash<hash<long double>> : public std::false_type {
    };
}
namespace std {
    template<> struct hash<std::string> : public __hash_base<std::size_t, std::string> {
        std::size_t operator()(const std::string &__s) const noexcept {
            return std::_Hash_impl::hash(__s.data(), __s.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::string>> : std::false_type {
    };
    template<> struct hash<std::wstring> : public __hash_base<std::size_t, std::wstring> {
        std::size_t operator()(const std::wstring &__s) const noexcept {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::wstring>> : std::false_type {
    };
    template<> struct hash<std::u16string> : public __hash_base<std::size_t, std::u16string> {
        std::size_t operator()(const std::u16string &__s) const noexcept {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u16string>> : std::false_type {
    };
    template<> struct hash<std::u32string> : public __hash_base<std::size_t, std::u32string> {
        std::size_t operator()(const std::u32string &__s) const noexcept {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u32string>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_literals {
            inline basic_string<char> operator""s(const char *__str, std::size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<char>{__str, __len};
            }
            inline basic_string<wchar_t> operator""s(const wchar_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<wchar_t>{__str, __len};
            }
            inline basic_string<char16_t> operator""s(const char16_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<char16_t>{__str, __len};
            }
            inline basic_string<char32_t> operator""s(const char32_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<char32_t>{__str, __len};
            }
        }
    }
}
namespace std {
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type npos;
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept {
        if (this == std::__addressof(__s))
            return;
        _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());
        if (this->_M_is_local())
            if (__s._M_is_local()) {
                if (this->length() && __s.length()) {
                    _CharT __tmp_data[_S_local_capacity + 1];
                    traits_type::copy(__tmp_data, __s._M_local_buf, __s.length() + 1);
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                    traits_type::copy(this->_M_local_buf, __tmp_data, __s.length() + 1);
                } else if (__s.length()) {
                    traits_type::copy(this->_M_local_buf, __s._M_local_buf, __s.length() + 1);
                    this->_M_length(__s.length());
                    __s._M_set_length(0);
                    return;
                } else if (this->length()) {
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                    __s._M_length(this->length());
                    this->_M_set_length(0);
                    return;
                }
            } else {
                const std::basic_string::size_type __tmp_capacity = __s._M_allocated_capacity;
                traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                _M_data(__s._M_data());
                __s._M_data(__s._M_local_buf);
                this->_M_capacity(__tmp_capacity);
            }
        else {
            const std::basic_string::size_type __tmp_capacity = this->_M_allocated_capacity;
            if (__s._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __s._M_local_buf, __s.length() + 1);
                __s._M_data(_M_data());
                _M_data(this->_M_local_buf);
            } else {
                std::basic_string::pointer __tmp_ptr = _M_data();
                _M_data(__s._M_data());
                __s._M_data(__tmp_ptr);
                this->_M_capacity(__s._M_allocated_capacity);
            }
            __s._M_capacity(__tmp_capacity);
        }
        const std::basic_string::size_type __tmp_length = this->length();
        this->_M_length(__s.length());
        __s._M_length(__tmp_length);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::pointer basic_string<_CharT, _Traits, _Alloc>::_M_create(std::basic_string::size_type &__capacity, std::basic_string::size_type __old_capacity) {
        if (__capacity > this->max_size())
            std::__throw_length_error(("basic_string::_M_create"));
        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
            __capacity = 2 * __old_capacity;
            if (__capacity > this->max_size())
                __capacity = this->max_size();
        }
        return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag) {
        std::basic_string::size_type __len = 0;
        std::basic_string::size_type __capacity = std::basic_string::size_type(_S_local_capacity);
        std::basic_string::pointer __p = this->_M_use_local_data();
        while (__beg != __end && __len < __capacity)
            {
                __p[__len++] = *__beg;
                ++__beg;
            }
        struct _Guard {
            explicit _Guard(basic_string<_CharT, _Traits, _Alloc> *__s) : _M_guarded(__s) {
            }
            ~_Guard() {
                if (this->_M_guarded)
                    this->_M_guarded->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> *_M_guarded;
        } __guard(this);
        while (__beg != __end)
            {
                if (__len == __capacity) {
                    __capacity = __len + 1;
                    std::basic_string::pointer __another = this->_M_create(__capacity, __len);
                    this->_S_copy(__another, _M_data(), __len);
                    this->_M_dispose();
                    _M_data(__another);
                    this->_M_capacity(__capacity);
                }
                traits_type::assign(_M_data()[__len++], *__beg);
                ++__beg;
            }
        __guard._M_guarded = 0;
        this->_M_set_length(__len);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::forward_iterator_tag) {
        std::basic_string::size_type __dnew = static_cast<std::basic_string::size_type>(std::distance(__beg, __end));
        if (__dnew > std::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__dnew, std::basic_string::size_type(0)));
            this->_M_capacity(__dnew);
        } else
            this->_M_use_local_data();
        struct _Guard {
            explicit _Guard(basic_string<_CharT, _Traits, _Alloc> *__s) : _M_guarded(__s) {
            }
            ~_Guard() {
                if (this->_M_guarded)
                    this->_M_guarded->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> *_M_guarded;
        } __guard(this);
        this->_S_copy_chars(_M_data(), __beg, __end);
        __guard._M_guarded = 0;
        this->_M_set_length(__dnew);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(std::basic_string::size_type __n, _CharT __c) {
        if (__n > std::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__n, std::basic_string::size_type(0)));
            this->_M_capacity(__n);
        } else
            this->_M_use_local_data();
        if (__n)
            this->_S_assign(_M_data(), __n, __c);
        this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_assign(const basic_string<_CharT, _Traits, _Alloc> &__str) {
        if (this != std::__addressof(__str)) {
            const std::basic_string::size_type __rsize = __str.length();
            const std::basic_string::size_type __capacity = this->capacity();
            if (__rsize > __capacity) {
                std::basic_string::size_type __new_capacity = __rsize;
                std::basic_string::pointer __tmp = this->_M_create(__new_capacity, __capacity);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__new_capacity);
            }
            if (__rsize)
                this->_S_copy(_M_data(), __str._M_data(), __rsize);
            this->_M_set_length(__rsize);
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::reserve(std::basic_string::size_type __res) {
        const std::basic_string::size_type __capacity = this->capacity();
        if (__res <= __capacity)
            return;
        std::basic_string::pointer __tmp = this->_M_create(__res, __capacity);
        this->_S_copy(__tmp, _M_data(), this->length() + 1);
        this->_M_dispose();
        _M_data(__tmp);
        this->_M_capacity(__res);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(std::basic_string::size_type __pos, std::basic_string::size_type __len1, const _CharT *__s, std::basic_string::size_type __len2) {
        const std::basic_string::size_type __how_much = this->length() - __pos - __len1;
        std::basic_string::size_type __new_capacity = this->length() + __len2 - __len1;
        std::basic_string::pointer __r = this->_M_create(__new_capacity, this->capacity());
        if (__pos)
            this->_S_copy(__r, _M_data(), __pos);
        if (__s && __len2)
            this->_S_copy(__r + __pos, __s, __len2);
        if (__how_much)
            this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1, __how_much);
        this->_M_dispose();
        _M_data(__r);
        this->_M_capacity(__new_capacity);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_erase(std::basic_string::size_type __pos, std::basic_string::size_type __n) {
        const std::basic_string::size_type __how_much = this->length() - __pos - __n;
        if (__how_much && __n)
            this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
        this->_M_set_length(this->length() - __n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::reserve() {
        if (this->_M_is_local())
            return;
        const std::basic_string::size_type __length = this->length();
        const std::basic_string::size_type __capacity = this->_M_allocated_capacity;
        if (__length <= std::basic_string::size_type(_S_local_capacity)) {
            this->_S_copy(this->_M_use_local_data(), _M_data(), __length + 1);
            this->_M_destroy(__capacity);
            _M_data(_M_local_data());
        } else if (__length < __capacity)
            try {
                std::basic_string::pointer __tmp = _Alloc_traits::allocate(_M_get_allocator(), __length + 1);
                this->_S_copy(__tmp, _M_data(), __length + 1);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__length);
            } catch (const __cxxabiv1::__forced_unwind &) {
                throw;
            } catch (...) {
            }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::resize(std::basic_string::size_type __n, _CharT __c) {
        const std::basic_string::size_type __size = this->size();
        if (__size < __n)
            this->append(__n - __size, __c);
        else if (__n < __size)
            this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s, std::basic_string::size_type __n) {
        const std::basic_string::size_type __len = __n + this->size();
        if (__len <= this->capacity()) {
            if (__n)
                this->_S_copy(this->_M_data() + this->size(), __s, __n);
        } else
            this->_M_mutate(this->size(), std::basic_string::size_type(0), __s, __n);
        this->_M_set_length(__len);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InputIterator> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(std::basic_string::const_iterator __i1, std::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type) {
        const basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2, this->get_allocator());
        const std::basic_string::size_type __n1 = __i2 - __i1;
        return this->_M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(std::basic_string::size_type __pos1, std::basic_string::size_type __n1, std::basic_string::size_type __n2, _CharT __c) {
        this->_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
        const std::basic_string::size_type __old_size = this->size();
        const std::basic_string::size_type __new_size = __old_size + __n2 - __n1;
        if (__new_size <= this->capacity()) {
            std::basic_string::pointer __p = this->_M_data() + __pos1;
            const std::basic_string::size_type __how_much = __old_size - __pos1 - __n1;
            if (__how_much && __n1 != __n2)
                this->_S_move(__p + __n2, __p + __n1, __how_much);
        } else
            this->_M_mutate(__pos1, __n1, 0, __n2);
        if (__n2)
            this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace(std::basic_string::size_type __pos, std::basic_string::size_type __len1, const _CharT *__s, const std::basic_string::size_type __len2) {
        this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
        const std::basic_string::size_type __old_size = this->size();
        const std::basic_string::size_type __new_size = __old_size + __len2 - __len1;
        if (__new_size <= this->capacity()) {
            std::basic_string::pointer __p = this->_M_data() + __pos;
            const std::basic_string::size_type __how_much = __old_size - __pos - __len1;
            if (this->_M_disjunct(__s)) {
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2)
                    this->_S_copy(__p, __s, __len2);
            } else {
                if (__len2 && __len2 <= __len1)
                    this->_S_move(__p, __s, __len2);
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2 > __len1) {
                    if (__s + __len2 <= __p + __len1)
                        this->_S_move(__p, __s, __len2);
                    else if (__s >= __p + __len1) {
                        const std::basic_string::size_type __poff = (__s - __p) + (__len2 - __len1);
                        this->_S_copy(__p, __p + __poff, __len2);
                    } else {
                        const std::basic_string::size_type __nleft = (__p + __len1) - __s;
                        this->_S_move(__p, __s, __nleft);
                        this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                    }
                }
            }
        } else
            this->_M_mutate(__pos, __len1, __s, __len2);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, std::basic_string::size_type __n, std::basic_string::size_type __pos = 0) const {
        this->_M_check(__pos, "basic_string::copy");
        __n = this->_M_limit(__pos, __n);
        ;
        if (__n)
            _S_copy(__s, _M_data() + __pos, __n);
        return __n;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        ;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        const __size_type __len = _Traits::length(__lhs);
        __string_type __str(_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
        __str.reserve(__len + __rhs.size());
        __str.append(__lhs, __len);
        __str.append(__rhs);
        return __str;
    }
    template<> basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        __string_type __str(_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
        const __size_type __len = __rhs.size();
        __str.reserve(__len + 1);
        __str.append(__size_type(1), __lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept {
        ;
        const std::basic_string::size_type __size = this->size();
        if (__n == 0)
            return __pos <= __size ? __pos : npos;
        if (__pos >= __size)
            return npos;
        const _CharT __elem0 = __s[0];
        const _CharT *const __data = this->data();
        const _CharT *__first = __data + __pos;
        const _CharT *const __last = __data + __size;
        std::basic_string::size_type __len = __size - __pos;
        while (__len >= __n)
            {
                __first = traits_type::find(__first, __len - __n + 1, __elem0);
                if (!__first)
                    return npos;
                if (traits_type::compare(__first, __s, __n) == 0)
                    return __first - __data;
                __len = __last - ++__first;
            }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, std::basic_string::size_type __pos = 0) const noexcept {
        std::basic_string::size_type __ret = npos;
        const std::basic_string::size_type __size = this->size();
        if (__pos < __size) {
            const _CharT *__data = _M_data();
            const std::basic_string::size_type __n = __size - __pos;
            const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
            if (__p)
                __ret = __p - __data;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept {
        ;
        const std::basic_string::size_type __size = this->size();
        if (__n <= __size) {
            __pos = std::min(std::basic_string::size_type(__size - __n), __pos);
            const _CharT *__data = _M_data();
            do {
                if (traits_type::compare(__data + __pos, __s, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, std::basic_string::size_type __pos = npos) const noexcept {
        std::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(_M_data()[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept {
        ;
        for (; __n && __pos < this->size(); ++__pos) {
            const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept {
        ;
        std::basic_string::size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept {
        ;
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::find(__s, __n, _M_data()[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, std::basic_string::size_type __pos = 0) const noexcept {
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::eq(_M_data()[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, std::basic_string::size_type __pos, std::basic_string::size_type __n) const noexcept {
        ;
        std::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, std::basic_string::size_type __pos = npos) const noexcept {
        std::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(_M_data()[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::basic_string::size_type __pos, std::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const {
        this->_M_check(__pos, "basic_string::compare");
        __n = this->_M_limit(__pos, __n);
        const std::basic_string::size_type __osize = __str.size();
        const std::basic_string::size_type __len = std::min(__n, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
        if (!__r)
            __r = _S_compare(__n, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::basic_string::size_type __pos1, std::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::basic_string::size_type __pos2, std::basic_string::size_type __n2 = npos) const {
        this->_M_check(__pos1, "basic_string::compare");
        __str._M_check(__pos2, "basic_string::compare");
        __n1 = this->_M_limit(__pos1, __n1);
        __n2 = __str._M_limit(__pos2, __n2);
        const std::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const noexcept {
        ;
        const std::basic_string::size_type __size = this->size();
        const std::basic_string::size_type __osize = traits_type::length(__s);
        const std::basic_string::size_type __len = std::min(__size, __osize);
        int __r = traits_type::compare(_M_data(), __s, __len);
        if (!__r)
            __r = _S_compare(__size, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::basic_string::size_type __pos, std::basic_string::size_type __n1, const _CharT *__s) const {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::basic_string::size_type __osize = traits_type::length(__s);
        const std::basic_string::size_type __len = std::min(__n1, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::basic_string::size_type __pos, std::basic_string::size_type __n1, const _CharT *__s, std::basic_string::size_type __n2) const {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        typedef ctype<_CharT> __ctype_type;
        typedef typename __ctype_type::ctype_base __ctype_base;
        __size_type __extracted = 0;
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                __str.erase();
                _CharT __buf[128];
                __size_type __len = 0;
                const std::streamsize __w = __in.width();
                const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        if (__len == sizeof (__buf) / sizeof(_CharT)) {
                            __str.append(__buf, sizeof (__buf) / sizeof(_CharT));
                            __len = 0;
                        }
                        __buf[__len++] = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                __str.append(__buf, __len);
                if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        __size_type __extracted = 0;
        const __size_type __n = __str.max_size();
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            try {
                __str.erase();
                const __int_type __idelim = _Traits::to_int_type(__delim);
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !_Traits::eq_int_type(__c, __idelim))
                    {
                        __str += _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                else if (_Traits::eq_int_type(__c, __idelim)) {
                    ++__extracted;
                    __in.rdbuf()->sbumpc();
                } else
                    __err |= __ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template<> class basic_string<char> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<char>>::rebind<char>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<char> traits_type;
        typedef typename char_traits<char>::char_type value_type;
        typedef std::basic_string<char>::_Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char>> iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char>> const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const std::basic_string<char>::size_type npos = static_cast<std::basic_string<char>::size_type>(-1);
    protected:
        typedef std::basic_string<char>::const_iterator __const_iterator;
    private:
        struct _Alloc_hider : std::basic_string<char>::allocator_type {
            _Alloc_hider(std::basic_string<char>::pointer __dat, const std::allocator<char> &__a) : std::basic_string<char>::allocator_type(__a), _M_p(__dat) {
            }
            _Alloc_hider(std::basic_string<char>::pointer __dat, std::allocator<char> &&__a = std::allocator<char>()) : std::basic_string<char>::allocator_type(std::move(__a)), _M_p(__dat) {
            }
            std::basic_string<char>::pointer _M_p;
        };
        std::basic_string<char>::_Alloc_hider _M_dataplus;
        std::basic_string<char>::size_type _M_string_length;
        enum {
            _S_local_capacity = 15 / sizeof(char)
        };
        union {
            char _M_local_buf[16];
            std::basic_string<char>::size_type _M_allocated_capacity;
        };
        void _M_data(std::basic_string<char>::pointer __p) {
            this->_M_dataplus._M_p = __p;
        }
        void _M_length(std::basic_string<char>::size_type __length) {
            this->_M_string_length = __length;
        }
        std::basic_string<char>::pointer _M_data() const {
            return this->_M_dataplus._M_p;
        }
        std::basic_string<char>::pointer _M_local_data() {
            return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
        }
        std::basic_string<char>::const_pointer _M_local_data() const {
            return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
        }
        void _M_capacity(std::basic_string<char>::size_type __capacity) {
            this->_M_allocated_capacity = __capacity;
        }
        void _M_set_length(std::basic_string<char>::size_type __n) {
            this->_M_length(__n);
            traits_type::assign(this->_M_data()[__n], char());
        }
        bool _M_is_local() const {
            return this->_M_data() == this->_M_local_data();
        }
        std::basic_string<char>::pointer _M_create(std::basic_string<char>::size_type &, std::basic_string<char>::size_type);
        void _M_dispose() {
            if (!this->_M_is_local())
                this->_M_destroy(this->_M_allocated_capacity);
        }
        void _M_destroy(std::basic_string<char>::size_type __size) throw() {
            _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
        }
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template<> void _M_construct<char *>(char *__beg, char *__end, std::input_iterator_tag);
        template<> void _M_construct<const char *>(const char *__beg, const char *__end, std::input_iterator_tag);
        template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        template<> void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<char *>(char *__beg, char *__end, std::forward_iterator_tag) {
            std::basic_string<char>::size_type __dnew = static_cast<std::basic_string<char>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::basic_string<char>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::basic_string<char>::size_type(0)));
                this->_M_capacity(__dnew);
            } else
                this->_M_use_local_data();
            struct _Guard {
                basic_string<char> *_M_guarded;
            } __guard(this);
            this->_S_copy_chars(this->_M_data(), __beg, __end);
            __guard._M_guarded = 0;
            this->_M_set_length(__dnew);
        }
;
        template<> void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<const char *>(const char *__beg, const char *__end, std::forward_iterator_tag) {
            std::basic_string<char>::size_type __dnew = static_cast<std::basic_string<char>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::basic_string<char>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::basic_string<char>::size_type(0)));
                this->_M_capacity(__dnew);
            } else
                this->_M_use_local_data();
            struct _Guard {
                basic_string<char> *_M_guarded;
            } __guard(this);
            this->_S_copy_chars(this->_M_data(), __beg, __end);
            __guard._M_guarded = 0;
            this->_M_set_length(__dnew);
        }
;
        void _M_construct(std::basic_string<char>::size_type __req, char __c);
        std::basic_string<char>::allocator_type &_M_get_allocator() {
            return this->_M_dataplus;
        }
        const std::basic_string<char>::allocator_type &_M_get_allocator() const {
            return this->_M_dataplus;
        }
        constexpr std::basic_string<char>::pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
            return this->_M_local_data();
        }
    private:
        std::basic_string<char>::size_type _M_check(std::basic_string<char>::size_type __pos, const char *__s) const {
            if (__pos > this->size())
                __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
            return __pos;
        }
        void _M_check_length(std::basic_string<char>::size_type __n1, std::basic_string<char>::size_type __n2, const char *__s) const {
            if (this->max_size() - (this->size() - __n1) < __n2)
                __throw_length_error((__s));
        }
        std::basic_string<char>::size_type _M_limit(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __off) const noexcept {
            const bool __testoff = __off < this->size() - __pos;
            return __testoff ? __off : this->size() - __pos;
        }
        bool _M_disjunct(const char *__s) const noexcept;
        static void _S_copy(char *__d, const char *__s, std::basic_string<char>::size_type __n) {
            if (__n == 1)
                traits_type::assign(*__d, *__s);
            else
                traits_type::copy(__d, __s, __n);
        }
        static void _S_move(char *__d, const char *__s, std::basic_string<char>::size_type __n);
        static void _S_assign(char *__d, std::basic_string<char>::size_type __n, char __c);
        template <class _Iterator> static void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
        template<> static void _S_copy_chars<char *>(char *__p, char *__k1, char *__k2);
        template<> static void _S_copy_chars<const char *>(char *__p, const char *__k1, const char *__k2);
        static void _S_copy_chars(char *__p, std::basic_string<char>::iterator __k1, std::basic_string<char>::iterator __k2) noexcept;
        static void _S_copy_chars(char *__p, std::basic_string<char>::const_iterator __k1, std::basic_string<char>::const_iterator __k2) noexcept;
        static void _S_copy_chars(char *__p, char *__k1, char *__k2) noexcept {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static void _S_copy_chars(char *__p, const char *__k1, const char *__k2) noexcept {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static int _S_compare(std::basic_string<char>::size_type __n1, std::basic_string<char>::size_type __n2) noexcept;
        void _M_assign(const std::basic_string<char> &);
        void _M_mutate(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __len1, const char *__s, std::basic_string<char>::size_type __len2);
        void _M_erase(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n);
    public:
        basic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::value) : _M_dataplus(this->_M_local_data()) {
            this->_M_use_local_data();
            this->_M_set_length(0);
        }
        explicit basic_string(const std::allocator<char> &__a) noexcept : _M_dataplus(this->_M_local_data(), __a) {
            this->_M_use_local_data();
            this->_M_set_length(0);
        }
        basic_string(const std::basic_string<char> &__str) : _M_dataplus(this->_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator())) {
            this->_M_construct(__str._M_data(), __str._M_data() + __str.length(), std::forward_iterator_tag());
        }
        basic_string(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos, const std::allocator<char> &__a);
        basic_string(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n);
        basic_string(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n, const std::allocator<char> &__a);
        basic_string(const char *__s, std::basic_string<char>::size_type __n, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
            if (__s == 0 && __n > 0)
                std::__throw_logic_error(("basic_string: construction from null is not valid"));
            this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
        }
        basic_string(const char *__s, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
            if (__s == 0)
                std::__throw_logic_error(("basic_string: construction from null is not valid"));
            const char *__end = __s + traits_type::length(__s);
            this->_M_construct(__s, __end, std::forward_iterator_tag());
        }
        basic_string(std::basic_string<char>::size_type __n, char __c, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
            this->_M_construct(__n, __c);
        }
        basic_string(std::basic_string<char> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
            if (__str._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
            } else {
                this->_M_data(__str._M_data());
                this->_M_capacity(__str._M_allocated_capacity);
            }
            this->_M_length(__str.length());
            __str._M_data(__str._M_local_data());
            __str._M_set_length(0);
        }
        basic_string(initializer_list<char> __l, const std::allocator<char> &__a);
        basic_string(const std::basic_string<char> &__str, const std::allocator<char> &__a);
        basic_string(std::basic_string<char> &&__str, const std::allocator<char> &__a);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
        template<> basic_string<char *, void>(char *__beg, char *__end, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
            this->_M_construct(__beg, __end, std::__iterator_category(__beg));
        }
;
        ~basic_string<char>() noexcept {
            this->_M_dispose();
        }
        std::basic_string<char> &operator=(const std::basic_string<char> &__str) {
            return this->assign(__str);
        }
        std::basic_string<char> &operator=(const char *__s);
        std::basic_string<char> &operator=(char __c);
        std::basic_string<char> &operator=(std::basic_string<char> &&__str);
        std::basic_string<char> &operator=(initializer_list<char> __l);
        std::basic_string<char>::iterator begin() noexcept {
            return std::basic_string<char>::iterator(this->_M_data());
        }
        std::basic_string<char>::const_iterator begin() const noexcept;
        std::basic_string<char>::iterator end() noexcept {
            return std::basic_string<char>::iterator(this->_M_data() + this->size());
        }
        std::basic_string<char>::const_iterator end() const noexcept;
        std::basic_string<char>::reverse_iterator rbegin() noexcept;
        std::basic_string<char>::const_reverse_iterator rbegin() const noexcept;
        std::basic_string<char>::reverse_iterator rend() noexcept;
        std::basic_string<char>::const_reverse_iterator rend() const noexcept;
        std::basic_string<char>::const_iterator cbegin() const noexcept;
        std::basic_string<char>::const_iterator cend() const noexcept;
        std::basic_string<char>::const_reverse_iterator crbegin() const noexcept;
        std::basic_string<char>::const_reverse_iterator crend() const noexcept;
    public:
        std::basic_string<char>::size_type size() const noexcept {
            return this->_M_string_length;
        }
        std::basic_string<char>::size_type length() const noexcept {
            return this->_M_string_length;
        }
        std::basic_string<char>::size_type max_size() const noexcept {
            return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
        }
        void resize(std::basic_string<char>::size_type __n, char __c);
        void resize(std::basic_string<char>::size_type __n);
        void shrink_to_fit() noexcept;
        std::basic_string<char>::size_type capacity() const noexcept {
            return this->_M_is_local() ? std::basic_string<char>::size_type(_S_local_capacity) : this->_M_allocated_capacity;
        }
        void reserve(std::basic_string<char>::size_type __res_arg);
        void reserve();
        void clear() noexcept;
        bool empty() const noexcept;
        std::basic_string<char>::const_reference operator[](std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::reference operator[](std::basic_string<char>::size_type __pos) {
            do {
                if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                    __builtin_unreachable();
            } while (false);
            ;
            return this->_M_data()[__pos];
        }
        std::basic_string<char>::const_reference at(std::basic_string<char>::size_type __n) const;
        std::basic_string<char>::reference at(std::basic_string<char>::size_type __n);
        std::basic_string<char>::reference front() noexcept;
        std::basic_string<char>::const_reference front() const noexcept;
        std::basic_string<char>::reference back() noexcept;
        std::basic_string<char>::const_reference back() const noexcept;
        std::basic_string<char> &operator+=(const std::basic_string<char> &__str);
        std::basic_string<char> &operator+=(const char *__s);
        std::basic_string<char> &operator+=(char __c);
        std::basic_string<char> &operator+=(initializer_list<char> __l);
        std::basic_string<char> &append(const std::basic_string<char> &__str) {
            return this->append(__str._M_data(), __str.size());
        }
        std::basic_string<char> &append(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n);
        std::basic_string<char> &append(const char *__s, std::basic_string<char>::size_type __n) {
            ;
            this->_M_check_length(std::basic_string<char>::size_type(0), __n, "basic_string::append");
            return this->_M_append(__s, __n);
        }
        std::basic_string<char> &append(const char *__s) {
            ;
            const std::basic_string<char>::size_type __n = traits_type::length(__s);
            this->_M_check_length(std::basic_string<char>::size_type(0), __n, "basic_string::append");
            return this->_M_append(__s, __n);
        }
        std::basic_string<char> &append(std::basic_string<char>::size_type __n, char __c);
        std::basic_string<char> &append(initializer_list<char> __l);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char> &append(_InputIterator __first, _InputIterator __last);
        void push_back(char __c);
        std::basic_string<char> &assign(const std::basic_string<char> &__str) {
            if (_Alloc_traits::_S_propagate_on_copy_assign()) {
                if (!_Alloc_traits::_S_always_equal() && !this->_M_is_local() && this->_M_get_allocator() != __str._M_get_allocator()) {
                    if (__str.size() <= _S_local_capacity) {
                        this->_M_destroy(this->_M_allocated_capacity);
                        this->_M_data(this->_M_use_local_data());
                        this->_M_set_length(0);
                    } else {
                        const auto __len = __str.size();
                        auto __alloc = __str._M_get_allocator();
                        auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
                        this->_M_destroy(this->_M_allocated_capacity);
                        this->_M_data(__ptr);
                        this->_M_capacity(__len);
                        this->_M_set_length(__len);
                    }
                }
                std::__alloc_on_copy(this->_M_get_allocator(), __str._M_get_allocator());
            }
            this->_M_assign(__str);
            return *this;
        }
        std::basic_string<char> &assign(std::basic_string<char> &&__str);
        std::basic_string<char> &assign(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n);
        std::basic_string<char> &assign(const char *__s, std::basic_string<char>::size_type __n);
        std::basic_string<char> &assign(const char *__s);
        std::basic_string<char> &assign(std::basic_string<char>::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
        template<> std::basic_string<char> &assign<char *, void>(char *__first, char *__last) {
            return this->replace(this->begin(), this->end(), __first, __last);
        }
;
        std::basic_string<char> &assign(initializer_list<char> __l);
        std::basic_string<char>::iterator insert(std::basic_string<char>::const_iterator __p, std::basic_string<char>::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char>::iterator insert(std::basic_string<char>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
        std::basic_string<char>::iterator insert(std::basic_string<char>::const_iterator __p, initializer_list<char> __l);
        std::basic_string<char> &insert(std::basic_string<char>::size_type __pos1, const std::basic_string<char> &__str) {
            return this->replace(__pos1, std::basic_string<char>::size_type(0), __str._M_data(), __str.size());
        }
        std::basic_string<char> &insert(std::basic_string<char>::size_type __pos1, const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos2, std::basic_string<char>::size_type __n);
        std::basic_string<char> &insert(std::basic_string<char>::size_type __pos, const char *__s, std::basic_string<char>::size_type __n);
        std::basic_string<char> &insert(std::basic_string<char>::size_type __pos, const char *__s) {
            ;
            return this->replace(__pos, std::basic_string<char>::size_type(0), __s, traits_type::length(__s));
        }
        std::basic_string<char> &insert(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n, char __c);
        std::basic_string<char>::iterator insert(std::basic_string<char>::__const_iterator __p, char __c);
        std::basic_string<char> &erase(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n);
        std::basic_string<char>::iterator erase(std::basic_string<char>::__const_iterator __position);
        std::basic_string<char>::iterator erase(std::basic_string<char>::__const_iterator __first, std::basic_string<char>::__const_iterator __last);
        void pop_back() noexcept;
        std::basic_string<char> &replace(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n, const std::basic_string<char> &__str);
        std::basic_string<char> &replace(std::basic_string<char>::size_type __pos1, std::basic_string<char>::size_type __n1, const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos2, std::basic_string<char>::size_type __n2);
        std::basic_string<char> &replace(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n1, const char *__s, std::basic_string<char>::size_type __n2) {
            ;
            return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
        }
        std::basic_string<char> &replace(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n1, const char *__s);
        std::basic_string<char> &replace(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n1, std::basic_string<char>::size_type __n2, char __c);
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, const std::basic_string<char> &__str);
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, const char *__s, std::basic_string<char>::size_type __n);
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, const char *__s);
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, std::basic_string<char>::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<char> &replace(std::basic_string<char>::const_iterator __i1, std::basic_string<char>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
        template<> std::basic_string<char> &replace<char *, void>(std::basic_string<char>::const_iterator __i1, std::basic_string<char>::const_iterator __i2, char *__k1, char *__k2);
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, char *__k1, char *__k2) {
            ;
            ;
            return this->replace(__i1 - this->begin(), __i2 - __i1, __k1, __k2 - __k1);
        }
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, const char *__k1, const char *__k2);
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, std::basic_string<char>::iterator __k1, std::basic_string<char>::iterator __k2);
        std::basic_string<char> &replace(std::basic_string<char>::__const_iterator __i1, std::basic_string<char>::__const_iterator __i2, std::basic_string<char>::const_iterator __k1, std::basic_string<char>::const_iterator __k2);
        std::basic_string<char> &replace(std::basic_string<char>::const_iterator __i1, std::basic_string<char>::const_iterator __i2, initializer_list<char> __l);
    private:
        template <class _Integer> std::basic_string<char> &_M_replace_dispatch(std::basic_string<char>::const_iterator __i1, std::basic_string<char>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::basic_string<char> &_M_replace_dispatch(std::basic_string<char>::const_iterator __i1, std::basic_string<char>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::basic_string<char> &_M_replace_aux(std::basic_string<char>::size_type __pos1, std::basic_string<char>::size_type __n1, std::basic_string<char>::size_type __n2, char __c);
        std::basic_string<char> &_M_replace(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __len1, const char *__s, const std::basic_string<char>::size_type __len2);
        std::basic_string<char> &_M_append(const char *__s, std::basic_string<char>::size_type __n);
    public:
        std::basic_string<char>::size_type copy(char *__s, std::basic_string<char>::size_type __n, std::basic_string<char>::size_type __pos = 0) const;
        void swap(std::basic_string<char> &__s) noexcept;
        const char *c_str() const noexcept {
            return this->_M_data();
        }
        const char *data() const noexcept {
            return this->_M_data();
        }
        std::basic_string<char>::allocator_type get_allocator() const noexcept {
            return this->_M_get_allocator();
        }
        std::basic_string<char>::size_type find(const char *__s, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n) const noexcept;
        std::basic_string<char>::size_type find(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find(const char *__s, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find(char __c, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type rfind(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type rfind(const char *__s, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n) const noexcept;
        std::basic_string<char>::size_type rfind(const char *__s, std::basic_string<char>::size_type __pos) const;
        std::basic_string<char>::size_type rfind(char __c, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_first_of(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_first_of(const char *__s, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n) const noexcept;
        std::basic_string<char>::size_type find_first_of(const char *__s, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_first_of(char __c, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_last_of(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_last_of(const char *__s, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n) const noexcept;
        std::basic_string<char>::size_type find_last_of(const char *__s, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_last_of(char __c, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_first_not_of(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_first_not_of(const char *__s, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n) const noexcept;
        std::basic_string<char>::size_type find_first_not_of(const char *__s, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_first_not_of(char __c, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_last_not_of(const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_last_not_of(const char *__s, std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n) const noexcept;
        std::basic_string<char>::size_type find_last_not_of(const char *__s, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char>::size_type find_last_not_of(char __c, std::basic_string<char>::size_type __pos) const noexcept;
        std::basic_string<char> substr(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n) const;
        int compare(const std::basic_string<char> &__str) const;
        int compare(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n, const std::basic_string<char> &__str) const;
        int compare(std::basic_string<char>::size_type __pos1, std::basic_string<char>::size_type __n1, const std::basic_string<char> &__str, std::basic_string<char>::size_type __pos2, std::basic_string<char>::size_type __n2) const;
        int compare(const char *__s) const noexcept;
        int compare(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n1, const char *__s) const;
        int compare(std::basic_string<char>::size_type __pos, std::basic_string<char>::size_type __n1, const char *__s, std::basic_string<char>::size_type __n2) const;
        friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
    };
    template<> class basic_string<wchar_t> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t>>::rebind<wchar_t>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename char_traits<wchar_t>::char_type value_type;
        typedef std::basic_string<wchar_t>::_Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t>> iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t>> const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const std::basic_string<wchar_t>::size_type npos = static_cast<std::basic_string<wchar_t>::size_type>(-1);
    protected:
        typedef std::basic_string<wchar_t>::const_iterator __const_iterator;
    private:
        struct _Alloc_hider : std::basic_string<wchar_t>::allocator_type {
            _Alloc_hider(std::basic_string<wchar_t>::pointer __dat, const std::allocator<wchar_t> &__a) : std::basic_string<wchar_t>::allocator_type(__a), _M_p(__dat) {
            }
            _Alloc_hider(std::basic_string<wchar_t>::pointer __dat, std::allocator<wchar_t> &&__a) : std::basic_string<wchar_t>::allocator_type(std::move(__a)), _M_p(__dat) {
            }
            std::basic_string<wchar_t>::pointer _M_p;
        };
        std::basic_string<wchar_t>::_Alloc_hider _M_dataplus;
        std::basic_string<wchar_t>::size_type _M_string_length;
        enum {
            _S_local_capacity = 15 / sizeof(wchar_t)
        };
        union {
            wchar_t _M_local_buf[4];
            std::basic_string<wchar_t>::size_type _M_allocated_capacity;
        };
        void _M_data(std::basic_string<wchar_t>::pointer __p) {
            this->_M_dataplus._M_p = __p;
        }
        void _M_length(std::basic_string<wchar_t>::size_type __length) {
            this->_M_string_length = __length;
        }
        std::basic_string<wchar_t>::pointer _M_data() const {
            return this->_M_dataplus._M_p;
        }
        std::basic_string<wchar_t>::pointer _M_local_data() {
            return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
        }
        std::basic_string<wchar_t>::const_pointer _M_local_data() const {
            return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
        }
        void _M_capacity(std::basic_string<wchar_t>::size_type __capacity) {
            this->_M_allocated_capacity = __capacity;
        }
        void _M_set_length(std::basic_string<wchar_t>::size_type __n) {
            this->_M_length(__n);
            traits_type::assign(this->_M_data()[__n], wchar_t());
        }
        bool _M_is_local() const {
            return this->_M_data() == this->_M_local_data();
        }
        std::basic_string<wchar_t>::pointer _M_create(std::basic_string<wchar_t>::size_type &, std::basic_string<wchar_t>::size_type);
        void _M_dispose() {
            if (!this->_M_is_local())
                this->_M_destroy(this->_M_allocated_capacity);
        }
        void _M_destroy(std::basic_string<wchar_t>::size_type __size) throw() {
            _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
        }
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template<> void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::input_iterator_tag);
        template<> void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::input_iterator_tag);
        template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        template<> void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::forward_iterator_tag) {
            std::basic_string<wchar_t>::size_type __dnew = static_cast<std::basic_string<wchar_t>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::basic_string<wchar_t>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::basic_string<wchar_t>::size_type(0)));
                this->_M_capacity(__dnew);
            } else
                this->_M_use_local_data();
            struct _Guard {
                basic_string<wchar_t> *_M_guarded;
            } __guard(this);
            this->_S_copy_chars(this->_M_data(), __beg, __end);
            __guard._M_guarded = 0;
            this->_M_set_length(__dnew);
        }
;
        template<> void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::forward_iterator_tag) {
            std::basic_string<wchar_t>::size_type __dnew = static_cast<std::basic_string<wchar_t>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::basic_string<wchar_t>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::basic_string<wchar_t>::size_type(0)));
                this->_M_capacity(__dnew);
            } else
                this->_M_use_local_data();
            struct _Guard {
                basic_string<wchar_t> *_M_guarded;
            } __guard(this);
            this->_S_copy_chars(this->_M_data(), __beg, __end);
            __guard._M_guarded = 0;
            this->_M_set_length(__dnew);
        }
;
        void _M_construct(std::basic_string<wchar_t>::size_type __req, wchar_t __c);
        std::basic_string<wchar_t>::allocator_type &_M_get_allocator() {
            return this->_M_dataplus;
        }
        const std::basic_string<wchar_t>::allocator_type &_M_get_allocator() const;
        constexpr std::basic_string<wchar_t>::pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
            return this->_M_local_data();
        }
    private:
        std::basic_string<wchar_t>::size_type _M_check(std::basic_string<wchar_t>::size_type __pos, const char *__s) const;
        void _M_check_length(std::basic_string<wchar_t>::size_type __n1, std::basic_string<wchar_t>::size_type __n2, const char *__s) const;
        std::basic_string<wchar_t>::size_type _M_limit(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __off) const noexcept;
        bool _M_disjunct(const wchar_t *__s) const noexcept;
        static void _S_copy(wchar_t *__d, const wchar_t *__s, std::basic_string<wchar_t>::size_type __n) {
            if (__n == 1)
                traits_type::assign(*__d, *__s);
            else
                traits_type::copy(__d, __s, __n);
        }
        static void _S_move(wchar_t *__d, const wchar_t *__s, std::basic_string<wchar_t>::size_type __n);
        static void _S_assign(wchar_t *__d, std::basic_string<wchar_t>::size_type __n, wchar_t __c);
        template <class _Iterator> static void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
        template<> static void _S_copy_chars<wchar_t *>(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
        template<> static void _S_copy_chars<const wchar_t *>(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
        static void _S_copy_chars(wchar_t *__p, std::basic_string<wchar_t>::iterator __k1, std::basic_string<wchar_t>::iterator __k2) noexcept;
        static void _S_copy_chars(wchar_t *__p, std::basic_string<wchar_t>::const_iterator __k1, std::basic_string<wchar_t>::const_iterator __k2) noexcept;
        static void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2) noexcept {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2) noexcept {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static int _S_compare(std::basic_string<wchar_t>::size_type __n1, std::basic_string<wchar_t>::size_type __n2) noexcept;
        void _M_assign(const std::basic_string<wchar_t> &);
        void _M_mutate(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __len1, const wchar_t *__s, std::basic_string<wchar_t>::size_type __len2);
        void _M_erase(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n);
    public:
        basic_string();
        explicit basic_string(const std::allocator<wchar_t> &__a) noexcept;
        basic_string(const std::basic_string<wchar_t> &__str);
        basic_string(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos, const std::allocator<wchar_t> &__a);
        basic_string(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n);
        basic_string(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n, const std::allocator<wchar_t> &__a);
        basic_string(const wchar_t *__s, std::basic_string<wchar_t>::size_type __n, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a) {
            if (__s == 0 && __n > 0)
                std::__throw_logic_error(("basic_string: construction from null is not valid"));
            this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
        }
        basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
        basic_string(std::basic_string<wchar_t>::size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
        basic_string(std::basic_string<wchar_t> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
            if (__str._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
            } else {
                this->_M_data(__str._M_data());
                this->_M_capacity(__str._M_allocated_capacity);
            }
            this->_M_length(__str.length());
            __str._M_data(__str._M_local_data());
            __str._M_set_length(0);
        }
        basic_string(initializer_list<wchar_t> __l, const std::allocator<wchar_t> &__a);
        basic_string(const std::basic_string<wchar_t> &__str, const std::allocator<wchar_t> &__a);
        basic_string(std::basic_string<wchar_t> &&__str, const std::allocator<wchar_t> &__a);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
        template<> basic_string<wchar_t *, void>(wchar_t *__beg, wchar_t *__end, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a) {
            this->_M_construct(__beg, __end, std::__iterator_category(__beg));
        }
;
        ~basic_string<wchar_t>() noexcept {
            this->_M_dispose();
        }
        std::basic_string<wchar_t> &operator=(const std::basic_string<wchar_t> &__str);
        std::basic_string<wchar_t> &operator=(const wchar_t *__s);
        std::basic_string<wchar_t> &operator=(wchar_t __c);
        std::basic_string<wchar_t> &operator=(std::basic_string<wchar_t> &&__str);
        std::basic_string<wchar_t> &operator=(initializer_list<wchar_t> __l);
        std::basic_string<wchar_t>::iterator begin() noexcept;
        std::basic_string<wchar_t>::const_iterator begin() const noexcept;
        std::basic_string<wchar_t>::iterator end() noexcept;
        std::basic_string<wchar_t>::const_iterator end() const noexcept;
        std::basic_string<wchar_t>::reverse_iterator rbegin() noexcept;
        std::basic_string<wchar_t>::const_reverse_iterator rbegin() const noexcept;
        std::basic_string<wchar_t>::reverse_iterator rend() noexcept;
        std::basic_string<wchar_t>::const_reverse_iterator rend() const noexcept;
        std::basic_string<wchar_t>::const_iterator cbegin() const noexcept;
        std::basic_string<wchar_t>::const_iterator cend() const noexcept;
        std::basic_string<wchar_t>::const_reverse_iterator crbegin() const noexcept;
        std::basic_string<wchar_t>::const_reverse_iterator crend() const noexcept;
    public:
        std::basic_string<wchar_t>::size_type size() const noexcept;
        std::basic_string<wchar_t>::size_type length() const noexcept {
            return this->_M_string_length;
        }
        std::basic_string<wchar_t>::size_type max_size() const noexcept;
        void resize(std::basic_string<wchar_t>::size_type __n, wchar_t __c);
        void resize(std::basic_string<wchar_t>::size_type __n);
        void shrink_to_fit() noexcept;
        std::basic_string<wchar_t>::size_type capacity() const noexcept;
        void reserve(std::basic_string<wchar_t>::size_type __res_arg);
        void reserve();
        void clear() noexcept;
        bool empty() const noexcept;
        std::basic_string<wchar_t>::const_reference operator[](std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::reference operator[](std::basic_string<wchar_t>::size_type __pos);
        std::basic_string<wchar_t>::const_reference at(std::basic_string<wchar_t>::size_type __n) const;
        std::basic_string<wchar_t>::reference at(std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t>::reference front() noexcept;
        std::basic_string<wchar_t>::const_reference front() const noexcept;
        std::basic_string<wchar_t>::reference back() noexcept;
        std::basic_string<wchar_t>::const_reference back() const noexcept;
        std::basic_string<wchar_t> &operator+=(const std::basic_string<wchar_t> &__str);
        std::basic_string<wchar_t> &operator+=(const wchar_t *__s);
        std::basic_string<wchar_t> &operator+=(wchar_t __c);
        std::basic_string<wchar_t> &operator+=(initializer_list<wchar_t> __l);
        std::basic_string<wchar_t> &append(const std::basic_string<wchar_t> &__str);
        std::basic_string<wchar_t> &append(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t> &append(const wchar_t *__s, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t> &append(const wchar_t *__s);
        std::basic_string<wchar_t> &append(std::basic_string<wchar_t>::size_type __n, wchar_t __c);
        std::basic_string<wchar_t> &append(initializer_list<wchar_t> __l);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
        void push_back(wchar_t __c);
        std::basic_string<wchar_t> &assign(const std::basic_string<wchar_t> &__str);
        std::basic_string<wchar_t> &assign(std::basic_string<wchar_t> &&__str);
        std::basic_string<wchar_t> &assign(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t> &assign(const wchar_t *__s, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t> &assign(const wchar_t *__s);
        std::basic_string<wchar_t> &assign(std::basic_string<wchar_t>::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
        std::basic_string<wchar_t> &assign(initializer_list<wchar_t> __l);
        std::basic_string<wchar_t>::iterator insert(std::basic_string<wchar_t>::const_iterator __p, std::basic_string<wchar_t>::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<wchar_t>::iterator insert(std::basic_string<wchar_t>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
        std::basic_string<wchar_t>::iterator insert(std::basic_string<wchar_t>::const_iterator __p, initializer_list<wchar_t> __l);
        std::basic_string<wchar_t> &insert(std::basic_string<wchar_t>::size_type __pos1, const std::basic_string<wchar_t> &__str);
        std::basic_string<wchar_t> &insert(std::basic_string<wchar_t>::size_type __pos1, const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos2, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t> &insert(std::basic_string<wchar_t>::size_type __pos, const wchar_t *__s, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t> &insert(std::basic_string<wchar_t>::size_type __pos, const wchar_t *__s);
        std::basic_string<wchar_t> &insert(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n, wchar_t __c);
        std::basic_string<wchar_t>::iterator insert(std::basic_string<wchar_t>::__const_iterator __p, wchar_t __c);
        std::basic_string<wchar_t> &erase(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t>::iterator erase(std::basic_string<wchar_t>::__const_iterator __position);
        std::basic_string<wchar_t>::iterator erase(std::basic_string<wchar_t>::__const_iterator __first, std::basic_string<wchar_t>::__const_iterator __last);
        void pop_back() noexcept;
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n, const std::basic_string<wchar_t> &__str);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::size_type __pos1, std::basic_string<wchar_t>::size_type __n1, const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos2, std::basic_string<wchar_t>::size_type __n2);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n1, const wchar_t *__s, std::basic_string<wchar_t>::size_type __n2);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n1, const wchar_t *__s);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n1, std::basic_string<wchar_t>::size_type __n2, wchar_t __c);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, const std::basic_string<wchar_t> &__str);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, const wchar_t *__s, std::basic_string<wchar_t>::size_type __n);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, const wchar_t *__s);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, std::basic_string<wchar_t>::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::const_iterator __i1, std::basic_string<wchar_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, std::basic_string<wchar_t>::iterator __k1, std::basic_string<wchar_t>::iterator __k2);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::__const_iterator __i1, std::basic_string<wchar_t>::__const_iterator __i2, std::basic_string<wchar_t>::const_iterator __k1, std::basic_string<wchar_t>::const_iterator __k2);
        std::basic_string<wchar_t> &replace(std::basic_string<wchar_t>::const_iterator __i1, std::basic_string<wchar_t>::const_iterator __i2, initializer_list<wchar_t> __l);
    private:
        template <class _Integer> std::basic_string<wchar_t> &_M_replace_dispatch(std::basic_string<wchar_t>::const_iterator __i1, std::basic_string<wchar_t>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::basic_string<wchar_t> &_M_replace_dispatch(std::basic_string<wchar_t>::const_iterator __i1, std::basic_string<wchar_t>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::basic_string<wchar_t> &_M_replace_aux(std::basic_string<wchar_t>::size_type __pos1, std::basic_string<wchar_t>::size_type __n1, std::basic_string<wchar_t>::size_type __n2, wchar_t __c);
        std::basic_string<wchar_t> &_M_replace(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __len1, const wchar_t *__s, const std::basic_string<wchar_t>::size_type __len2);
        std::basic_string<wchar_t> &_M_append(const wchar_t *__s, std::basic_string<wchar_t>::size_type __n);
    public:
        std::basic_string<wchar_t>::size_type copy(wchar_t *__s, std::basic_string<wchar_t>::size_type __n, std::basic_string<wchar_t>::size_type __pos) const;
        void swap(std::basic_string<wchar_t> &__s) noexcept;
        const wchar_t *c_str() const noexcept {
            return this->_M_data();
        }
        const wchar_t *data() const noexcept {
            return this->_M_data();
        }
        std::basic_string<wchar_t>::allocator_type get_allocator() const noexcept;
        std::basic_string<wchar_t>::size_type find(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n) const noexcept;
        std::basic_string<wchar_t>::size_type find(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find(wchar_t __c, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type rfind(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type rfind(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n) const noexcept;
        std::basic_string<wchar_t>::size_type rfind(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos) const;
        std::basic_string<wchar_t>::size_type rfind(wchar_t __c, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_of(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_of(wchar_t __c, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_of(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_of(wchar_t __c, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_not_of(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_not_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_not_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_first_not_of(wchar_t __c, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_not_of(const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_not_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_not_of(const wchar_t *__s, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t>::size_type find_last_not_of(wchar_t __c, std::basic_string<wchar_t>::size_type __pos) const noexcept;
        std::basic_string<wchar_t> substr(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n) const;
        int compare(const std::basic_string<wchar_t> &__str) const;
        int compare(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n, const std::basic_string<wchar_t> &__str) const;
        int compare(std::basic_string<wchar_t>::size_type __pos1, std::basic_string<wchar_t>::size_type __n1, const std::basic_string<wchar_t> &__str, std::basic_string<wchar_t>::size_type __pos2, std::basic_string<wchar_t>::size_type __n2) const;
        int compare(const wchar_t *__s) const noexcept;
        int compare(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n1, const wchar_t *__s) const;
        int compare(std::basic_string<wchar_t>::size_type __pos, std::basic_string<wchar_t>::size_type __n1, const wchar_t *__s, std::basic_string<wchar_t>::size_type __n2) const;
        friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
    };
}
namespace std {
    class locale {
    public:
        typedef int category;
        class facet;
        class id;
        class _Impl;
        friend  class facet;
        friend  class _Impl;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
        static const std::locale::category none = 0;
        static const std::locale::category ctype = 1L << 0;
        static const std::locale::category numeric = 1L << 1;
        static const std::locale::category collate = 1L << 2;
        static const std::locale::category time = 1L << 3;
        static const std::locale::category monetary = 1L << 4;
        static const std::locale::category messages = 1L << 5;
        static const std::locale::category all = (ctype | numeric | collate | time | monetary | messages);
        locale() throw();
        locale(const std::locale &__other) throw();
        explicit locale(const char *__s);
        locale(const std::locale &__base, const char *__s, std::locale::category __cat);
        explicit locale(const std::string &__s) : NULL TYPE(__s.c_str()) {
        }
        locale(const std::locale &__base, const std::string &__s, std::locale::category __cat) : NULL TYPE(__base, __s.c_str(), __cat) {
        }
        locale(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        template <typename _Facet> locale(const std::locale &__other, _Facet *__f);
        ~locale() throw();
        const std::locale &operator=(const std::locale &__other) throw();
        template <typename _Facet> std::locale combine(const std::locale &__other) const;
        std::string name() const __attribute__((abi_tag("cxx11")));
        bool operator==(const std::locale &__other) const throw();
        bool operator!=(const std::locale &__other) const throw() {
            return !(this->operator==(__other));
        }
        template <typename _Char, typename _Traits, typename _Alloc> bool operator()(const basic_string<_Char, _Traits, _Alloc> &__s1, const basic_string<_Char, _Traits, _Alloc> &__s2) const;
        static std::locale global(const std::locale &__loc);
        static const std::locale &classic();
    private:
        std::locale::_Impl *_M_impl;
        static std::locale::_Impl *_S_classic;
        static std::locale::_Impl *_S_global;
        static const char *const *const _S_categories;
        enum {
            _S_categories_size = 6 + 6
        };
        static __gthread_once_t _S_once;
        explicit locale(std::locale::_Impl *) throw();
        static void _S_initialize();
        static void _S_initialize_once() throw();
        static std::locale::category _S_normalize_category(std::locale::category);
        void _M_coalesce(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        static const std::locale::id *const _S_twinned_facets[];
    };
    class facet {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        mutable _Atomic_word _M_refcount;
        static std::__c_locale _S_c_locale;
        static const char _S_c_name[2];
        static __gthread_once_t _S_once;
        static void _S_initialize_once();
    protected:
        explicit facet(std::size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0) {
        }
        virtual ~facet() noexcept;
        static void _S_create_c_locale(std::__c_locale &__cloc, const char *__s, std::__c_locale __old = 0);
        static std::__c_locale _S_clone_c_locale(std::__c_locale &__cloc) throw();
        static void _S_destroy_c_locale(std::__c_locale &__cloc);
        static std::__c_locale _S_lc_ctype_c_locale(std::__c_locale __cloc, const char *__s);
        static std::__c_locale _S_get_c_locale();
        static const char *_S_get_c_name() throw() __attribute__((const));
        facet(const std::locale::facet &) = delete
        std::locale::facet &operator=(const std::locale::facet &) = delete
    private:
        void _M_add_reference() const throw() {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() const throw() {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        const std::locale::facet *_M_sso_shim(const std::locale::id *) const;
        const std::locale::facet *_M_cow_shim(const std::locale::id *) const;
    protected:
        class __shim;
    };
    class id {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        mutable std::size_t _M_index;
        static _Atomic_word _S_refcount;
        void operator=(const std::locale::id &);
        id(const std::locale::id &);
    public:
        id() {
        }
        std::size_t _M_id() const throw();
    };
    class _Impl {
    public:
        friend  class locale;
        friend  class locale::facet;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
    private:
        _Atomic_word _M_refcount;
        const std::locale::facet **_M_facets;
        std::size_t _M_facets_size;
        const std::locale::facet **_M_caches;
        char **_M_names;
        static const locale::id *const _S_id_ctype[];
        static const locale::id *const _S_id_numeric[];
        static const locale::id *const _S_id_collate[];
        static const locale::id *const _S_id_time[];
        static const locale::id *const _S_id_monetary[];
        static const locale::id *const _S_id_messages[];
        static const locale::id *const *const _S_facet_categories[];
        void _M_add_reference() throw() {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() throw() {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        _Impl(const std::locale::_Impl &, std::size_t);
        _Impl(const char *, std::size_t);
        _Impl(std::size_t) throw();
        ~_Impl() throw();
        _Impl(const std::locale::_Impl &);
        void operator=(const std::locale::_Impl &);
        bool _M_check_same_name() {
            bool __ret = true;
            if (this->_M_names[1])
                for (std::size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
                    __ret = __builtin_strcmp(this->_M_names[__i], this->_M_names[__i + 1]) == 0;
            return __ret;
        }
        void _M_replace_categories(const std::locale::_Impl *, std::locale::category);
        void _M_replace_category(const std::locale::_Impl *, const locale::id *const *);
        void _M_replace_facet(const std::locale::_Impl *, const locale::id *);
        void _M_install_facet(const locale::id *, const std::locale::facet *);
        template <typename _Facet> void _M_init_facet(_Facet *__facet) {
            this->_M_install_facet(&_Facet::id, __facet);
        }
        template <typename _Facet> void _M_init_facet_unchecked(_Facet *__facet) {
            __facet->_M_add_reference();
            this->_M_facets[_Facet::id._M_id()] = __facet;
        }
        void _M_install_cache(const std::locale::facet *, std::size_t);
        void _M_init_extra(std::locale::facet **);
        void _M_init_extra(void *, void *, const char *, const char *);
    };
    template <typename _CharT> class collate : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale()) {
        }
        explicit collate<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) {
        }
        int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const {
            return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }
        std::collate::string_type transform(const _CharT *__lo, const _CharT *__hi) const {
            return this->do_transform(__lo, __hi);
        }
        long hash(const _CharT *__lo, const _CharT *__hi) const {
            return this->do_hash(__lo, __hi);
        }
        int _M_compare(const _CharT *, const _CharT *) const throw();
        std::size_t _M_transform(_CharT *, const _CharT *, std::size_t) const throw();
    protected:
        virtual ~collate<_CharT>() {
            _S_destroy_c_locale(this->_M_c_locale_collate);
        }
        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const;
        virtual std::collate::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const;
        virtual long do_hash(const _CharT *__lo, const _CharT *__hi) const;
    };
    locale::id id;
    template <> int collate<char>::_M_compare(const char *, const char *) const throw();
    template <> std::size_t collate<char>::_M_transform(char *, const char *, std::size_t) const throw();
    template <> int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const throw();
    template <> std::size_t collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    template <typename _CharT> class collate_byname : public collate<_CharT> {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
        explicit collate_byname<_CharT>(const char *__s, std::size_t __refs = 0) : collate<_CharT>(__refs) {
            if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                this->_S_destroy_c_locale(this->_M_c_locale_collate);
                this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }
        explicit collate_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : collate_byname<_CharT>(__s.c_str(), __refs) {
        }
    protected:
        virtual ~collate_byname<_CharT>() {
        }
    };
}
namespace std {
    template <typename _Facet> locale::locale(const std::locale &__other, _Facet *__f) {
        this->_M_impl = new std::locale::_Impl(*__other._M_impl, 1);
        try {
            this->_M_impl->_M_install_facet(&_Facet::id, __f);
        } catch (...) {
            this->_M_impl->_M_remove_reference();
            throw;
        }
        delete [] this->_M_impl->_M_names[0];
        this->_M_impl->_M_names[0] = 0;
    }
    template <typename _Facet> std::locale locale::combine(const std::locale &__other) const {
        std::locale::_Impl *__tmp = new std::locale::_Impl(*this->_M_impl, 1);
        try {
            __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
        } catch (...) {
            __tmp->_M_remove_reference();
            throw;
        }
        return std::locale(__tmp);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> bool locale::operator()(const basic_string<_CharT, _Traits, _Alloc> &__s1, const basic_string<_CharT, _Traits, _Alloc> &__s2) const {
        typedef std::collate<_CharT> __collate_type;
        const __collate_type &__collate = use_facet<__collate_type>(*this);
        return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0);
    }
    template <typename _Facet> bool has_facet(const std::locale &__loc) throw() {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        return (__i < __loc._M_impl->_M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]));
    }
    template <typename _Facet> const _Facet &use_facet(const std::locale &__loc) {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
            __throw_bad_cast();
        return dynamic_cast<const _Facet &>(*__facets[__i]);
    }
    template <typename _CharT> int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const throw() {
        return 0;
    }
    template <typename _CharT> std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, std::size_t) const throw() {
        return 0;
    }
    template <typename _CharT> int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const {
        const std::collate::string_type __one(__lo1, __hi1);
        const std::collate::string_type __two(__lo2, __hi2);
        const _CharT *__p = __one.c_str();
        const _CharT *__pend = __one.data() + __one.length();
        const _CharT *__q = __two.c_str();
        const _CharT *__qend = __two.data() + __two.length();
        for (;;) {
            const int __res = this->_M_compare(__p, __q);
            if (__res)
                return __res;
            __p += char_traits<_CharT>::length(__p);
            __q += char_traits<_CharT>::length(__q);
            if (__p == __pend && __q == __qend)
                return 0;
            else if (__p == __pend)
                return -1;
            else if (__q == __qend)
                return 1;
            __p++;
            __q++;
        }
    }
    template <typename _CharT> typename collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const {
        std::collate::string_type __ret;
        const std::collate::string_type __str(__lo, __hi);
        const _CharT *__p = __str.c_str();
        const _CharT *__pend = __str.data() + __str.length();
        std::size_t __len = (__hi - __lo) * 2;
        _CharT *__c = new _CharT [__len];
        try {
            for (;;) {
                std::size_t __res = this->_M_transform(__c, __p, __len);
                if (__res >= __len) {
                    __len = __res + 1;
                    delete [] __c , __c = 0;
                    __c = new _CharT [__len];
                    __res = this->_M_transform(__c, __p, __len);
                }
                __ret.append(__c, __res);
                __p += char_traits<_CharT>::length(__p);
                if (__p == __pend)
                    break;
                __p++;
                __ret.push_back(_CharT());
            }
        } catch (...) {
            delete [] __c;
            throw;
        }
        delete [] __c;
        return __ret;
    }
    template <typename _CharT> long collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const {
        unsigned long __val = 0;
        for (; __lo < __hi; ++__lo)
            __val = *__lo + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::__digits - 7)));
        return static_cast<long>(__val);
    }
    template<> class collate<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        std::collate<char>::string_type transform(const char *__lo, const char *__hi) const;
        long hash(const char *__lo, const char *__hi) const;
        int _M_compare(const char *, const char *) const throw();
        std::size_t _M_transform(char *, const char *, std::size_t) const throw();
    protected:
        virtual ~collate<char>() noexcept;
        virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        virtual std::collate<char>::string_type do_transform(const char *__lo, const char *__hi) const;
        virtual long do_hash(const char *__lo, const char *__hi) const;
    };
    template<> class collate_byname<char> : public collate<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<char>() noexcept;
    };
    template<> class collate<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        std::collate<wchar_t>::string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
        long hash(const wchar_t *__lo, const wchar_t *__hi) const;
        int _M_compare(const wchar_t *, const wchar_t *) const throw();
        std::size_t _M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    protected:
        virtual ~collate<wchar_t>() noexcept;
        virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        virtual std::collate<wchar_t>::string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
        virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
    };
    template<> class collate_byname<wchar_t> : public collate<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<wchar_t>() noexcept;
    };
}
namespace std {
    enum class errc : int {
        address_family_not_supported = 97,
        address_in_use = 98,
        address_not_available = 99,
        already_connected = 106,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 74,
        broken_pipe = 32,
        connection_aborted = 103,
        connection_already_in_progress = 114,
        connection_refused = 111,
        connection_reset = 104,
        cross_device_link = 18,
        destination_address_required = 89,
        device_or_resource_busy = 16,
        directory_not_empty = 39,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 36,
        function_not_supported = 38,
        host_unreachable = 113,
        identifier_removed = 43,
        illegal_byte_sequence = 84,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 90,
        network_down = 100,
        network_reset = 102,
        network_unreachable = 101,
        no_buffer_space = 105,
        no_child_process = 10,
        no_link = 67,
        no_lock_available = 37,
        no_message_available = 61,
        no_message = 42,
        no_protocol_option = 92,
        no_space_on_device = 28,
        no_stream_resources = 63,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 88,
        not_a_stream = 60,
        not_connected = 107,
        not_enough_memory = 12,
        not_supported = 95,
        operation_canceled = 125,
        operation_in_progress = 115,
        operation_not_permitted = 1,
        operation_not_supported = 95,
        operation_would_block = 11,
        owner_dead = 130,
        permission_denied = 13,
        protocol_error = 71,
        protocol_not_supported = 93,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 35,
        resource_unavailable_try_again = 11,
        result_out_of_range = 34,
        state_not_recoverable = 131,
        stream_timeout = 62,
        text_file_busy = 26,
        timed_out = 110,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_symbolic_link_levels = 40,
        value_too_large = 75,
        wrong_protocol_type = 91
    };
}
namespace std {
    struct __cow_string {
        union {
            const char *_M_p;
            char _M_bytes[8];
        };
        __cow_string();
        __cow_string(const std::string &);
        __cow_string(const char *, std::size_t);
        __cow_string(const std::__cow_string &) noexcept;
        std::__cow_string &operator=(const std::__cow_string &) noexcept;
        ~__cow_string();
        __cow_string(std::__cow_string &&) noexcept;
        std::__cow_string &operator=(std::__cow_string &&) noexcept;
    };
    typedef basic_string<char> __sso_string;
    class logic_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit logic_error(const std::string &__arg);
        explicit logic_error(const char *);
        logic_error(std::logic_error &&) noexcept;
        std::logic_error &operator=(std::logic_error &&) noexcept;
        logic_error(const std::logic_error &) noexcept;
        std::logic_error &operator=(const std::logic_error &) noexcept;
        virtual ~logic_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class domain_error : public std::logic_error {
    public:
        explicit domain_error(const std::string &__arg);
        explicit domain_error(const char *);
        domain_error(const std::domain_error &) = default
        std::domain_error &operator=(const std::domain_error &) = default
        domain_error(std::domain_error &&) = default
        std::domain_error &operator=(std::domain_error &&) = default
        virtual ~domain_error() noexcept;
    };
    class invalid_argument : public std::logic_error {
    public:
        explicit invalid_argument(const std::string &__arg);
        explicit invalid_argument(const char *);
        invalid_argument(const std::invalid_argument &) = default
        std::invalid_argument &operator=(const std::invalid_argument &) = default
        invalid_argument(std::invalid_argument &&) = default
        std::invalid_argument &operator=(std::invalid_argument &&) = default
        virtual ~invalid_argument() noexcept;
    };
    class length_error : public std::logic_error {
    public:
        explicit length_error(const std::string &__arg);
        explicit length_error(const char *);
        length_error(const std::length_error &) = default
        std::length_error &operator=(const std::length_error &) = default
        length_error(std::length_error &&) = default
        std::length_error &operator=(std::length_error &&) = default
        virtual ~length_error() noexcept;
    };
    class out_of_range : public std::logic_error {
    public:
        explicit out_of_range(const std::string &__arg);
        explicit out_of_range(const char *);
        out_of_range(const std::out_of_range &) = default
        std::out_of_range &operator=(const std::out_of_range &) = default
        out_of_range(std::out_of_range &&) = default
        std::out_of_range &operator=(std::out_of_range &&) = default
        virtual ~out_of_range() noexcept;
    };
    class runtime_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit runtime_error(const std::string &__arg);
        explicit runtime_error(const char *);
        runtime_error(std::runtime_error &&) noexcept;
        std::runtime_error &operator=(std::runtime_error &&) noexcept;
        runtime_error(const std::runtime_error &) noexcept;
        std::runtime_error &operator=(const std::runtime_error &) noexcept;
        virtual ~runtime_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class range_error : public std::runtime_error {
    public:
        explicit range_error(const std::string &__arg);
        explicit range_error(const char *);
        range_error(const std::range_error &) = default
        std::range_error &operator=(const std::range_error &) = default
        range_error(std::range_error &&) = default
        std::range_error &operator=(std::range_error &&) = default
        virtual ~range_error() noexcept;
    };
    class overflow_error : public std::runtime_error {
    public:
        explicit overflow_error(const std::string &__arg);
        explicit overflow_error(const char *);
        overflow_error(const std::overflow_error &) = default
        std::overflow_error &operator=(const std::overflow_error &) = default
        overflow_error(std::overflow_error &&) = default
        std::overflow_error &operator=(std::overflow_error &&) = default
        virtual ~overflow_error() noexcept;
    };
    class underflow_error : public std::runtime_error {
    public:
        explicit underflow_error(const std::string &__arg);
        explicit underflow_error(const char *);
        underflow_error(const std::underflow_error &) = default
        std::underflow_error &operator=(const std::underflow_error &) = default
        underflow_error(std::underflow_error &&) = default
        std::underflow_error &operator=(std::underflow_error &&) = default
        virtual ~underflow_error() noexcept;
    };
}
namespace std {
    class error_code;
    class error_condition;
    class system_error;
    template <typename _Tp> struct is_error_code_enum : public std::false_type {
    };
    template<> struct is_error_code_enum<std::error_code> : public std::false_type {
    };
    template<> struct is_error_code_enum<std::error_category> : public std::false_type {
    };
    template<> struct is_error_code_enum<int> : public std::false_type {
    };
    template<> struct is_error_code_enum<std::error_condition> : public std::false_type {
    };
    template<> struct is_error_code_enum<const char *> : public std::false_type {
    };
    template<> struct is_error_code_enum<char *> : public std::false_type {
    };
    template<> struct is_error_code_enum<std::type_info> : public std::false_type {
    };
    template<> struct is_error_code_enum<unsigned long> : public std::false_type {
    };
    template<> struct is_error_code_enum<std::basic_string<char>> : public std::false_type {
    };
    template<> struct is_error_code_enum<std::allocator<char>> : public std::false_type {
    };
    template <typename _Tp> struct is_error_condition_enum : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::error_condition> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::error_category> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::error_code> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::type_info> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::allocator<char>> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::errc> : public std::true_type {
    };
    inline namespace _V2 {
        class error_category {
        public:
            error_category() noexcept = default
            virtual ~error_category();
            error_category(const std::error_category &) = delete
            std::error_category &operator=(const std::error_category &) = delete
            virtual const char *name() const noexcept = 0;
        private:
            virtual std::__cow_string _M_message(int) const __attribute__((abi_tag("cxx11")));
        public:
            virtual std::string message(int) const __attribute__((abi_tag("cxx11"))) = 0;
        public:
            virtual std::error_condition default_error_condition(int __i) const noexcept;
            virtual bool equivalent(int __i, const std::error_condition &__cond) const noexcept;
            virtual bool equivalent(const std::error_code &__code, int __i) const noexcept;
            bool operator==(const std::error_category &__other) const noexcept {
                return this == &__other;
            }
            bool operator!=(const std::error_category &__other) const noexcept {
                return this != &__other;
            }
            bool operator<(const std::error_category &__other) const noexcept {
                return less<const std::error_category *>()(this, &__other);
            }
        };
        const std::error_category &generic_category() noexcept __attribute__((const));
        const std::error_category &system_category() noexcept __attribute__((const));
    }
    std::error_code make_error_code(std::errc) noexcept;
    class error_code {
    public:
        error_code() noexcept : _M_value(0), _M_cat(&system_category()) {
        }
        error_code(int __v, const std::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) {
        }
        template <typename _ErrorCodeEnum, typename = typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type> error_code(_ErrorCodeEnum __e) noexcept {
            *this = make_error_code(__e);
        }
        template<> error_code<std::io_errc, void>(std::io_errc __e) noexcept        void assign(int __v, const std::error_category &__cat) noexcept {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        void clear() noexcept {
            this->assign(0, system_category());
        }
        template <typename _ErrorCodeEnum> typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value, error_code &>::type operator=(_ErrorCodeEnum __e) noexcept {
            return *this = make_error_code(__e);
        }
        int value() const noexcept {
            return this->_M_value;
        }
        const std::error_category &category() const noexcept {
            return *this->_M_cat;
        }
        std::error_condition default_error_condition() const noexcept;
        std::string message() const __attribute__((abi_tag("cxx11"))) {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const std::error_category *_M_cat;
    };
    inline std::error_code make_error_code(std::errc __e) noexcept {
        return std::error_code(static_cast<int>(__e), generic_category());
    }
    inline bool operator<(const std::error_code &__lhs, const std::error_code &__rhs) noexcept {
        return (__lhs.category() < __rhs.category() || (__lhs.category() == __rhs.category() && __lhs.value() < __rhs.value()));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::error_code &__e) {
        return (__os << __e.category().name() << ':' << __e.value());
    }
    std::error_condition make_error_condition(std::errc) noexcept;
    class error_condition {
    public:
        error_condition() noexcept : _M_value(0), _M_cat(&generic_category()) {
        }
        error_condition(int __v, const std::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) {
        }
        template <typename _ErrorConditionEnum, typename = typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type> error_condition(_ErrorConditionEnum __e) noexcept {
            *this = make_error_condition(__e);
        }
        void assign(int __v, const std::error_category &__cat) noexcept {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        template <typename _ErrorConditionEnum> typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value, error_condition &>::type operator=(_ErrorConditionEnum __e) noexcept {
            return *this = make_error_condition(__e);
        }
        void clear() noexcept {
            this->assign(0, generic_category());
        }
        int value() const noexcept {
            return this->_M_value;
        }
        const std::error_category &category() const noexcept {
            return *this->_M_cat;
        }
        std::string message() const __attribute__((abi_tag("cxx11"))) {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const std::error_category *_M_cat;
    };
    inline std::error_condition make_error_condition(std::errc __e) noexcept {
        return std::error_condition(static_cast<int>(__e), generic_category());
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_code &__rhs) noexcept {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_condition &__rhs) noexcept {
        return (__lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value()));
    }
    inline bool operator==(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline bool operator<(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept {
        return (__lhs.category() < __rhs.category() || (__lhs.category() == __rhs.category() && __lhs.value() < __rhs.value()));
    }
    inline bool operator==(const std::error_condition &__lhs, const std::error_code &__rhs) noexcept {
        return (__rhs.category().equivalent(__rhs.value(), __lhs) || __lhs.category().equivalent(__rhs, __lhs.value()));
    }
    inline bool operator!=(const std::error_code &__lhs, const std::error_code &__rhs) noexcept {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_code &__lhs, const std::error_condition &__rhs) noexcept {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_condition &__lhs, const std::error_code &__rhs) noexcept {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept {
        return !(__lhs == __rhs);
    }
    class system_error : public std::runtime_error {
    private:
        std::error_code _M_code;
    public:
        system_error(std::error_code __ec = std::error_code()) : std::runtime_error(__ec.message()), _M_code(__ec) {
        }
        system_error(std::error_code __ec, const std::string &__what) : std::runtime_error(__what + ": " + __ec.message()), _M_code(__ec) {
        }
        system_error(std::error_code __ec, const char *__what) : std::runtime_error(__what + (": " + __ec.message())), _M_code(__ec) {
        }
        system_error(int __v, const std::error_category &__ecat, const char *__what) : NULL TYPE(std::error_code(__v, __ecat), __what) {
        }
        system_error(int __v, const std::error_category &__ecat) : std::runtime_error(std::error_code(__v, __ecat).message()), _M_code(__v, __ecat) {
        }
        system_error(int __v, const std::error_category &__ecat, const std::string &__what) : std::runtime_error(__what + ": " + std::error_code(__v, __ecat).message()), _M_code(__v, __ecat) {
        }
        system_error(const std::system_error &) = default
        std::system_error &operator=(const std::system_error &) = default
        virtual ~system_error() noexcept;
        const std::error_code &code() const noexcept {
            return this->_M_code;
        }
    };
}
namespace std {
    template<> struct hash<std::error_code> : public __hash_base<std::size_t, std::error_code> {
        std::size_t operator()(const std::error_code &__e) const noexcept {
            const std::size_t __tmp = std::_Hash_impl::hash(__e.value());
            return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
        }
    };
}
namespace std {
    enum _Ios_Fmtflags {
        _S_boolalpha = 1L << 0,
        _S_dec = 1L << 1,
        _S_fixed = 1L << 2,
        _S_hex = 1L << 3,
        _S_internal = 1L << 4,
        _S_left = 1L << 5,
        _S_oct = 1L << 6,
        _S_right = 1L << 7,
        _S_scientific = 1L << 8,
        _S_showbase = 1L << 9,
        _S_showpoint = 1L << 10,
        _S_showpos = 1L << 11,
        _S_skipws = 1L << 12,
        _S_unitbuf = 1L << 13,
        _S_uppercase = 1L << 14,
        _S_adjustfield = _S_left | _S_right | _S_internal,
        _S_basefield = _S_dec | _S_oct | _S_hex,
        _S_floatfield = _S_scientific | _S_fixed,
        _S_ios_fmtflags_end = 1L << 16,
        _S_ios_fmtflags_max = 2147483647,
        _S_ios_fmtflags_min = ~2147483647
    };
    inline constexpr std::_Ios_Fmtflags operator&(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b) {
        return std::_Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator|(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b) {
        return std::_Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator^(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b) {
        return std::_Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator~(std::_Ios_Fmtflags __a) {
        return std::_Ios_Fmtflags(~static_cast<int>(__a));
    }
    inline const std::_Ios_Fmtflags &operator|=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b) {
        return __a = __a | __b;
    }
    inline const std::_Ios_Fmtflags &operator&=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b) {
        return __a = __a & __b;
    }
    inline const std::_Ios_Fmtflags &operator^=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b) {
        return __a = __a ^ __b;
    }
    enum _Ios_Openmode {
        _S_app = 1L << 0,
        _S_ate = 1L << 1,
        _S_bin = 1L << 2,
        _S_in = 1L << 3,
        _S_out = 1L << 4,
        _S_trunc = 1L << 5,
        _S_noreplace = 1L << 6,
        _S_ios_openmode_end = 1L << 16,
        _S_ios_openmode_max = 2147483647,
        _S_ios_openmode_min = ~2147483647
    };
    inline constexpr std::_Ios_Openmode operator&(std::_Ios_Openmode __a, std::_Ios_Openmode __b) {
        return std::_Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator|(std::_Ios_Openmode __a, std::_Ios_Openmode __b) {
        return std::_Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator^(std::_Ios_Openmode __a, std::_Ios_Openmode __b) {
        return std::_Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator~(std::_Ios_Openmode __a) {
        return std::_Ios_Openmode(~static_cast<int>(__a));
    }
    inline const std::_Ios_Openmode &operator|=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b) {
        return __a = __a | __b;
    }
    inline const std::_Ios_Openmode &operator&=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b) {
        return __a = __a & __b;
    }
    inline const std::_Ios_Openmode &operator^=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b) {
        return __a = __a ^ __b;
    }
    enum _Ios_Iostate {
        _S_goodbit = 0,
        _S_badbit = 1L << 0,
        _S_eofbit = 1L << 1,
        _S_failbit = 1L << 2,
        _S_ios_iostate_end = 1L << 16,
        _S_ios_iostate_max = 2147483647,
        _S_ios_iostate_min = ~2147483647
    };
    inline constexpr std::_Ios_Iostate operator&(std::_Ios_Iostate __a, std::_Ios_Iostate __b) {
        return std::_Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator|(std::_Ios_Iostate __a, std::_Ios_Iostate __b) {
        return std::_Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator^(std::_Ios_Iostate __a, std::_Ios_Iostate __b) {
        return std::_Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator~(std::_Ios_Iostate __a) {
        return std::_Ios_Iostate(~static_cast<int>(__a));
    }
    inline const std::_Ios_Iostate &operator|=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b) {
        return __a = __a | __b;
    }
    inline const std::_Ios_Iostate &operator&=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b) {
        return __a = __a & __b;
    }
    inline const std::_Ios_Iostate &operator^=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b) {
        return __a = __a ^ __b;
    }
    enum _Ios_Seekdir {
        _S_beg = 0,
        _S_cur = 1,
        _S_end = 2,
        _S_ios_seekdir_end = 1L << 16
    };
    enum class io_errc : int {
        stream = 1
    };
    template<> struct is_error_code_enum<std::io_errc> : public std::true_type {
    };
    const std::error_category &iostream_category() noexcept;
    inline std::error_code make_error_code(std::io_errc __e) noexcept {
        return std::error_code(static_cast<int>(__e), iostream_category());
    }
    inline std::error_condition make_error_condition(std::io_errc __e) noexcept {
        return std::error_condition(static_cast<int>(__e), iostream_category());
    }
    class ios_base {
    public:
        class __attribute__((abi_tag("cxx11"))) failure : public std::system_error {
        public:
            explicit failure(const std::string &__str);
            explicit failure(const std::string &, const std::error_code &);
            explicit failure(const char *, const std::error_code & = io_errc::stream);
            virtual ~failure() throw();
            virtual const char *what() const throw();
        };
        typedef std::_Ios_Fmtflags fmtflags;
        static const std::ios_base::fmtflags boolalpha = _S_boolalpha;
        static const std::ios_base::fmtflags dec = _S_dec;
        static const std::ios_base::fmtflags fixed = _S_fixed;
        static const std::ios_base::fmtflags hex = _S_hex;
        static const std::ios_base::fmtflags internal = _S_internal;
        static const std::ios_base::fmtflags left = _S_left;
        static const std::ios_base::fmtflags oct = _S_oct;
        static const std::ios_base::fmtflags right = _S_right;
        static const std::ios_base::fmtflags scientific = _S_scientific;
        static const std::ios_base::fmtflags showbase = _S_showbase;
        static const std::ios_base::fmtflags showpoint = _S_showpoint;
        static const std::ios_base::fmtflags showpos = _S_showpos;
        static const std::ios_base::fmtflags skipws = _S_skipws;
        static const std::ios_base::fmtflags unitbuf = _S_unitbuf;
        static const std::ios_base::fmtflags uppercase = _S_uppercase;
        static const std::ios_base::fmtflags adjustfield = _S_adjustfield;
        static const std::ios_base::fmtflags basefield = _S_basefield;
        static const std::ios_base::fmtflags floatfield = _S_floatfield;
        typedef std::_Ios_Iostate iostate;
        static const std::ios_base::iostate badbit = _S_badbit;
        static const std::ios_base::iostate eofbit = _S_eofbit;
        static const std::ios_base::iostate failbit = _S_failbit;
        static const std::ios_base::iostate goodbit = _S_goodbit;
        typedef std::_Ios_Openmode openmode;
        static const std::ios_base::openmode app = _S_app;
        static const std::ios_base::openmode ate = _S_ate;
        static const std::ios_base::openmode binary = _S_bin;
        static const std::ios_base::openmode in = _S_in;
        static const std::ios_base::openmode out = _S_out;
        static const std::ios_base::openmode trunc = _S_trunc;
        static const std::ios_base::openmode __noreplace = _S_noreplace;
        typedef std::_Ios_Seekdir seekdir;
        static const std::ios_base::seekdir beg = _S_beg;
        static const std::ios_base::seekdir cur = _S_cur;
        static const std::ios_base::seekdir end = _S_end;
        typedef int io_state __attribute__((deprecated("use 'std::iostate' instead")));
        typedef int open_mode __attribute__((deprecated("use 'std::openmode' instead")));
        typedef int seek_dir __attribute__((deprecated("use 'std::seekdir' instead")));
        typedef std::streampos streampos __attribute__((deprecated("use 'std::streampos' instead")));
        typedef std::streamoff streamoff __attribute__((deprecated("use 'std::streamoff' instead")));
        enum event {
            erase_event,
            imbue_event,
            copyfmt_event
        };
        typedef void (*event_callback)(std::ios_base::event, std::ios_base &, int);
        void register_callback(std::ios_base::event_callback __fn, int __index);
    protected:
        std::streamsize _M_precision;
        std::streamsize _M_width;
        std::ios_base::fmtflags _M_flags;
        std::ios_base::iostate _M_exception;
        std::ios_base::iostate _M_streambuf_state;
        struct _Callback_list {
            std::ios_base::_Callback_list *_M_next;
            ios_base::event_callback _M_fn;
            int _M_index;
            _Atomic_word _M_refcount;
            _Callback_list(ios_base::event_callback __fn, int __index, std::ios_base::_Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) {
            }
            void _M_add_reference() {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
            }
            int _M_remove_reference() {
                ;
                int __res = __gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1);
                if (__res == 0) {
                    ;
                }
                return __res;
            }
        };
        std::ios_base::_Callback_list *_M_callbacks;
        void _M_call_callbacks(std::ios_base::event __ev) throw();
        void _M_dispose_callbacks() throw();
        struct _Words {
            void *_M_pword;
            long _M_iword;
            _Words() : _M_pword(0), _M_iword(0) {
            }
        };
        std::ios_base::_Words _M_word_zero;
        enum {
            _S_local_word_size = 8
        };
        std::ios_base::_Words _M_local_word[8];
        int _M_word_size;
        std::ios_base::_Words *_M_word;
        std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
        std::locale _M_ios_locale;
        void _M_init() throw();
    public:
        class Init {
            friend  class ios_base;
        public:
            Init();
            ~Init() noexcept;
            Init(const std::ios_base::Init &) = default
            std::ios_base::Init &operator=(const std::ios_base::Init &) = default
        private:
            static _Atomic_word _S_refcount;
            static bool _S_synced_with_stdio;
        };
        std::ios_base::fmtflags flags() const {
            return this->_M_flags;
        }
        std::ios_base::fmtflags flags(std::ios_base::fmtflags __fmtfl) {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags = __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl) {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags |= __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl, std::ios_base::fmtflags __mask) {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags &= ~ __mask;
            this->_M_flags |= (__fmtfl & __mask);
            return __old;
        }
        void unsetf(std::ios_base::fmtflags __mask) {
            this->_M_flags &= ~ __mask;
        }
        std::streamsize precision() const {
            return this->_M_precision;
        }
        std::streamsize precision(std::streamsize __prec) {
            std::streamsize __old = this->_M_precision;
            this->_M_precision = __prec;
            return __old;
        }
        std::streamsize width() const {
            return this->_M_width;
        }
        std::streamsize width(std::streamsize __wide) {
            std::streamsize __old = this->_M_width;
            this->_M_width = __wide;
            return __old;
        }
        static bool sync_with_stdio(bool __sync = true);
        std::locale imbue(const std::locale &__loc) throw();
        std::locale getloc() const {
            return this->_M_ios_locale;
        }
        const std::locale &_M_getloc() const {
            return this->_M_ios_locale;
        }
        static int xalloc() throw();
        long &iword(int __ix) {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, true);
            return __word._M_iword;
        }
        void *&pword(int __ix) {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, false);
            return __word._M_pword;
        }
        virtual ~ios_base() throw();
    protected:
        ios_base() throw();
    public:
        ios_base(const std::ios_base &) = delete
        std::ios_base &operator=(const std::ios_base &) = delete
    protected:
        void _M_move(std::ios_base &) noexcept;
        void _M_swap(std::ios_base &__rhs) noexcept;
    };
    inline std::ios_base &boolalpha(std::ios_base &__base) {
        __base.setf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &noboolalpha(std::ios_base &__base) {
        __base.unsetf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &showbase(std::ios_base &__base) {
        __base.setf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &noshowbase(std::ios_base &__base) {
        __base.unsetf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &showpoint(std::ios_base &__base) {
        __base.setf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &noshowpoint(std::ios_base &__base) {
        __base.unsetf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &showpos(std::ios_base &__base) {
        __base.setf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &noshowpos(std::ios_base &__base) {
        __base.unsetf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &skipws(std::ios_base &__base) {
        __base.setf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &noskipws(std::ios_base &__base) {
        __base.unsetf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &uppercase(std::ios_base &__base) {
        __base.setf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &nouppercase(std::ios_base &__base) {
        __base.unsetf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &unitbuf(std::ios_base &__base) {
        __base.setf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &nounitbuf(std::ios_base &__base) {
        __base.unsetf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &internal(std::ios_base &__base) {
        __base.setf(ios_base::internal, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &left(std::ios_base &__base) {
        __base.setf(ios_base::left, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &right(std::ios_base &__base) {
        __base.setf(ios_base::right, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &dec(std::ios_base &__base) {
        __base.setf(ios_base::dec, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &hex(std::ios_base &__base) {
        __base.setf(ios_base::hex, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &oct(std::ios_base &__base) {
        __base.setf(ios_base::oct, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &fixed(std::ios_base &__base) {
        __base.setf(ios_base::fixed, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &scientific(std::ios_base &__base) {
        __base.setf(ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &hexfloat(std::ios_base &__base) {
        __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &defaultfloat(std::ios_base &__base) {
        __base.unsetf(ios_base::floatfield);
        return __base;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf::char_type, std::basic_streambuf::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(std::istream &, char *, std::streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf::char_type *_M_in_beg;
        std::basic_streambuf::char_type *_M_in_cur;
        std::basic_streambuf::char_type *_M_in_end;
        std::basic_streambuf::char_type *_M_out_beg;
        std::basic_streambuf::char_type *_M_out_cur;
        std::basic_streambuf::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<_CharT, _Traits>() {
        }
        std::locale pubimbue(const std::locale &__loc) {
            std::locale __tmp(this->getloc());
            this->imbue(__loc);
            this->_M_buf_locale = __loc;
            return __tmp;
        }
        std::locale getloc() const {
            return this->_M_buf_locale;
        }
        basic_streambuf<_CharT, _Traits> *pubsetbuf(std::basic_streambuf::char_type *__s, std::streamsize __n) {
            return this->setbuf(__s, __n);
        }
        std::basic_streambuf::pos_type pubseekoff(std::basic_streambuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out) {
            return this->seekoff(__off, __way, __mode);
        }
        std::basic_streambuf::pos_type pubseekpos(std::basic_streambuf::pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out) {
            return this->seekpos(__sp, __mode);
        }
        int pubsync() {
            return this->sync();
        }
        std::streamsize in_avail() {
            const std::streamsize __ret = this->egptr() - this->gptr();
            return __ret ? __ret : this->showmanyc();
        }
        std::basic_streambuf::int_type snextc() {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
                __ret = this->sgetc();
            return __ret;
        }
        std::basic_streambuf::int_type sbumpc() {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true)) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            } else
                __ret = this->uflow();
            return __ret;
        }
        std::basic_streambuf::int_type sgetc() {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true))
                __ret = traits_type::to_int_type(*this->gptr());
            else
                __ret = this->underflow();
            return __ret;
        }
        std::streamsize sgetn(std::basic_streambuf::char_type *__s, std::streamsize __n) {
            return this->xsgetn(__s, __n);
        }
        std::basic_streambuf::int_type sputbackc(std::basic_streambuf::char_type __c) {
            std::basic_streambuf::int_type __ret;
            const bool __testpos = this->eback() < this->gptr();
            if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
                __ret = this->pbackfail(traits_type::to_int_type(__c));
            else {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            }
            return __ret;
        }
        std::basic_streambuf::int_type sungetc() {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->eback() < this->gptr(), true)) {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            } else
                __ret = this->pbackfail();
            return __ret;
        }
        std::basic_streambuf::int_type sputc(std::basic_streambuf::char_type __c) {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->pptr() < this->epptr(), true)) {
                *this->pptr() = __c;
                this->pbump(1);
                __ret = traits_type::to_int_type(__c);
            } else
                __ret = this->overflow(traits_type::to_int_type(__c));
            return __ret;
        }
        std::streamsize sputn(const std::basic_streambuf::char_type *__s, std::streamsize __n) {
            return this->xsputn(__s, __n);
        }
    protected:
        basic_streambuf<_CharT, _Traits>() : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(std::locale()) {
        }
        std::basic_streambuf::char_type *eback() const {
            return this->_M_in_beg;
        }
        std::basic_streambuf::char_type *gptr() const {
            return this->_M_in_cur;
        }
        std::basic_streambuf::char_type *egptr() const {
            return this->_M_in_end;
        }
        void gbump(int __n) {
            this->_M_in_cur += __n;
        }
        void setg(std::basic_streambuf::char_type *__gbeg, std::basic_streambuf::char_type *__gnext, std::basic_streambuf::char_type *__gend) {
            this->_M_in_beg = __gbeg;
            this->_M_in_cur = __gnext;
            this->_M_in_end = __gend;
        }
        std::basic_streambuf::char_type *pbase() const {
            return this->_M_out_beg;
        }
        std::basic_streambuf::char_type *pptr() const {
            return this->_M_out_cur;
        }
        std::basic_streambuf::char_type *epptr() const {
            return this->_M_out_end;
        }
        void pbump(int __n) {
            this->_M_out_cur += __n;
        }
        void setp(std::basic_streambuf::char_type *__pbeg, std::basic_streambuf::char_type *__pend) {
            this->_M_out_beg = this->_M_out_cur = __pbeg;
            this->_M_out_end = __pend;
        }
        virtual void imbue(const std::locale &__loc __attribute__((unused))) {
        }
        virtual basic_streambuf<std::basic_streambuf::char_type, _Traits> *setbuf(std::basic_streambuf::char_type *, std::streamsize) {
            return this;
        }
        virtual std::basic_streambuf::pos_type seekoff(std::basic_streambuf::off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual std::basic_streambuf::pos_type seekpos(std::basic_streambuf::pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual int sync() {
            return 0;
        }
        virtual std::streamsize showmanyc() {
            return 0;
        }
        virtual std::streamsize xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type underflow() {
            return traits_type::eof();
        }
        virtual std::basic_streambuf::int_type uflow() {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
            if (!__testeof) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            }
            return __ret;
        }
        virtual std::basic_streambuf::int_type pbackfail(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused))) {
            return traits_type::eof();
        }
        virtual std::streamsize xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type overflow(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused))) {
            return traits_type::eof();
        }
    public:
        void stossc() __attribute__((deprecated("use 'std::basic_streambuf::sbumpc' instead"))) {
            if (this->gptr() < this->egptr())
                this->gbump(1);
            else
                this->uflow();
        }
        void __safe_gbump(std::streamsize __n) {
            this->_M_in_cur += __n;
        }
        void __safe_pbump(std::streamsize __n) {
            this->_M_out_cur += __n;
        }
    protected:
        basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &);
        basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &);
        void swap(basic_streambuf<_CharT, _Traits> &__sb) {
            std::swap(this->_M_in_beg, __sb._M_in_beg);
            std::swap(this->_M_in_cur, __sb._M_in_cur);
            std::swap(this->_M_in_end, __sb._M_in_end);
            std::swap(this->_M_out_beg, __sb._M_out_beg);
            std::swap(this->_M_out_cur, __sb._M_out_cur);
            std::swap(this->_M_out_end, __sb._M_out_end);
            std::swap(this->_M_buf_locale, __sb._M_buf_locale);
        }
    };
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits>::basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &) = default
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits> &std::basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf<_CharT, _Traits> &) = default
    template<> std::streamsize __copy_streambufs_eof<char, std::char_traits<char>>(basic_streambuf<char> *__sbin, basic_streambuf<char> *__sbout, bool &__ineof);
    template<> std::streamsize __copy_streambufs_eof<wchar_t, std::char_traits<wchar_t>>(basic_streambuf<wchar_t> *__sbin, basic_streambuf<wchar_t> *__sbout, bool &__ineof);
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n) {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->egptr() - this->gptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(__s, this->gptr(), __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_gbump(__len);
                }
                if (__ret < __n) {
                    const std::basic_streambuf::int_type __c = this->uflow();
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        traits_type::assign(*__s++, traits_type::to_char_type(__c));
                        ++__ret;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n) {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->epptr() - this->pptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(this->pptr(), __s, __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_pbump(__len);
                }
                if (__ret < __n) {
                    std::basic_streambuf::int_type __c = this->overflow(traits_type::to_int_type(*__s));
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        ++__ret;
                        ++__s;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof) {
        std::streamsize __ret = 0;
        __ineof = true;
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
            {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof())) {
                    __ineof = false;
                    break;
                }
                ++__ret;
                __c = __sbin->snextc();
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> inline std::streamsize __copy_streambufs(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout) {
        bool __ineof;
        return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
    template<> class basic_streambuf<char> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<char>::char_type, std::basic_streambuf<char>::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(std::istream &, char *, std::streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<char>::char_type *_M_in_beg;
        std::basic_streambuf<char>::char_type *_M_in_cur;
        std::basic_streambuf<char>::char_type *_M_in_end;
        std::basic_streambuf<char>::char_type *_M_out_beg;
        std::basic_streambuf<char>::char_type *_M_out_cur;
        std::basic_streambuf<char>::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<char>() throw() {
        }
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<char> *pubsetbuf(std::basic_streambuf<char>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char>::pos_type pubseekoff(std::basic_streambuf<char>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<char>::pos_type pubseekpos(std::basic_streambuf<char>::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<char>::int_type snextc();
        std::basic_streambuf<char>::int_type sbumpc();
        std::basic_streambuf<char>::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<char>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char>::int_type sputbackc(std::basic_streambuf<char>::char_type __c);
        std::basic_streambuf<char>::int_type sungetc();
        std::basic_streambuf<char>::int_type sputc(std::basic_streambuf<char>::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<char>::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf() : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(std::locale()) {
        }
        std::basic_streambuf<char>::char_type *eback() const;
        std::basic_streambuf<char>::char_type *gptr() const;
        std::basic_streambuf<char>::char_type *egptr() const {
            return this->_M_in_end;
        }
        void gbump(int __n);
        void setg(std::basic_streambuf<char>::char_type *__gbeg, std::basic_streambuf<char>::char_type *__gnext, std::basic_streambuf<char>::char_type *__gend);
        std::basic_streambuf<char>::char_type *pbase() const {
            return this->_M_out_beg;
        }
        std::basic_streambuf<char>::char_type *pptr() const {
            return this->_M_out_cur;
        }
        std::basic_streambuf<char>::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<char>::char_type *__pbeg, std::basic_streambuf<char>::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<char>::char_type, std::char_traits<char>> *setbuf(std::basic_streambuf<char>::char_type *, std::streamsize);
        virtual std::basic_streambuf<char>::pos_type seekoff(std::basic_streambuf<char>::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<char>::pos_type seekpos(std::basic_streambuf<char>::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<char>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char>::int_type underflow();
        virtual std::basic_streambuf<char>::int_type uflow();
        virtual std::basic_streambuf<char>::int_type pbackfail(std::basic_streambuf<char>::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<char>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char>::int_type overflow(std::basic_streambuf<char>::int_type __c __attribute__((unused)));
    public:
        void stossc() __attribute__((deprecated("use 'std::basic_streambuf::sbumpc' instead")));
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<char> &);
        std::basic_streambuf<char> &operator=(const std::basic_streambuf<char> &);
        void swap(std::basic_streambuf<char> &__sb);
    };
    template<> class basic_streambuf<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<wchar_t>::char_type, std::basic_streambuf<wchar_t>::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(std::istream &, char *, std::streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<wchar_t>::char_type *_M_in_beg;
        std::basic_streambuf<wchar_t>::char_type *_M_in_cur;
        std::basic_streambuf<wchar_t>::char_type *_M_in_end;
        std::basic_streambuf<wchar_t>::char_type *_M_out_beg;
        std::basic_streambuf<wchar_t>::char_type *_M_out_cur;
        std::basic_streambuf<wchar_t>::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<wchar_t>() throw();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<wchar_t> *pubsetbuf(std::basic_streambuf<wchar_t>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t>::pos_type pubseekoff(std::basic_streambuf<wchar_t>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<wchar_t>::pos_type pubseekpos(std::basic_streambuf<wchar_t>::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<wchar_t>::int_type snextc();
        std::basic_streambuf<wchar_t>::int_type sbumpc();
        std::basic_streambuf<wchar_t>::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<wchar_t>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t>::int_type sputbackc(std::basic_streambuf<wchar_t>::char_type __c);
        std::basic_streambuf<wchar_t>::int_type sungetc();
        std::basic_streambuf<wchar_t>::int_type sputc(std::basic_streambuf<wchar_t>::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<wchar_t>::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf();
        std::basic_streambuf<wchar_t>::char_type *eback() const;
        std::basic_streambuf<wchar_t>::char_type *gptr() const;
        std::basic_streambuf<wchar_t>::char_type *egptr() const;
        void gbump(int __n);
        void setg(std::basic_streambuf<wchar_t>::char_type *__gbeg, std::basic_streambuf<wchar_t>::char_type *__gnext, std::basic_streambuf<wchar_t>::char_type *__gend);
        std::basic_streambuf<wchar_t>::char_type *pbase() const;
        std::basic_streambuf<wchar_t>::char_type *pptr() const;
        std::basic_streambuf<wchar_t>::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<wchar_t>::char_type *__pbeg, std::basic_streambuf<wchar_t>::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<wchar_t>::char_type, std::char_traits<wchar_t>> *setbuf(std::basic_streambuf<wchar_t>::char_type *, std::streamsize);
        virtual std::basic_streambuf<wchar_t>::pos_type seekoff(std::basic_streambuf<wchar_t>::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<wchar_t>::pos_type seekpos(std::basic_streambuf<wchar_t>::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<wchar_t>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t>::int_type underflow();
        virtual std::basic_streambuf<wchar_t>::int_type uflow();
        virtual std::basic_streambuf<wchar_t>::int_type pbackfail(std::basic_streambuf<wchar_t>::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<wchar_t>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t>::int_type overflow(std::basic_streambuf<wchar_t>::int_type __c __attribute__((unused)));
    public:
        void stossc() __attribute__((deprecated("use 'std::basic_streambuf::sbumpc' instead")));
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<wchar_t> &);
        std::basic_streambuf<wchar_t> &operator=(const std::basic_streambuf<wchar_t> &);
        void swap(std::basic_streambuf<wchar_t> &__sb);
    };
}
typedef unsigned long wctype_t;
enum {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = ((__ISwupper) < 8 ? (int)((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int)((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int)((1UL << (__ISwupper)) >> 8) : (int)((1UL << (__ISwupper)) >> 24)))),
    _ISwlower = ((__ISwlower) < 8 ? (int)((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int)((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int)((1UL << (__ISwlower)) >> 8) : (int)((1UL << (__ISwlower)) >> 24)))),
    _ISwalpha = ((__ISwalpha) < 8 ? (int)((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int)((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int)((1UL << (__ISwalpha)) >> 8) : (int)((1UL << (__ISwalpha)) >> 24)))),
    _ISwdigit = ((__ISwdigit) < 8 ? (int)((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int)((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int)((1UL << (__ISwdigit)) >> 8) : (int)((1UL << (__ISwdigit)) >> 24)))),
    _ISwxdigit = ((__ISwxdigit) < 8 ? (int)((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int)((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int)((1UL << (__ISwxdigit)) >> 8) : (int)((1UL << (__ISwxdigit)) >> 24)))),
    _ISwspace = ((__ISwspace) < 8 ? (int)((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int)((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int)((1UL << (__ISwspace)) >> 8) : (int)((1UL << (__ISwspace)) >> 24)))),
    _ISwprint = ((__ISwprint) < 8 ? (int)((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int)((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int)((1UL << (__ISwprint)) >> 8) : (int)((1UL << (__ISwprint)) >> 24)))),
    _ISwgraph = ((__ISwgraph) < 8 ? (int)((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int)((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int)((1UL << (__ISwgraph)) >> 8) : (int)((1UL << (__ISwgraph)) >> 24)))),
    _ISwblank = ((__ISwblank) < 8 ? (int)((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int)((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int)((1UL << (__ISwblank)) >> 8) : (int)((1UL << (__ISwblank)) >> 24)))),
    _ISwcntrl = ((__ISwcntrl) < 8 ? (int)((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int)((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int)((1UL << (__ISwcntrl)) >> 8) : (int)((1UL << (__ISwcntrl)) >> 24)))),
    _ISwpunct = ((__ISwpunct) < 8 ? (int)((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int)((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int)((1UL << (__ISwpunct)) >> 8) : (int)((1UL << (__ISwpunct)) >> 24)))),
    _ISwalnum = ((__ISwalnum) < 8 ? (int)((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int)((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int)((1UL << (__ISwalnum)) >> 8) : (int)((1UL << (__ISwalnum)) >> 24))))
};
extern "C" {
    extern int iswalnum(wint_t __wc) noexcept(true);
    extern int iswalpha(wint_t __wc) noexcept(true);
    extern int iswcntrl(wint_t __wc) noexcept(true);
    extern int iswdigit(wint_t __wc) noexcept(true);
    extern int iswgraph(wint_t __wc) noexcept(true);
    extern int iswlower(wint_t __wc) noexcept(true);
    extern int iswprint(wint_t __wc) noexcept(true);
    extern int iswpunct(wint_t __wc) noexcept(true);
    extern int iswspace(wint_t __wc) noexcept(true);
    extern int iswupper(wint_t __wc) noexcept(true);
    extern int iswxdigit(wint_t __wc) noexcept(true);
    extern int iswblank(wint_t __wc) noexcept(true);
    extern wctype_t wctype(const char *__property) noexcept(true);
    extern int iswctype(wint_t __wc, wctype_t __desc) noexcept(true);
    extern wint_t towlower(wint_t __wc) noexcept(true);
    extern wint_t towupper(wint_t __wc) noexcept(true);
}
extern "C" {
    typedef const __int32_t *wctrans_t;
    extern wctrans_t wctrans(const char *__property) noexcept(true);
    extern wint_t towctrans(wint_t __wc, wctrans_t __desc) noexcept(true);
    extern int iswalnum_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswalpha_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswcntrl_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswgraph_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswlower_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswprint_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswpunct_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswspace_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswupper_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswxdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswblank_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wctype_t wctype_l(const char *__property, locale_t __locale) noexcept(true);
    extern int iswctype_l(wint_t __wc, wctype_t __desc, locale_t __locale) noexcept(true);
    extern wint_t towlower_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wint_t towupper_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wctrans_t wctrans_l(const char *__property, locale_t __locale) noexcept(true);
    extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, locale_t __locale) noexcept(true);
}
namespace std {
    using ::wctrans_t;
    using ::wctype_t;
    using ::wint_t;
    using ::iswalnum;
    using ::iswalpha;
    using ::iswblank;
    using ::iswcntrl;
    using ::iswctype;
    using ::iswdigit;
    using ::iswgraph;
    using ::iswlower;
    using ::iswprint;
    using ::iswpunct;
    using ::iswspace;
    using ::iswupper;
    using ::iswxdigit;
    using ::towctrans;
    using ::towlower;
    using ::towupper;
    using ::wctrans;
    using ::wctype;
}
namespace std {
    struct ctype_base {
        typedef const int *__to_type;
        typedef unsigned short mask;
        static const std::ctype_base::mask upper = _ISupper;
        static const std::ctype_base::mask lower = _ISlower;
        static const std::ctype_base::mask alpha = _ISalpha;
        static const std::ctype_base::mask digit = _ISdigit;
        static const std::ctype_base::mask xdigit = _ISxdigit;
        static const std::ctype_base::mask space = _ISspace;
        static const std::ctype_base::mask print = _ISprint;
        static const std::ctype_base::mask graph = _ISalpha | _ISdigit | _ISpunct;
        static const std::ctype_base::mask cntrl = _IScntrl;
        static const std::ctype_base::mask punct = _ISpunct;
        static const std::ctype_base::mask alnum = _ISalpha | _ISdigit;
        static const std::ctype_base::mask blank = _ISblank;
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator : public iterator<std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename _Traits::int_type int_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_istream<_CharT, _Traits> istream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2 *, bool);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
    private:
        mutable std::istreambuf_iterator::streambuf_type *_M_sbuf;
        std::istreambuf_iterator::int_type _M_c;
    public:
        constexpr istreambuf_iterator<_CharT, _Traits>() noexcept : _M_sbuf(0), _M_c(traits_type::eof()) {
        }
        istreambuf_iterator<_CharT, _Traits>(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        ~istreambuf_iterator<_CharT, _Traits>() = default
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::istream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) {
        }
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_c(traits_type::eof()) {
        }
        istreambuf_iterator<_CharT, _Traits> &operator=(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        std::istreambuf_iterator::char_type operator*() const {
            std::istreambuf_iterator::int_type __c = this->_M_get();
            return traits_type::to_char_type(__c);
        }
        istreambuf_iterator<_CharT, _Traits> &operator++() {
            ;
            this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return *this;
        }
        istreambuf_iterator<_CharT, _Traits> operator++(int) {
            ;
            istreambuf_iterator<_CharT, _Traits> __old = *this;
            __old._M_c = this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return __old;
        }
        bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const {
            return this->_M_at_eof() == __b._M_at_eof();
        }
    private:
        std::istreambuf_iterator::int_type _M_get() const {
            std::istreambuf_iterator::int_type __ret = this->_M_c;
            if (this->_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = this->_M_sbuf->sgetc()))
                this->_M_sbuf = 0;
            return __ret;
        }
        bool _M_at_eof() const {
            return _S_is_eof(this->_M_get());
        }
        static bool _S_is_eof(std::istreambuf_iterator::int_type __c) {
            const std::istreambuf_iterator::int_type __eof = traits_type::eof();
            return traits_type::eq_int_type(__c, __eof);
        }
    };
    template <typename _CharT, typename _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) {
        return __a.equal(__b);
    }
    template <typename _CharT, typename _Traits> inline bool operator!=(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) {
        return !__a.equal(__b);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
    private:
        std::ostreambuf_iterator::streambuf_type *_M_sbuf;
        bool _M_failed;
    public:
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::ostream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_failed(!this->_M_sbuf) {
        }
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_failed(!this->_M_sbuf) {
        }
        ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c) {
            if (!this->_M_failed && _Traits::eq_int_type(this->_M_sbuf->sputc(__c), _Traits::eof()))
                this->_M_failed = true;
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator*() {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++(int) {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++() {
            return *this;
        }
        bool failed() const noexcept {
            return this->_M_failed;
        }
        ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, std::streamsize __len) {
            if (__builtin_expect(!this->_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
                this->_M_failed = true;
            return *this;
        }
    };
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type copy(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, ostreambuf_iterator<_CharT> __result) {
        if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed) {
            bool __ineof;
            __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
            if (!__ineof)
                __result._M_failed = true;
        }
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator<_CharT> __result) {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator<_CharT> __result) {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, _CharT *__result) {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf) {
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    const std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        traits_type::copy(__result, __sb->gptr(), __n);
                        __sb->__safe_gbump(__n);
                        __result += __n;
                        __c = __sb->underflow();
                    } else {
                        *__result++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                    }
                }
        }
        return __result;
    }
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT *__result, bool __strict __attribute__((unused))) {
        if (__n == 0)
            return __result;
        ;
        _CharT *__beg = __result;
        __result += __it._M_sbuf->sgetn(__beg, __n);
        ;
        return __result;
    }
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, istreambuf_iterator<_CharT>>::__type find(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, const _CharT &__val) {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        if (__first._M_sbuf && !__last._M_sbuf) {
            const int_type __ival = traits_type::to_int_type(__val);
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __ival))
                {
                    std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                        if (__p)
                            __n = __p - __sb->gptr();
                        __sb->__safe_gbump(__n);
                        __c = __sb->sgetc();
                    } else
                        __c = __sb->snextc();
                }
            __first._M_c = __eof;
        }
        return __first;
    }
    template <typename _CharT, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, void>::__type advance(istreambuf_iterator<_CharT> &__i, _Distance __n) {
        if (__n == 0)
            return;
        do {
            if (std::__is_constant_evaluated() && !bool(__n > 0))
                __builtin_unreachable();
        } while (false);
        ;
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        streambuf_type *__sb = __i._M_sbuf;
        while (__n > 0)
            {
                std::streamsize __size = __sb->egptr() - __sb->gptr();
                if (__size > __n) {
                    __sb->__safe_gbump(__n);
                    break;
                }
                __sb->__safe_gbump(__size);
                __n -= __size;
                if (traits_type::eq_int_type(__sb->underflow(), __eof)) {
                    ;
                    break;
                }
            }
        __i._M_c = __eof;
    }
}
namespace std {
    template <typename _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<float>(const char *, float &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<double>(const char *, double &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<long double>(const char *, long double &, ios_base::iostate &, const std::__c_locale &) throw();
    template <typename _CharT, typename _Traits> struct __pad {
        static void _S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen);
    };
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last);
    template <typename _CharT> inline ostreambuf_iterator<_CharT> __write(ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len) {
        __s._M_put(__ws, __len);
        return __s;
    }
    template <typename _CharT, typename _OutIter> inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len) {
        for (int __j = 0; __j < __len; __j++ , ++__s)
            *__s = __ws[__j];
        return __s;
    }
    template <typename _CharT> class __ctype_abstract_base : public locale::facet, public std::ctype_base {
    public:
        typedef _CharT char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const {
            return this->do_is(__m, __c);
        }
        const std::__ctype_abstract_base::char_type *is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const {
            return this->do_is(__lo, __hi, __vec);
        }
        const std::__ctype_abstract_base::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const {
            return this->do_scan_is(__m, __lo, __hi);
        }
        const std::__ctype_abstract_base::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const {
            return this->do_scan_not(__m, __lo, __hi);
        }
        std::__ctype_abstract_base::char_type toupper(std::__ctype_abstract_base::char_type __c) const {
            return this->do_toupper(__c);
        }
        const std::__ctype_abstract_base::char_type *toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const {
            return this->do_toupper(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type tolower(std::__ctype_abstract_base::char_type __c) const {
            return this->do_tolower(__c);
        }
        const std::__ctype_abstract_base::char_type *tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const {
            return this->do_tolower(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type widen(char __c) const {
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const {
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const {
            return this->do_narrow(__c, __dfault);
        }
        const std::__ctype_abstract_base::char_type *narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const {
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
    protected:
        explicit __ctype_abstract_base<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs) {
        }
        virtual ~__ctype_abstract_base<_CharT>() {
        }
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_toupper(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_tolower(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template<> class __ctype_abstract_base<wchar_t> : public locale::facet, public std::ctype_base {
    public:
        typedef wchar_t char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type widen(char __c) const;
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const;
        char narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
    protected:
        explicit __ctype_abstract_base(std::size_t __refs);
        virtual ~__ctype_abstract_base<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template <typename _CharT> class ctype : public __ctype_abstract_base<_CharT> {
    public:
        typedef _CharT char_type;
        typedef typename __ctype_abstract_base<_CharT>::mask mask;
        static locale::id id;
        explicit ctype<_CharT>(std::size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) {
        }
    protected:
        virtual ~ctype<_CharT>();
        virtual bool do_is(std::ctype::mask __m, std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_is(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, std::ctype::mask *__vec) const;
        virtual const std::ctype::char_type *do_scan_is(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual const std::ctype::char_type *do_scan_not(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_toupper(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_toupper(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_tolower(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_tolower(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype::char_type *__dest) const;
        virtual char do_narrow(std::ctype::char_type, char __dfault) const;
        virtual const std::ctype::char_type *do_narrow(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, char __dfault, char *__to) const;
    };
    locale::id id;
    template <typename _CharT, typename _Traits, typename _Alloc> class ctype<basic_string<_CharT, _Traits, _Alloc>>;
    template<> class ctype<char> : public locale::facet, public std::ctype_base {
    public:
        typedef char char_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_del;
        std::ctype_base::__to_type _M_toupper;
        std::ctype_base::__to_type _M_tolower;
        const std::ctype_base::mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const std::size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        inline bool is(std::ctype_base::mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, std::ctype_base::mask *__vec) const;
        inline const char *scan_is(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        std::ctype<char>::char_type toupper(std::ctype<char>::char_type __c) const {
            return this->do_toupper(__c);
        }
        const std::ctype<char>::char_type *toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const {
            return this->do_toupper(__lo, __hi);
        }
        std::ctype<char>::char_type tolower(std::ctype<char>::char_type __c) const {
            return this->do_tolower(__c);
        }
        const std::ctype<char>::char_type *tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const {
            return this->do_tolower(__lo, __hi);
        }
        std::ctype<char>::char_type widen(char __c) const {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const {
            if (this->_M_widen_ok == 1) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::ctype<char>::char_type __c, char __dfault) const {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }
        const std::ctype<char>::char_type *narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault, char *__to) const {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
        const std::ctype_base::mask *table() const throw() {
            return this->_M_table;
        }
        static const std::ctype_base::mask *classic_table() throw();
    protected:
        virtual ~ctype<char>() noexcept;
        virtual std::ctype<char>::char_type do_toupper(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_tolower(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_widen(char __c) const {
            return __c;
        }
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
        virtual char do_narrow(std::ctype<char>::char_type __c, char __dfault __attribute__((unused))) const {
            return __c;
        }
        virtual const std::ctype<char>::char_type *do_narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault __attribute__((unused)), char *__to) const {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    };
    template<> class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        std::ctype_base::mask _M_bit[16];
        std::ctype<wchar_t>::__wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, std::size_t __refs = 0);
    protected:
        std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const std::ctype_base::mask __m) const throw();
        virtual ~ctype<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_is(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_toupper(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_toupper(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_tolower(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_tolower(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<wchar_t>::char_type *__to) const;
        virtual char do_narrow(std::ctype<wchar_t>::char_type __c, char __dfault) const;
        virtual const std::ctype<wchar_t>::char_type *do_narrow(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    };
    template <typename _CharT> class ctype_byname : public ctype<_CharT> {
    public:
        typedef typename ctype<_CharT>::mask mask;
        explicit ctype_byname<_CharT>(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : ctype_byname<_CharT>(__s.c_str(), __refs) {
        }
    protected:
        virtual ~ctype_byname<_CharT>() {
        }
    };
    template<> class ctype_byname<char> : public ctype<char> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<char>() noexcept;
    };
    template<> class ctype_byname<wchar_t> : public ctype<wchar_t> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<wchar_t>() noexcept;
    };
}
namespace std {
    bool ctype<char>::is(std::ctype_base::mask __m, char __c) const {
        return this->_M_table[static_cast<unsigned char>(__c)] & __m;
    }
    const char *ctype<char>::is(const char *__low, const char *__high, std::ctype_base::mask *__vec) const {
        while (__low < __high)
            *__vec++ = this->_M_table[static_cast<unsigned char>(*__low++)];
        return __high;
    }
    const char *ctype<char>::scan_is(std::ctype_base::mask __m, const char *__low, const char *__high) const {
        while (__low < __high && !(this->_M_table[static_cast<unsigned char>(*__low)] & __m))
            ++__low;
        return __low;
    }
    const char *ctype<char>::scan_not(std::ctype_base::mask __m, const char *__low, const char *__high) const {
        while (__low < __high && (this->_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
            ++__low;
        return __low;
    }
}
namespace std {
    class __num_base {
    public:
        enum {
            _S_ominus,
            _S_oplus,
            _S_ox,
            _S_oX,
            _S_odigits,
            _S_odigits_end = _S_odigits + 16,
            _S_oudigits = _S_odigits_end,
            _S_oudigits_end = _S_oudigits + 16,
            _S_oe = _S_odigits + 14,
            _S_oE = _S_oudigits + 14,
            _S_oend = _S_oudigits_end
        };
        static const char *_S_atoms_out;
        static const char *_S_atoms_in;
        enum {
            _S_iminus,
            _S_iplus,
            _S_ix,
            _S_iX,
            _S_izero,
            _S_ie = _S_izero + 14,
            _S_iE = _S_izero + 20,
            _S_iend = 26
        };
        static void _S_format_float(const std::ios_base &__io, char *__fptr, char __mod) throw();
    };
    template <typename _CharT> struct __numpunct_cache : public locale::facet {
        const char *_M_grouping;
        std::size_t _M_grouping_size;
        bool _M_use_grouping;
        const _CharT *_M_truename;
        std::size_t _M_truename_size;
        const _CharT *_M_falsename;
        std::size_t _M_falsename_size;
        _CharT _M_decimal_point;
        _CharT _M_thousands_sep;
        _CharT _M_atoms_out[36];
        _CharT _M_atoms_in[26];
        bool _M_allocated;
        __numpunct_cache<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false) {
        }
        ~__numpunct_cache<_CharT>();
        void _M_cache(const std::locale &__loc);
    private:
        __numpunct_cache<_CharT> &operator=(const __numpunct_cache<_CharT> &);
        explicit __numpunct_cache<_CharT>(const __numpunct_cache<_CharT> &);
    };
    template <typename _CharT> __numpunct_cache<_CharT>::~__numpunct_cache<_CharT>() {
        if (this->_M_allocated) {
            delete [] this->_M_grouping;
            delete [] this->_M_truename;
            delete [] this->_M_falsename;
        }
    }
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            typedef __numpunct_cache<_CharT> __cache_type;
        protected:
            std::numpunct::__cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0) {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::numpunct::__cache_type *__cache, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(__cache) {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0) {
                this->_M_initialize_numpunct(__cloc);
            }
            std::numpunct::char_type decimal_point() const {
                return this->do_decimal_point();
            }
            std::numpunct::char_type thousands_sep() const {
                return this->do_thousands_sep();
            }
            std::string grouping() const {
                return this->do_grouping();
            }
            std::numpunct::string_type truename() const {
                return this->do_truename();
            }
            std::numpunct::string_type falsename() const {
                return this->do_falsename();
            }
        protected:
            virtual ~numpunct<_CharT>();
            virtual std::numpunct::char_type do_decimal_point() const {
                return this->_M_data->_M_decimal_point;
            }
            virtual std::numpunct::char_type do_thousands_sep() const {
                return this->_M_data->_M_thousands_sep;
            }
            virtual std::string do_grouping() const {
                return this->_M_data->_M_grouping;
            }
            virtual std::numpunct::string_type do_truename() const {
                return this->_M_data->_M_truename;
            }
            virtual std::numpunct::string_type do_falsename() const {
                return this->_M_data->_M_falsename;
            }
            void _M_initialize_numpunct(std::__c_locale __cloc = 0);
        };
        locale::id id;
        template <> numpunct<char>::~numpunct<char>() noexcept;
        template <> void numpunct<char>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <> numpunct<wchar_t>::~numpunct<wchar_t>() noexcept;
        template <> void numpunct<wchar_t>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <typename _CharT> class numpunct_byname : public numpunct<_CharT> {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit numpunct_byname<_CharT>(const char *__s, std::size_t __refs = 0) : numpunct<_CharT>(__refs) {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                    std::__c_locale __tmp;
                    this->_S_create_c_locale(__tmp, __s);
                    this->_M_initialize_numpunct(__tmp);
                    this->_S_destroy_c_locale(__tmp);
                }
            }
            explicit numpunct_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : numpunct_byname<_CharT>(__s.c_str(), __refs) {
            }
        protected:
            virtual ~numpunct_byname<_CharT>() {
            }
        };
    }
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _InIter iter_type;
        static locale::id id;
        explicit num_get<_CharT, _InIter>(std::size_t __refs = 0) : std::locale::facet(__refs) {
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
    protected:
        virtual ~num_get<_CharT, _InIter>() {
        }
        std::num_get::iter_type _M_extract_float(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get::iter_type _M_extract_int(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const {
            int __ret = -1;
            if (__len <= 10) {
                if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
                    __ret = __c - _CharT2('0');
            } else {
                if (__c >= _CharT2('0') && __c <= _CharT2('9'))
                    __ret = __c - _CharT2('0');
                else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                    __ret = 10 + (__c - _CharT2('a'));
                else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                    __ret = 10 + (__c - _CharT2('A'));
            }
            return __ret;
        }
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const {
            int __ret = -1;
            const std::num_get::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
            if (__q) {
                __ret = __q - __zero;
                if (__ret > 15)
                    __ret -= 6;
            }
            return __ret;
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    locale::id id;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _OutIter iter_type;
        static locale::id id;
        explicit num_put<_CharT, _OutIter>(std::size_t __refs = 0) : std::locale::facet(__refs) {
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
    protected:
        template <typename _ValueT> std::num_put::iter_type _M_insert_float(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, const std::num_put::char_type *__p, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put::iter_type _M_insert_int(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, std::ios_base &__io, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put::char_type *__new, const std::num_put::char_type *__cs, int &__len) const;
        virtual ~num_put<_CharT, _OutIter>() {
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, long double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, const void *) const;
    };
    locale::id id;
    template <typename _CharT> inline bool isspace(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space, __c);
    }
    template <typename _CharT> inline bool isprint(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print, __c);
    }
    template <typename _CharT> inline bool iscntrl(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl, __c);
    }
    template <typename _CharT> inline bool isupper(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper, __c);
    }
    template <typename _CharT> inline bool islower(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower, __c);
    }
    template <typename _CharT> inline bool isalpha(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha, __c);
    }
    template <typename _CharT> inline bool isdigit(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit, __c);
    }
    template <typename _CharT> inline bool ispunct(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct, __c);
    }
    template <typename _CharT> inline bool isxdigit(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit, __c);
    }
    template <typename _CharT> inline bool isalnum(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum, __c);
    }
    template <typename _CharT> inline bool isgraph(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph, __c);
    }
    template <typename _CharT> inline bool isblank(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::blank, __c);
    }
    template <typename _CharT> inline _CharT toupper(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).toupper(__c);
    }
    template <typename _CharT> inline _CharT tolower(_CharT __c, const std::locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).tolower(__c);
    }
}
namespace std {
    template <typename _Facet> struct __use_cache {
        const _Facet *operator()(const std::locale &__loc) const;
    };
    template <typename _CharT> struct __use_cache<__numpunct_cache<_CharT>> {
        const __numpunct_cache<_CharT> *operator()(const std::locale &__loc) const {
            const std::size_t __i = numpunct<_CharT>::id._M_id();
            const locale::facet **__caches = __loc._M_impl->_M_caches;
            if (!__caches[__i]) {
                __numpunct_cache<_CharT> *__tmp = 0;
                try {
                    __tmp = new __numpunct_cache<_CharT>;
                    __tmp->_M_cache(__loc);
                } catch (...) {
                    delete __tmp;
                    throw;
                }
                __loc._M_impl->_M_install_cache(__tmp, __i);
            }
            return static_cast<const __numpunct_cache<_CharT> *>(__caches[__i]);
        }
    };
    template <typename _CharT> void __numpunct_cache<_CharT>::_M_cache(const std::locale &__loc) {
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
        char *__grouping = 0;
        _CharT *__truename = 0;
        _CharT *__falsename = 0;
        try {
            const std::string &__g = __np.grouping();
            this->_M_grouping_size = __g.size();
            __grouping = new char [this->_M_grouping_size];
            __g.copy(__grouping, this->_M_grouping_size);
            this->_M_use_grouping = (this->_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0 && (__grouping[0] != __gnu_cxx::__numeric_traits<char>::__max));
            const basic_string<_CharT> &__tn = __np.truename();
            this->_M_truename_size = __tn.size();
            __truename = new _CharT [this->_M_truename_size];
            __tn.copy(__truename, this->_M_truename_size);
            const basic_string<_CharT> &__fn = __np.falsename();
            this->_M_falsename_size = __fn.size();
            __falsename = new _CharT [this->_M_falsename_size];
            __fn.copy(__falsename, this->_M_falsename_size);
            this->_M_decimal_point = __np.decimal_point();
            this->_M_thousands_sep = __np.thousands_sep();
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
            __ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, this->_M_atoms_out);
            __ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, this->_M_atoms_in);
            this->_M_grouping = __grouping;
            this->_M_truename = __truename;
            this->_M_falsename = __falsename;
            this->_M_allocated = true;
        } catch (...) {
            delete [] __grouping;
            delete [] __truename;
            delete [] __falsename;
            throw;
        }
    }
    bool __verify_grouping(const char *__grouping, std::size_t __grouping_size, const std::string &__grouping_tmp) throw() __attribute__((pure));
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, std::string &__xtrc) const __attribute__((abi_tag("cxx11"))) {
        typedef char_traits<_CharT> __traits_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        bool __testeof = __beg == __end;
        if (!__testeof) {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                __xtrc += __plus ? '+' : '-';
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_mantissa = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero]) {
                    if (!__found_mantissa) {
                        __xtrc += '0';
                        __found_mantissa = true;
                    }
                    ++__sep_pos;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                } else
                    break;
            }
        bool __found_dec = false;
        bool __found_sci = false;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    const int __digit = _M_find(__lit_zero, 10, __c);
                    if (__digit != -1) {
                        __xtrc += '0' + __digit;
                        __found_mantissa = true;
                    } else if (__c == __lc->_M_decimal_point && !__found_dec && !__found_sci) {
                        __xtrc += '.';
                        __found_dec = true;
                    } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                        __xtrc += 'e';
                        __found_sci = true;
                        if (++__beg != __end) {
                            __c = *__beg;
                            const bool __plus = __c == __lit[__num_base::_S_iplus];
                            if (__plus || __c == __lit[__num_base::_S_iminus])
                                __xtrc += __plus ? '+' : '-';
                            else
                                continue;
                        } else {
                            __testeof = true;
                            break;
                        }
                    } else
                        break;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (!__found_dec && !__found_sci) {
                            if (__sep_pos) {
                                __found_grouping += static_cast<char>(__sep_pos);
                                __sep_pos = 0;
                            } else {
                                __xtrc.clear();
                                break;
                            }
                        } else
                            break;
                    } else if (__c == __lc->_M_decimal_point) {
                        if (!__found_dec && !__found_sci) {
                            if (__found_grouping.size())
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += '.';
                            __found_dec = true;
                        } else
                            break;
                    } else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                        if (__q) {
                            __xtrc += '0' + (__q - __lit_zero);
                            __found_mantissa = true;
                            ++__sep_pos;
                        } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                            if (__found_grouping.size() && !__found_dec)
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end) {
                                __c = *__beg;
                                const bool __plus = __c == __lit[__num_base::_S_iplus];
                                if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
                                    __xtrc += __plus ? '+' : '-';
                                else
                                    continue;
                            } else {
                                __testeof = true;
                                break;
                            }
                        } else
                            break;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            if (!__found_dec && !__found_sci)
                __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> template <typename _ValueT> _InIter num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, _ValueT &__v) const __attribute__((abi_tag("cxx11"))) {
        typedef char_traits<_CharT> __traits_type;
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
        const bool __oct = __basefield == ios_base::oct;
        int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
        bool __testeof = __beg == __end;
        bool __negative = false;
        if (!__testeof) {
            __c = *__beg;
            __negative = __c == __lit[__num_base::_S_iminus];
            if ((__negative || __c == __lit[__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_zero = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero] && (!__found_zero || __base == 10)) {
                    __found_zero = true;
                    ++__sep_pos;
                    if (__basefield == 0)
                        __base = 8;
                    if (__base == 8)
                        __sep_pos = 0;
                } else if (__found_zero && (__c == __lit[__num_base::_S_ix] || __c == __lit[__num_base::_S_iX])) {
                    if (__basefield == 0)
                        __base = 16;
                    if (__base == 16) {
                        __found_zero = false;
                        __sep_pos = 0;
                    } else
                        break;
                } else
                    break;
                if (++__beg != __end) {
                    __c = *__beg;
                    if (!__found_zero)
                        break;
                } else
                    __testeof = true;
            }
        const std::size_t __len = (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);
        typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        bool __testfail = false;
        bool __testoverflow = false;
        const __unsigned_type __max = (__negative && __num_traits::__is_signed) ? - static_cast<__unsigned_type>(__num_traits::__min) : __num_traits::__max;
        const __unsigned_type __smax = __max / __base;
        __unsigned_type __result = 0;
        int __digit = 0;
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    __digit = _M_find(__lit_zero, __len, __c);
                    if (__digit == -1)
                        break;
                    if (__result > __smax)
                        __testoverflow = true;
                    else {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                        ++__sep_pos;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (__sep_pos) {
                            __found_grouping += static_cast<char>(__sep_pos);
                            __sep_pos = 0;
                        } else {
                            __testfail = true;
                            break;
                        }
                    } else if (__c == __lc->_M_decimal_point)
                        break;
                    else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                        if (!__q)
                            break;
                        __digit = __q - __lit_zero;
                        if (__digit > 15)
                            __digit -= 6;
                        if (__result > __smax)
                            __testoverflow = true;
                        else {
                            __result *= __base;
                            __testoverflow |= __result > __max - __digit;
                            __result += __digit;
                            ++__sep_pos;
                        }
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        if ((!__sep_pos && !__found_zero && !__found_grouping.size()) || __testfail) {
            __v = 0;
            __err = ios_base::failbit;
        } else if (__testoverflow) {
            if (__negative && __num_traits::__is_signed)
                __v = __num_traits::__min;
            else
                __v = __num_traits::__max;
            __err = ios_base::failbit;
        } else
            __v = __negative ? - __result : __result;
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const {
        if (!(__io.flags() & ios_base::boolalpha)) {
            long __l = -1;
            __beg = _M_extract_int(__beg, __end, __io, __err, __l);
            if (__l == 0 || __l == 1)
                __v = bool(__l);
            else {
                __v = true;
                __err = ios_base::failbit;
                if (__beg == __end)
                    __err |= ios_base::eofbit;
            }
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            bool __testf = true;
            bool __testt = true;
            bool __donef = __lc->_M_falsename_size == 0;
            bool __donet = __lc->_M_truename_size == 0;
            bool __testeof = false;
            std::size_t __n = 0;
            while (!__donef || !__donet)
                {
                    if (__beg == __end) {
                        __testeof = true;
                        break;
                    }
                    const std::num_get::char_type __c = *__beg;
                    if (!__donef)
                        __testf = __c == __lc->_M_falsename[__n];
                    if (!__testf && __donet)
                        break;
                    if (!__donet)
                        __testt = __c == __lc->_M_truename[__n];
                    if (!__testt && __donef)
                        break;
                    if (!__testt && !__testf)
                        break;
                    ++__n;
                    ++__beg;
                    __donef = !__testf || __n >= __lc->_M_falsename_size;
                    __donet = !__testt || __n >= __lc->_M_truename_size;
                }
            if (__testf && __n == __lc->_M_falsename_size && __n) {
                __v = false;
                if (__testt && __n == __lc->_M_truename_size)
                    __err = ios_base::failbit;
                else
                    __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else if (__testt && __n == __lc->_M_truename_size && __n) {
                __v = true;
                __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else {
                __v = false;
                __err = ios_base::failbit;
                if (__testeof)
                    __err |= ios_base::eofbit;
            }
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const {
        typedef ios_base::fmtflags fmtflags;
        const fmtflags __fmt = __io.flags();
        __io.flags((__fmt & ~ ios_base::basefield) | ios_base::hex);
        typedef __gnu_cxx::__conditional_type<(sizeof(void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        _UIntPtrType __ul;
        __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
        __io.flags(__fmt);
        __v = reinterpret_cast<void *>(__ul);
        return __beg;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, std::streamsize __w, std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const {
        __pad<_CharT, char_traits<_CharT>>::_S_pad(__io, __fill, __new, __cs, __w, __len);
        __len = static_cast<int>(__w);
    }
    template <typename _CharT, typename _ValueT> int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags __flags, bool __dec) {
        _CharT *__buf = __bufend;
        if (__builtin_expect(__dec, true)) {
            do {
                *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
                __v /= 10;
            } while (__v != 0);
        } else if ((__flags & ios_base::basefield) == ios_base::oct) {
            do {
                *--__buf = __lit[(__v & 7) + __num_base::_S_odigits];
                __v >>= 3;
            } while (__v != 0);
        } else {
            const bool __uppercase = __flags & ios_base::uppercase;
            const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
            do {
                *--__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
            } while (__v != 0);
        }
        return __bufend - __buf;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, std::size_t __grouping_size, _CharT __sep, std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const {
        _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
        __len = __p - __new;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, std::ios_base &__io, _CharT __fill, _ValueT __v) const {
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_out;
        const ios_base::fmtflags __flags = __io.flags();
        const int __ilen = 5 * sizeof(_ValueT);
        _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
        const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
        const bool __dec = (__basefield != ios_base::oct && __basefield != ios_base::hex);
        const __unsigned_type __u = ((__v > 0 || !__dec) ? __unsigned_type(__v) : - __unsigned_type(__v));
        int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
        __cs += __ilen - __len;
        if (__lc->_M_use_grouping) {
            _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
            this->_M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
            __cs = __cs2 + 2;
        }
        if (__builtin_expect(__dec, true)) {
            if (__v >= 0) {
                if (bool(__flags & ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
                    *--__cs = __lit[__num_base::_S_oplus] , ++__len;
            } else
                *--__cs = __lit[__num_base::_S_ominus] , ++__len;
        } else if (bool(__flags & ios_base::showbase) && __v) {
            if (__basefield == ios_base::oct)
                *--__cs = __lit[__num_base::_S_odigits] , ++__len;
            else {
                const bool __uppercase = __flags & ios_base::uppercase;
                *--__cs = __lit[__num_base::_S_ox + __uppercase];
                *--__cs = __lit[__num_base::_S_odigits];
                __len += 2;
            }
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
        }
        __io.width(0);
        return std::__write(__s, __cs, __len);
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const {
        const int __declen = __p ? __p - __cs : __len;
        _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
        int __newlen = __p2 - __new;
        if (__p) {
            char_traits<_CharT>::copy(__p2, __p, __len - __declen);
            __newlen += __len - __declen;
        }
        __len = __newlen;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const {
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const std::streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
        const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
        int __len;
        char __fbuf[16];
        __num_base::_S_format_float(__io, __fbuf, __mod);
        const bool __use_prec = (__io.flags() & ios_base::floatfield) != ios_base::floatfield;
        int __cs_size = __max_digits * 3;
        char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        else
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        if (__len >= __cs_size) {
            __cs_size = __len + 1;
            __cs = static_cast<char *>(__builtin_alloca(__cs_size));
            if (__use_prec)
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
            else
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        }
        const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
        _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
        __ctype.widen(__cs, __cs + __len, __ws);
        _CharT *__wp = 0;
        const char *__p = char_traits<char>::find(__cs, __len, '.');
        if (__p) {
            __wp = __ws + (__p - __cs);
            *__wp = __lc->_M_decimal_point;
        }
        if (__lc->_M_use_grouping && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9' && __cs[1] >= '0' && __cs[2] >= '0'))) {
            _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
            std::streamsize __off = 0;
            if (__cs[0] == '-' || __cs[0] == '+') {
                __off = 1;
                __ws2[0] = __ws[0];
                __len -= 1;
            }
            this->_M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
            __len += __off;
            __ws = __ws2;
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __ws3, __ws, __len);
            __ws = __ws3;
        }
        __io.width(0);
        return std::__write(__s, __ws, __len);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const {
        const ios_base::fmtflags __flags = __io.flags();
        if ((__flags & ios_base::boolalpha) == 0) {
            const long __l = __v;
            __s = _M_insert_int(__s, __io, __fill, __l);
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
            int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
            const std::streamsize __w = __io.width();
            if (__w > static_cast<std::streamsize>(__len)) {
                const std::streamsize __plen = __w - __len;
                _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
                char_traits<_CharT>::assign(__ps, __plen, __fill);
                __io.width(0);
                if ((__flags & ios_base::adjustfield) == ios_base::left) {
                    __s = std::__write(__s, __name, __len);
                    __s = std::__write(__s, __ps, __plen);
                } else {
                    __s = std::__write(__s, __ps, __plen);
                    __s = std::__write(__s, __name, __len);
                }
                return __s;
            }
            __io.width(0);
            __s = std::__write(__s, __name, __len);
        }
        return __s;
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const {
        return _M_insert_float(__s, __io, __fill, char(), __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const {
        return _M_insert_float(__s, __io, __fill, 'L', __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const {
        const ios_base::fmtflags __flags = __io.flags();
        const ios_base::fmtflags __fmt = ~ (ios_base::basefield | ios_base::uppercase);
        __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
        typedef __gnu_cxx::__conditional_type<(sizeof(const void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
        __io.flags(__flags);
        return __s;
    }
    template <typename _CharT, typename _Traits> void __pad<_CharT, _Traits>::_S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen) {
        const std::size_t __plen = static_cast<std::size_t>(__newlen - __oldlen);
        const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
        if (__adjust == ios_base::left) {
            _Traits::copy(__news, __olds, __oldlen);
            _Traits::assign(__news + __oldlen, __plen, __fill);
            return;
        }
        std::size_t __mod = 0;
        if (__adjust == ios_base::internal) {
            const std::locale &__loc = __io._M_getloc();
            const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
            if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0]) {
                __news[0] = __olds[0];
                __mod = 1;
                ++__news;
            } else if (__ctype.widen('0') == __olds[0] && __oldlen > 1 && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1])) {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
            }
        }
        _Traits::assign(__news, __plen, __fill);
        _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last) {
        std::size_t __idx = 0;
        std::size_t __ctr = 0;
        while (__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0 && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
            {
                __last -= __gbeg[__idx];
                __idx < __gsize - 1 ? ++__idx : ++__ctr;
            }
        while (__first != __last)
            *__s++ = *__first++;
        while (__ctr--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        while (__idx--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        return __s;
    }
    template<> class numpunct<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        typedef __numpunct_cache<char> __cache_type;
    protected:
        std::numpunct<char>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::numpunct<char>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::numpunct<char>::char_type decimal_point() const;
        std::numpunct<char>::char_type thousands_sep() const;
        std::string grouping() const;
        std::numpunct<char>::string_type truename() const;
        std::numpunct<char>::string_type falsename() const;
    protected:
        virtual ~numpunct<char>() noexcept;
        virtual std::numpunct<char>::char_type do_decimal_point() const;
        virtual std::numpunct<char>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::numpunct<char>::string_type do_truename() const;
        virtual std::numpunct<char>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<char> : public numpunct<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<char>() noexcept;
    };
    template<> class num_get<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char> iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<char>::iter_type get(std::num_get<char>::iter_type __in, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<char>() noexcept;
        std::num_get<char>::iter_type _M_extract_float(std::num_get<char>::iter_type, std::num_get<char>::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<char>::iter_type _M_extract_int(std::num_get<char>::iter_type, std::num_get<char>::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type, std::num_get<char>::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type __beg, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type __beg, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type __beg, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type __beg, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type __beg, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type __beg, std::num_get<char>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type, std::num_get<char>::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type, std::num_get<char>::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type, std::num_get<char>::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<char>::iter_type do_get(std::num_get<char>::iter_type, std::num_get<char>::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char> iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, bool __v) const;
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, long __v) const;
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, unsigned long __v) const;
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, long long __v) const;
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, unsigned long long __v) const;
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, double __v) const;
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, long double __v) const;
        std::num_put<char>::iter_type put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<char>::iter_type _M_insert_float(std::num_put<char>::iter_type, std::ios_base &__io, std::num_put<char>::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<char>::char_type __sep, const std::num_put<char>::char_type *__p, std::num_put<char>::char_type *__new, std::num_put<char>::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<char>::iter_type _M_insert_int(std::num_put<char>::iter_type, std::ios_base &__io, std::num_put<char>::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<char>::char_type __sep, std::ios_base &__io, std::num_put<char>::char_type *__new, std::num_put<char>::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<char>::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<char>::char_type *__new, const std::num_put<char>::char_type *__cs, int &__len) const;
        virtual ~num_put<char>() noexcept;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, bool __v) const;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, long __v) const;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, unsigned long __v) const;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, long long __v) const;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type __s, std::ios_base &__io, std::num_put<char>::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type, std::ios_base &, std::num_put<char>::char_type, double) const;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type, std::ios_base &, std::num_put<char>::char_type, long double) const;
        virtual std::num_put<char>::iter_type do_put(std::num_put<char>::iter_type, std::ios_base &, std::num_put<char>::char_type, const void *) const;
    };
    template<> class ctype_byname<char>;
    template<> class numpunct<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        typedef __numpunct_cache<wchar_t> __cache_type;
    protected:
        std::numpunct<wchar_t>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::numpunct<wchar_t>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::numpunct<wchar_t>::char_type decimal_point() const;
        std::numpunct<wchar_t>::char_type thousands_sep() const;
        std::string grouping() const;
        std::numpunct<wchar_t>::string_type truename() const;
        std::numpunct<wchar_t>::string_type falsename() const;
    protected:
        virtual ~numpunct<wchar_t>() noexcept;
        virtual std::numpunct<wchar_t>::char_type do_decimal_point() const;
        virtual std::numpunct<wchar_t>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::numpunct<wchar_t>::string_type do_truename() const;
        virtual std::numpunct<wchar_t>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<wchar_t> : public numpunct<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<wchar_t>() noexcept;
    };
    template<> class num_get<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t> iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<wchar_t>::iter_type get(std::num_get<wchar_t>::iter_type __in, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<wchar_t>() noexcept;
        std::num_get<wchar_t>::iter_type _M_extract_float(std::num_get<wchar_t>::iter_type, std::num_get<wchar_t>::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<wchar_t>::iter_type _M_extract_int(std::num_get<wchar_t>::iter_type, std::num_get<wchar_t>::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type, std::num_get<wchar_t>::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type __beg, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type __beg, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type __beg, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type __beg, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type __beg, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type __beg, std::num_get<wchar_t>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type, std::num_get<wchar_t>::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type, std::num_get<wchar_t>::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type, std::num_get<wchar_t>::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<wchar_t>::iter_type do_get(std::num_get<wchar_t>::iter_type, std::num_get<wchar_t>::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t> iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, bool __v) const;
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, long __v) const;
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, unsigned long __v) const;
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, long long __v) const;
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, unsigned long long __v) const;
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, double __v) const;
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, long double __v) const;
        std::num_put<wchar_t>::iter_type put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<wchar_t>::iter_type _M_insert_float(std::num_put<wchar_t>::iter_type, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t>::char_type __sep, const std::num_put<wchar_t>::char_type *__p, std::num_put<wchar_t>::char_type *__new, std::num_put<wchar_t>::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<wchar_t>::iter_type _M_insert_int(std::num_put<wchar_t>::iter_type, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t>::char_type __sep, std::ios_base &__io, std::num_put<wchar_t>::char_type *__new, std::num_put<wchar_t>::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<wchar_t>::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<wchar_t>::char_type *__new, const std::num_put<wchar_t>::char_type *__cs, int &__len) const;
        virtual ~num_put<wchar_t>() noexcept;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, bool __v) const;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, long __v) const;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, unsigned long __v) const;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, long long __v) const;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t>::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type, std::ios_base &, std::num_put<wchar_t>::char_type, double) const;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type, std::ios_base &, std::num_put<wchar_t>::char_type, long double) const;
        virtual std::num_put<wchar_t>::iter_type do_put(std::num_put<wchar_t>::iter_type, std::ios_base &, std::num_put<wchar_t>::char_type, const void *) const;
    };
    template<> class ctype_byname<wchar_t>;
}
namespace std {
    template <typename _Facet> inline const _Facet &__check_facet(const _Facet *__f) {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template<> inline const std::ctype<char> &__check_facet<std::ctype<char>>(const std::ctype<char> *__f) {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios : public std::ios_base {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef ctype<_CharT> __ctype_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
    protected:
        basic_ostream<_CharT, _Traits> *_M_tie;
        mutable std::basic_ios::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<_CharT, _Traits> *_M_streambuf;
        const std::basic_ios::__ctype_type *_M_ctype;
        const std::basic_ios::__num_put_type *_M_num_put;
        const std::basic_ios::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const {
            return !this->fail();
        }
        bool operator!() const {
            return this->fail();
        }
        std::ios_base::iostate rdstate() const {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state = goodbit);
        void setstate(std::ios_base::iostate __state) {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state) {
            this->_M_streambuf_state |= __state;
            if (this->exceptions() & __state)
                throw;
        }
        bool good() const {
            return this->rdstate() == 0;
        }
        bool eof() const {
            return (this->rdstate() & eofbit) != 0;
        }
        bool fail() const {
            return (this->rdstate() & (badbit | failbit)) != 0;
        }
        bool bad() const {
            return (this->rdstate() & badbit) != 0;
        }
        std::ios_base::iostate exceptions() const {
            return this->_M_exception;
        }
        void exceptions(std::ios_base::iostate __except) {
            this->_M_exception = __except;
            this->clear(this->_M_streambuf_state);
        }
        explicit basic_ios<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) {
            this->init(__sb);
        }
        virtual ~basic_ios<_CharT, _Traits>() {
        }
        basic_ostream<_CharT, _Traits> *tie() const {
            return this->_M_tie;
        }
        basic_ostream<_CharT, _Traits> *tie(basic_ostream<_CharT, _Traits> *__tiestr) {
            basic_ostream<_CharT, _Traits> *__old = this->_M_tie;
            this->_M_tie = __tiestr;
            return __old;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf() const {
            return this->_M_streambuf;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
        std::basic_ios::char_type fill() const {
            if (!this->_M_fill_init) {
                this->_M_fill = this->widen(' ');
                this->_M_fill_init = true;
            }
            return this->_M_fill;
        }
        std::basic_ios::char_type fill(std::basic_ios::char_type __ch) {
            std::basic_ios::char_type __old = this->fill();
            this->_M_fill = __ch;
            return __old;
        }
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios::char_type __c, char __dfault) const {
            return __check_facet(this->_M_ctype).narrow(__c, __dfault);
        }
        std::basic_ios::char_type widen(char __c) const {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios<_CharT, _Traits>() : std::ios_base(), _M_tie(0), _M_fill(std::basic_ios::char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) {
        }
        void init(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits>(const basic_ios<_CharT, _Traits> &) = delete
        basic_ios<_CharT, _Traits> &operator=(const basic_ios<_CharT, _Traits> &) = delete
        void move(basic_ios<_CharT, _Traits> &__rhs) {
            this->ios_base::_M_move(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            this->tie(__rhs.tie(nullptr));
            this->_M_fill = __rhs._M_fill;
            this->_M_fill_init = __rhs._M_fill_init;
            this->_M_streambuf = nullptr;
        }
        void move(basic_ios<_CharT, _Traits> &&__rhs) {
            this->move(__rhs);
        }
        void swap(basic_ios<_CharT, _Traits> &__rhs) noexcept {
            this->ios_base::_M_swap(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            __rhs._M_cache_locale(__rhs._M_ios_locale);
            std::swap(this->_M_tie, __rhs._M_tie);
            std::swap(this->_M_fill, __rhs._M_fill);
            std::swap(this->_M_fill_init, __rhs._M_fill_init);
        }
        void set_rdbuf(basic_streambuf<_CharT, _Traits> *__sb) {
            this->_M_streambuf = __sb;
        }
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::clear(std::ios_base::iostate __state = goodbit) {
        if (this->rdbuf())
            this->_M_streambuf_state = __state;
        else
            this->_M_streambuf_state = __state | badbit;
        if (this->exceptions() & this->rdstate())
            __throw_ios_failure(("basic_ios::clear"));
    }
    template <typename _CharT, typename _Traits> basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits> *__sb) {
        basic_streambuf<_CharT, _Traits> *__old = this->_M_streambuf;
        this->_M_streambuf = __sb;
        this->clear();
        return __old;
    }
    template <typename _CharT, typename _Traits> basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits> &__rhs) {
        if (this != std::__addressof(__rhs)) {
            std::ios_base::_Words *__words = (__rhs._M_word_size <= _S_local_word_size) ? this->_M_local_word : new std::ios_base::_Words [__rhs._M_word_size];
            std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
            if (__cb)
                __cb->_M_add_reference();
            this->_M_call_callbacks(erase_event);
            if (this->_M_word != this->_M_local_word) {
                delete [] this->_M_word;
                this->_M_word = 0;
            }
            this->_M_dispose_callbacks();
            this->_M_callbacks = __cb;
            for (int __i = 0; __i < __rhs._M_word_size; ++__i)
                __words[__i] = __rhs._M_word[__i];
            this->_M_word = __words;
            this->_M_word_size = __rhs._M_word_size;
            this->flags(__rhs.flags());
            this->width(__rhs.width());
            this->precision(__rhs.precision());
            this->tie(__rhs.tie());
            this->fill(__rhs.fill());
            this->_M_ios_locale = __rhs.getloc();
            this->_M_cache_locale(this->_M_ios_locale);
            this->_M_call_callbacks(copyfmt_event);
            this->exceptions(__rhs.exceptions());
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::locale basic_ios<_CharT, _Traits>::imbue(const std::locale &__loc) {
        std::locale __old(this->getloc());
        this->ios_base::imbue(__loc);
        this->_M_cache_locale(__loc);
        if (this->rdbuf() != 0)
            this->rdbuf()->pubimbue(__loc);
        return __old;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits> *__sb) {
        this->ios_base::_M_init();
        this->_M_cache_locale(this->_M_ios_locale);
        this->_M_fill = _CharT();
        this->_M_fill_init = false;
        this->_M_tie = 0;
        this->_M_exception = goodbit;
        this->_M_streambuf = __sb;
        this->_M_streambuf_state = __sb ? goodbit : badbit;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::_M_cache_locale(const std::locale &__loc) {
        if (__builtin_expect(has_facet<std::basic_ios::__ctype_type>(__loc), true))
            this->_M_ctype = std::__addressof(use_facet<std::basic_ios::__ctype_type>(__loc));
        else
            this->_M_ctype = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_put_type>(__loc), true))
            this->_M_num_put = std::__addressof(use_facet<std::basic_ios::__num_put_type>(__loc));
        else
            this->_M_num_put = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_get_type>(__loc), true))
            this->_M_num_get = std::__addressof(use_facet<std::basic_ios::__num_get_type>(__loc));
        else
            this->_M_num_get = 0;
    }
    template<> class basic_ios<char> : public std::ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char>>> __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char>>> __num_get_type;
    protected:
        basic_ostream<char, std::char_traits<char>> *_M_tie;
        mutable std::basic_ios<char>::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, std::char_traits<char>> *_M_streambuf;
        const std::basic_ios<char>::__ctype_type *_M_ctype;
        const std::basic_ios<char>::__num_put_type *_M_num_put;
        const std::basic_ios<char>::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state) {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<char, std::char_traits<char>> *__sb);
        virtual ~basic_ios<char>() throw() {
        }
        basic_ostream<char, std::char_traits<char>> *tie() const;
        basic_ostream<char, std::char_traits<char>> *tie(basic_ostream<char, std::char_traits<char>> *__tiestr);
        basic_streambuf<char, std::char_traits<char>> *rdbuf() const;
        basic_streambuf<char, std::char_traits<char>> *rdbuf(basic_streambuf<char, std::char_traits<char>> *__sb);
        std::basic_ios<char> &copyfmt(const std::basic_ios<char> &__rhs);
        std::basic_ios<char>::char_type fill() const;
        std::basic_ios<char>::char_type fill(std::basic_ios<char>::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<char>::char_type __c, char __dfault) const;
        std::basic_ios<char>::char_type widen(char __c) const {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios() : std::ios_base(), _M_tie(0), _M_fill(std::basic_ios<char>::char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) {
        }
        void init(basic_streambuf<char, std::char_traits<char>> *__sb);
        basic_ios(const std::basic_ios<char> &) = delete
        std::basic_ios<char> &operator=(const std::basic_ios<char> &) = delete
        void move(std::basic_ios<char> &__rhs);
        void move(std::basic_ios<char> &&__rhs);
        void swap(std::basic_ios<char> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<char, std::char_traits<char>> *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
    template<> class basic_ios<wchar_t> : public std::ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_get_type;
    protected:
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *_M_tie;
        mutable std::basic_ios<wchar_t>::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *_M_streambuf;
        const std::basic_ios<wchar_t>::__ctype_type *_M_ctype;
        const std::basic_ios<wchar_t>::__num_put_type *_M_num_put;
        const std::basic_ios<wchar_t>::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const;
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state);
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        virtual ~basic_ios<wchar_t>() throw();
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *tie() const;
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *tie(basic_ostream<wchar_t, std::char_traits<wchar_t>> *__tiestr);
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *rdbuf() const;
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        std::basic_ios<wchar_t> &copyfmt(const std::basic_ios<wchar_t> &__rhs);
        std::basic_ios<wchar_t>::char_type fill() const;
        std::basic_ios<wchar_t>::char_type fill(std::basic_ios<wchar_t>::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<wchar_t>::char_type __c, char __dfault) const;
        std::basic_ios<wchar_t>::char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        basic_ios(const std::basic_ios<wchar_t> &) = delete
        std::basic_ios<wchar_t> &operator=(const std::basic_ios<wchar_t> &) = delete
        void move(std::basic_ios<wchar_t> &__rhs);
        void move(std::basic_ios<wchar_t> &&__rhs);
        void swap(std::basic_ios<wchar_t> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef ctype<_CharT> __ctype_type;
        explicit basic_ostream<_CharT, _Traits>(std::basic_ostream::__streambuf_type *__sb) {
            this->init(__sb);
        }
        virtual ~basic_ostream<_CharT, _Traits>() {
        }
        class sentry;
        friend  class sentry;
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ostream_type &(*__pf)(std::basic_ostream::__ostream_type &)) {
            return __pf(*this);
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ios_type &(*__pf)(std::basic_ostream::__ios_type &)) {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &)) {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(long __n) {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long __n) {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(bool __n) {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(short __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned short __n) {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(int __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned int __n) {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(long long __n) {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long long __n) {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(double __f) {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(float __f) {
            return _M_insert(static_cast<double>(__f));
        }
        std::basic_ostream::__ostream_type &operator<<(long double __f) {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(const void *__p) {
            return _M_insert(__p);
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__streambuf_type *__sb);
        std::basic_ostream::__ostream_type &put(std::basic_ostream::char_type __c);
        std::basic_ostream::__ostream_type &write(const std::basic_ostream::char_type *__s, std::streamsize __n);
        std::basic_ostream::__ostream_type &flush();
        std::basic_ostream::pos_type tellp();
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::pos_type);
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::off_type, ios_base::seekdir);
    protected:
        basic_ostream<_CharT, _Traits>() {
            this->init(0);
        }
        basic_ostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &) {
        }
        basic_ostream<_CharT, _Traits>(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits>(basic_ostream<_CharT, _Traits> &&__rhs) : std::basic_ostream::__ios_type() {
            __ios_type::move(__rhs);
        }
        basic_ostream<_CharT, _Traits> &operator=(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits> &operator=(basic_ostream<_CharT, _Traits> &&__rhs) {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_ostream<_CharT, _Traits> &__rhs) {
            __ios_type::swap(__rhs);
        }
        template <typename _ValueT> std::basic_ostream::__ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const std::basic_ostream::char_type *__s, std::streamsize __n) {
            std::__ostream_insert(*this, __s, __n);
        }
    };
    class sentry {
        bool _M_ok;
        basic_ostream<_CharT, _Traits> &_M_os;
    public:
        explicit sentry(basic_ostream<_CharT, _Traits> &__os);
        ~sentry() {
            if (bool(this->_M_os.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                if (this->_M_os.rdbuf() && this->_M_os.rdbuf()->pubsync() == -1)
                    this->_M_os.setstate(ios_base::badbit);
            }
        }
        explicit operator bool() const {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, _CharT __c) {
        if (__out.width() != 0)
            return __ostream_insert(__out, & __c, 1);
        __out.put(__c);
        return __out;
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, char __c)    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, char __c) {
        return (__out << __out.widen(__c));
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, char __c)    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, char __c) {
        if (__out.width() != 0)
            return __ostream_insert(__out, &__c, 1);
        __out.put(__c);
        return __out;
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, signed char __c) {
        return (__out << static_cast<char>(__c));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, unsigned char __c) {
        return (__out << static_cast<char>(__c));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s) {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, const char *__s)    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s);
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const char *__s) {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const signed char *__s) {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const unsigned char *__s) {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os) {
        return flush(__os.put(__os.widen('\n')));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os) {
        return __os.put(_CharT());
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os) {
        return __os.flush();
    }
    template <typename _Tp> using _Require_derived_from_ios_base = _Require<is_class<_Tp>, __not_<is_same<_Tp, std::ios_base>>, is_convertible<typename add_pointer<_Tp>::type, std::ios_base *>>;
    template <typename _Os, typename _Tp, typename = _Require_derived_from_ios_base<_Os>, typename = decltype(std::declval<_Os &>() << std::declval<const _Tp &>())> using __rvalue_stream_insertion_t = _Os &&;
    template <typename _Ostream, typename _Tp> inline __rvalue_stream_insertion_t<_Ostream, _Tp> operator<<(_Ostream &&__os, const _Tp &__x) {
        __os << __x;
        return std::move(__os);
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits> &__os) : _M_ok(false), _M_os(__os) {
        if (__os.tie() && __os.good())
            __os.tie()->flush();
        if (__os.good())
            this->_M_ok = true;
        else if (__os.bad())
            __os.setstate(ios_base::failbit);
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v) {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::__num_put_type &__np = __check_facet(this->_M_num_put);
                if (__np.put(*this, *this, this->fill(), __v).failed())
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(short __n) {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(int __n) {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream::__streambuf_type *__sbin) {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb && __sbin) {
            try {
                if (!__copy_streambufs(__sbin, this->rdbuf()))
                    __err |= ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbin)
            __err |= ios_base::badbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(std::basic_ostream::char_type __c) {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::int_type __put = this->rdbuf()->sputc(__c);
                if (traits_type::eq_int_type(__put, traits_type::eof()))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, std::streamsize __n) {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (this->rdbuf()->sputn(__s, __n) != __n)
                    __err = ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(ios_base::badbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush() {
        if (std::basic_ostream::__streambuf_type *__buf = this->rdbuf()) {
            std::basic_ostream::sentry __cerb(*this);
            if (__cerb) {
                ios_base::iostate __err = ios_base::goodbit;
                try {
                    if (this->rdbuf()->pubsync() == -1)
                        __err |= ios_base::badbit;
                } catch (__cxxabiv1::__forced_unwind &) {
                    this->_M_setstate(ios_base::badbit);
                    throw;
                } catch (...) {
                    this->_M_setstate(ios_base::badbit);
                }
                if (__err)
                    this->setstate(__err);
            }
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp() {
        std::basic_ostream::sentry __cerb(*this);
        std::basic_ostream::pos_type __ret = std::basic_ostream::pos_type(-1);
        if (!this->fail())
            __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::pos_type __pos) {
        std::basic_ostream::sentry __cerb(*this);
        if (!this->fail()) {
            const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
            if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::off_type __off, ios_base::seekdir __dir) {
        std::basic_ostream::sentry __cerb(*this);
        if (!this->fail()) {
            const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
            if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s) {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else {
            const std::size_t __clen = char_traits<char>::length(__s);
            try {
                struct __ptr_guard {
                    _CharT *__p;
                    __ptr_guard(_CharT *__ip) : __p(__ip) {
                    }
                    ~__ptr_guard() {
                        delete [] this->__p;
                    }
                    _CharT *__get() {
                        return this->__p;
                    }
                } __pg(new _CharT [__clen]);
                _CharT *__ws = __pg.__get();
                for (std::size_t __i = 0; __i < __clen; ++__i)
                    __ws[__i] = __out.widen(__s[__i]);
                __ostream_insert(__out, __ws, __clen);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(ios_base::badbit);
            }
        }
        return __out;
    }
    template<> basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, const char *__s)    template<> class basic_ostream<char> : virtual public basic_ios<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
        typedef basic_ios<char, std::char_traits<char>> __ios_type;
        typedef basic_ostream<char, std::char_traits<char>> __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char>>> __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(std::basic_ostream<char>::__streambuf_type *__sb);
        virtual ~basic_ostream<char>() throw() {
        }
        class sentry {
            bool _M_ok;
            basic_ostream<char, std::char_traits<char>> &_M_os;
        public:
            explicit sentry(basic_ostream<char, std::char_traits<char>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<char>::__ostream_type &operator<<(std::basic_ostream<char>::__ostream_type &(*__pf)(std::basic_ostream<char>::__ostream_type &)) {
            return __pf(*this);
        }
        std::basic_ostream<char>::__ostream_type &operator<<(std::basic_ostream<char>::__ios_type &(*__pf)(std::basic_ostream<char>::__ios_type &));
        std::basic_ostream<char>::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<char>::__ostream_type &operator<<(long __n);
        std::basic_ostream<char>::__ostream_type &operator<<(unsigned long __n) {
            return this->_M_insert(__n);
        }
        std::basic_ostream<char>::__ostream_type &operator<<(bool __n);
        std::basic_ostream<char>::__ostream_type &operator<<(short __n);
        std::basic_ostream<char>::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<char>::__ostream_type &operator<<(int __n);
        std::basic_ostream<char>::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<char>::__ostream_type &operator<<(long long __n);
        std::basic_ostream<char>::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<char>::__ostream_type &operator<<(double __f);
        std::basic_ostream<char>::__ostream_type &operator<<(float __f);
        std::basic_ostream<char>::__ostream_type &operator<<(long double __f);
        std::basic_ostream<char>::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<char>::__ostream_type &operator<<(std::basic_ostream<char>::__streambuf_type *__sb);
        std::basic_ostream<char>::__ostream_type &put(std::basic_ostream<char>::char_type __c);
        std::basic_ostream<char>::__ostream_type &write(const std::basic_ostream<char>::char_type *__s, std::streamsize __n);
        std::basic_ostream<char>::__ostream_type &flush();
        std::basic_ostream<char>::pos_type tellp();
        std::basic_ostream<char>::__ostream_type &seekp(std::basic_ostream<char>::pos_type);
        std::basic_ostream<char>::__ostream_type &seekp(std::basic_ostream<char>::off_type, ios_base::seekdir);
    protected:
        basic_ostream() : basic_ios<char, std::char_traits<char>>() {
            this->init(0);
        }
        basic_ostream(basic_iostream<char, std::char_traits<char>> &);
        basic_ostream(const std::basic_ostream<char> &) = delete
        basic_ostream(std::basic_ostream<char> &&__rhs);
        std::basic_ostream<char> &operator=(const std::basic_ostream<char> &) = delete
        std::basic_ostream<char> &operator=(std::basic_ostream<char> &&__rhs);
        void swap(std::basic_ostream<char> &__rhs);
        template <typename _ValueT> std::basic_ostream<char>::__ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const std::basic_ostream<char>::char_type *__s, std::streamsize __n);
    };
    template<> class basic_ostream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t>> __ios_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t>> __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(std::basic_ostream<wchar_t>::__streambuf_type *__sb);
        virtual ~basic_ostream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, std::char_traits<wchar_t>> &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, std::char_traits<wchar_t>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(std::basic_ostream<wchar_t>::__ostream_type &(*__pf)(std::basic_ostream<wchar_t>::__ostream_type &));
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(std::basic_ostream<wchar_t>::__ios_type &(*__pf)(std::basic_ostream<wchar_t>::__ios_type &));
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(long __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(unsigned long __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(bool __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(short __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(int __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(long long __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(double __f);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(float __f);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(long double __f);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<wchar_t>::__ostream_type &operator<<(std::basic_ostream<wchar_t>::__streambuf_type *__sb);
        std::basic_ostream<wchar_t>::__ostream_type &put(std::basic_ostream<wchar_t>::char_type __c);
        std::basic_ostream<wchar_t>::__ostream_type &write(const std::basic_ostream<wchar_t>::char_type *__s, std::streamsize __n);
        std::basic_ostream<wchar_t>::__ostream_type &flush();
        std::basic_ostream<wchar_t>::pos_type tellp();
        std::basic_ostream<wchar_t>::__ostream_type &seekp(std::basic_ostream<wchar_t>::pos_type);
        std::basic_ostream<wchar_t>::__ostream_type &seekp(std::basic_ostream<wchar_t>::off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<wchar_t, std::char_traits<wchar_t>> &);
        basic_ostream(const std::basic_ostream<wchar_t> &) = delete
        basic_ostream(std::basic_ostream<wchar_t> &&__rhs);
        std::basic_ostream<wchar_t> &operator=(const std::basic_ostream<wchar_t> &) = delete
        std::basic_ostream<wchar_t> &operator=(std::basic_ostream<wchar_t> &&__rhs);
        void swap(std::basic_ostream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_ostream<wchar_t>::__ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const std::basic_ostream<wchar_t>::char_type *__s, std::streamsize __n);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
        typedef ctype<_CharT> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream<_CharT, _Traits>(std::basic_istream::__streambuf_type *__sb) : _M_gcount(std::streamsize(0)) {
            this->init(__sb);
        }
        virtual ~basic_istream<_CharT, _Traits>() {
            this->_M_gcount = std::streamsize(0);
        }
        class sentry;
        friend  class sentry;
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__istream_type &(*__pf)(std::basic_istream::__istream_type &)) {
            return __pf(*this);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__ios_type &(*__pf)(std::basic_istream::__ios_type &)) {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &)) {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(bool &__n) {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(short &__n);
        std::basic_istream::__istream_type &operator>>(unsigned short &__n) {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(int &__n);
        std::basic_istream::__istream_type &operator>>(unsigned int &__n) {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long &__n) {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long &__n) {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long long &__n) {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long long &__n) {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(float &__f) {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(double &__f) {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(long double &__f) {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(void *&__p) {
            return _M_extract(__p);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__streambuf_type *__sb);
        std::streamsize gcount() const {
            return this->_M_gcount;
        }
        std::basic_istream::int_type get();
        std::basic_istream::__istream_type &get(std::basic_istream::char_type &__c);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n) {
            return this->get(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb) {
            return this->get(__sb, this->widen('\n'));
        }
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n) {
            return this->getline(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &ignore(std::streamsize __n, std::basic_istream::int_type __delim);
        std::basic_istream::__istream_type &ignore(std::streamsize __n);
        std::basic_istream::__istream_type &ignore();
        std::basic_istream::int_type peek();
        std::basic_istream::__istream_type &read(std::basic_istream::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream::char_type *__s, std::streamsize __n);
        std::basic_istream::__istream_type &putback(std::basic_istream::char_type __c);
        std::basic_istream::__istream_type &unget();
        int sync();
        std::basic_istream::pos_type tellg();
        std::basic_istream::__istream_type &seekg(std::basic_istream::pos_type);
        std::basic_istream::__istream_type &seekg(std::basic_istream::off_type, ios_base::seekdir);
    protected:
        basic_istream<_CharT, _Traits>() : _M_gcount(std::streamsize(0)) {
            this->init(0);
        }
        basic_istream<_CharT, _Traits>(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits>(basic_istream<_CharT, _Traits> &&__rhs) : std::basic_istream::__ios_type(), _M_gcount(__rhs._M_gcount) {
            __ios_type::move(__rhs);
            __rhs._M_gcount = 0;
        }
        basic_istream<_CharT, _Traits> &operator=(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits> &operator=(basic_istream<_CharT, _Traits> &&__rhs) {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_istream<_CharT, _Traits> &__rhs) {
            __ios_type::swap(__rhs);
            std::swap(this->_M_gcount, __rhs._M_gcount);
        }
        template <typename _ValueT> std::basic_istream::__istream_type &_M_extract(_ValueT &__v);
    };
    template <> basic_istream<char> &basic_istream<char>::getline(std::basic_istream<char>::char_type *__s, std::streamsize __n, std::basic_istream<char>::char_type __delim);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n, std::basic_istream<char>::int_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::getline(std::basic_istream<wchar_t>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t>::char_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n, std::basic_istream<wchar_t>::int_type __delim);
    class sentry {
        bool _M_ok;
    public:
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::__ctype_type __ctype_type;
        typedef typename _Traits::int_type __int_type;
        explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
        explicit operator bool() const {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c);
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char &__c) {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char &__c) {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <typename _CharT, typename _Traits> void __istream_extract(basic_istream<_CharT, _Traits> &, _CharT *, std::streamsize);
    void __istream_extract(std::istream &, char *, std::streamsize);
    template <typename _CharT, typename _Traits> inline basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s) __attribute__((nonnull(2))) {
        std::size_t __n = __builtin_object_size(__s, 0);
        if (__builtin_expect(__n < sizeof(_CharT), false)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__n >= sizeof(_CharT)))
                    __builtin_unreachable();
            } while (false);
            __in.width(0);
            __in.setstate(ios_base::failbit);
        } else {
            if (__n == (std::size_t)-1)
                __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
            std::__istream_extract(__in, __s, __n / sizeof(_CharT));
        }
        return __in;
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char *__s) __attribute__((nonnull(2))) {
        return __in >> reinterpret_cast<char *>(__s);
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char *__s) __attribute__((nonnull(2))) {
        return __in >> reinterpret_cast<char *>(__s);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        explicit basic_iostream<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::basic_iostream::__istream_type(__sb), std::basic_iostream::__ostream_type(__sb) {
        }
        virtual ~basic_iostream<_CharT, _Traits>() {
        }
    protected:
        basic_iostream<_CharT, _Traits>() : std::basic_iostream::__istream_type(), std::basic_iostream::__ostream_type() {
        }
        basic_iostream<_CharT, _Traits>(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &&__rhs) : std::basic_iostream::__istream_type(std::move(__rhs)), std::basic_iostream::__ostream_type(*this) {
        }
        basic_iostream<_CharT, _Traits> &operator=(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits> &operator=(basic_iostream<_CharT, _Traits> &&__rhs) {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_iostream<_CharT, _Traits> &__rhs) {
            __istream_type::swap(__rhs);
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is);
    template <typename _Is, typename _Tp, typename = _Require_derived_from_ios_base<_Is>, typename = decltype(std::declval<_Is &>() >> std::declval<_Tp>())> using __rvalue_stream_extraction_t = _Is &&;
    template <typename _Istream, typename _Tp> inline __rvalue_stream_extraction_t<_Istream, _Tp> operator>>(_Istream &&__is, _Tp &&__x) {
        __is >> std::forward<_Tp>(__x);
        return std::move(__is);
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits> &__in, bool __noskip = false) : _M_ok(false) {
        ios_base::iostate __err = ios_base::goodbit;
        if (__in.good()) {
            try {
                if (__in.tie())
                    __in.tie()->flush();
                if (!__noskip && bool(__in.flags() & ios_base::skipws)) {
                    const std::basic_istream::sentry::__int_type __eof = traits_type::eof();
                    std::basic_istream::sentry::__streambuf_type *__sb = __in.rdbuf();
                    std::basic_istream::sentry::__int_type __c = __sb->sgetc();
                    const std::basic_istream::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
                    while (!traits_type::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
                        __c = __sb->snextc();
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (__in.good() && __err == ios_base::goodbit)
            this->_M_ok = true;
        else {
            __err |= ios_base::failbit;
            __in.setstate(__err);
        }
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v) {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __v);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(short &__n) {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<short>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<short>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__max;
                } else
                    __n = short(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(int &__n) {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<int>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<int>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__max;
                } else
                    __n = int(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(std::basic_istream::__streambuf_type *__sbout) {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb && __sbout) {
            try {
                bool __ineof;
                if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
                    __err |= ios_base::failbit;
                if (__ineof)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::failbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbout)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get() {
        const std::basic_istream::int_type __eof = traits_type::eof();
        std::basic_istream::int_type __c = __eof;
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                __c = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__c, __eof))
                    this->_M_gcount = 1;
                else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type &__c) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __cb = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__cb, traits_type::eof())) {
                    this->_M_gcount = 1;
                    __c = traits_type::to_char_type(__cb);
                } else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        ++this->_M_gcount;
                        __c = __sb->snextc();
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__this_sb = this->rdbuf();
                std::basic_istream::int_type __c = __this_sb->sgetc();
                std::basic_istream::char_type __c2 = traits_type::to_char_type(__c);
                unsigned long long __gcount = 0;
                while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                    {
                        ++__gcount;
                        __c = __this_sb->snextc();
                        __c2 = traits_type::to_char_type(__c);
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)
                    this->_M_gcount = __gcount;
                else
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                        ++this->_M_gcount;
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else {
                    if (traits_type::eq_int_type(__c, __idelim)) {
                        __sb->sbumpc();
                        ++this->_M_gcount;
                    } else
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore() {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
                    __err |= ios_base::eofbit;
                else
                    this->_M_gcount = 1;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n) {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
                    if (__large_ignore)
                        this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                } else if (this->_M_gcount < __n) {
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n, std::basic_istream::int_type __delim) {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
                    if (__large_ignore)
                        this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                    else {
                        if (this->_M_gcount != __n)
                            ++this->_M_gcount;
                        __sb->sbumpc();
                    }
                } else if (this->_M_gcount < __n) {
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                    else {
                        ++this->_M_gcount;
                        __sb->sbumpc();
                    }
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek() {
        std::basic_istream::int_type __c = traits_type::eof();
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __c = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__c, traits_type::eof()))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(std::basic_istream::char_type *__s, std::streamsize __n) {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                this->_M_gcount = this->rdbuf()->sgetn(__s, __n);
                if (this->_M_gcount != __n)
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_istream<_CharT, _Traits>::readsome(std::basic_istream::char_type *__s, std::streamsize __n) {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::streamsize __num = this->rdbuf()->in_avail();
                if (__num > 0)
                    this->_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
                else if (__num == -1)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return this->_M_gcount;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(std::basic_istream::char_type __c) {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget() {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> int basic_istream<_CharT, _Traits>::sync() {
        int __ret = -1;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (__sb) {
                    if (__sb->pubsync() == -1)
                        __err |= ios_base::badbit;
                    else
                        __ret = 0;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg() {
        std::basic_istream::pos_type __ret = std::basic_istream::pos_type(-1);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                if (!this->fail())
                    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::pos_type __pos) {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::off_type __off, ios_base::seekdir __dir) {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::int_type __int_type;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __int_type __cb = __in.rdbuf()->sbumpc();
                if (!_Traits::eq_int_type(__cb, _Traits::eof()))
                    __c = _Traits::to_char_type(__cb);
                else
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template <typename _CharT, typename _Traits> void __istream_extract(basic_istream<_CharT, _Traits> &__in, _CharT *__s, std::streamsize __num) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename _Traits::int_type int_type;
        typedef _CharT char_type;
        typedef ctype<_CharT> __ctype_type;
        std::streamsize __extracted = 0;
        ios_base::iostate __err = ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                std::streamsize __width = __in.width();
                if (0 < __width && __width < __num)
                    __num = __width;
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                int_type __c = __sb->sgetc();
                while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        *__s++ = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __sb->snextc();
                    }
                if (__extracted < __num - 1 && _Traits::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                *__s = char_type();
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= ios_base::failbit;
        if (__err)
            __in.setstate(__err);
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__in) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename __istream_type::int_type __int_type;
        typedef ctype<_CharT> __ctype_type;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                __int_type __c = __sb->sgetc();
                while (true)
                    {
                        if (_Traits::eq_int_type(__c, __eof)) {
                            __err = ios_base::eofbit;
                            break;
                        }
                        if (!__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                            break;
                        __c = __sb->snextc();
                    }
            } catch (const __cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template<> class basic_istream<char> : virtual public basic_ios<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
        typedef basic_ios<char, std::char_traits<char>> __ios_type;
        typedef basic_istream<char, std::char_traits<char>> __istream_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char>>> __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<char>::__streambuf_type *__sb);
        virtual ~basic_istream<char>() throw() {
            this->_M_gcount = std::streamsize(0);
        }
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
            typedef basic_istream<char, std::char_traits<char>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, std::char_traits<char>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<char>::__istream_type &operator>>(std::basic_istream<char>::__istream_type &(*__pf)(std::basic_istream<char>::__istream_type &));
        std::basic_istream<char>::__istream_type &operator>>(std::basic_istream<char>::__ios_type &(*__pf)(std::basic_istream<char>::__ios_type &));
        std::basic_istream<char>::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<char>::__istream_type &operator>>(bool &__n);
        std::basic_istream<char>::__istream_type &operator>>(short &__n);
        std::basic_istream<char>::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<char>::__istream_type &operator>>(int &__n);
        std::basic_istream<char>::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<char>::__istream_type &operator>>(long &__n);
        std::basic_istream<char>::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<char>::__istream_type &operator>>(long long &__n);
        std::basic_istream<char>::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<char>::__istream_type &operator>>(float &__f);
        std::basic_istream<char>::__istream_type &operator>>(double &__f);
        std::basic_istream<char>::__istream_type &operator>>(long double &__f);
        std::basic_istream<char>::__istream_type &operator>>(void *&__p);
        std::basic_istream<char>::__istream_type &operator>>(std::basic_istream<char>::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<char>::int_type get();
        std::basic_istream<char>::__istream_type &get(std::basic_istream<char>::char_type &__c);
        std::basic_istream<char>::__istream_type &get(std::basic_istream<char>::char_type *__s, std::streamsize __n, std::basic_istream<char>::char_type __delim);
        std::basic_istream<char>::__istream_type &get(std::basic_istream<char>::char_type *__s, std::streamsize __n);
        std::basic_istream<char>::__istream_type &get(std::basic_istream<char>::__streambuf_type &__sb, std::basic_istream<char>::char_type __delim);
        std::basic_istream<char>::__istream_type &get(std::basic_istream<char>::__streambuf_type &__sb);
        std::basic_istream<char>::__istream_type &getline(std::basic_istream<char>::char_type *__s, std::streamsize __n, std::basic_istream<char>::char_type __delim);
        std::basic_istream<char>::__istream_type &getline(std::basic_istream<char>::char_type *__s, std::streamsize __n);
        std::basic_istream<char>::__istream_type &ignore(std::streamsize __n, std::basic_istream<char>::int_type __delim);
        std::basic_istream<char>::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<char>::__istream_type &ignore();
        std::basic_istream<char>::int_type peek();
        std::basic_istream<char>::__istream_type &read(std::basic_istream<char>::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<char>::char_type *__s, std::streamsize __n);
        std::basic_istream<char>::__istream_type &putback(std::basic_istream<char>::char_type __c);
        std::basic_istream<char>::__istream_type &unget();
        int sync();
        std::basic_istream<char>::pos_type tellg();
        std::basic_istream<char>::__istream_type &seekg(std::basic_istream<char>::pos_type);
        std::basic_istream<char>::__istream_type &seekg(std::basic_istream<char>::off_type, ios_base::seekdir);
    protected:
        basic_istream() : basic_ios<char, std::char_traits<char>>(), _M_gcount(std::streamsize(0)) {
            this->init(0);
        }
        basic_istream(const std::basic_istream<char> &) = delete
        basic_istream(std::basic_istream<char> &&__rhs);
        std::basic_istream<char> &operator=(const std::basic_istream<char> &) = delete
        std::basic_istream<char> &operator=(std::basic_istream<char> &&__rhs);
        void swap(std::basic_istream<char> &__rhs);
        template <typename _ValueT> std::basic_istream<char>::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<char> : public basic_istream<char, std::char_traits<char>>, public basic_ostream<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, std::char_traits<char>> __istream_type;
        typedef basic_ostream<char, std::char_traits<char>> __ostream_type;
        explicit basic_iostream(basic_streambuf<char, std::char_traits<char>> *__sb);
        virtual ~basic_iostream<char>() throw() {
        }
    protected:
        basic_iostream() : basic_ios<char, std::char_traits<char>>(), std::basic_iostream<char>::__istream_type(), std::basic_iostream<char>::__ostream_type() {
        }
        basic_iostream(const std::basic_iostream<char> &) = delete
        basic_iostream(std::basic_iostream<char> &&__rhs);
        std::basic_iostream<char> &operator=(const std::basic_iostream<char> &) = delete
        std::basic_iostream<char> &operator=(std::basic_iostream<char> &&__rhs);
        void swap(std::basic_iostream<char> &__rhs);
    };
    template<> class basic_istream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t>> __ios_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<wchar_t>::__streambuf_type *__sb);
        virtual ~basic_istream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
            typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, std::char_traits<wchar_t>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<wchar_t>::__istream_type &operator>>(std::basic_istream<wchar_t>::__istream_type &(*__pf)(std::basic_istream<wchar_t>::__istream_type &));
        std::basic_istream<wchar_t>::__istream_type &operator>>(std::basic_istream<wchar_t>::__ios_type &(*__pf)(std::basic_istream<wchar_t>::__ios_type &));
        std::basic_istream<wchar_t>::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<wchar_t>::__istream_type &operator>>(bool &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(short &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(int &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(long &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(long long &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<wchar_t>::__istream_type &operator>>(float &__f);
        std::basic_istream<wchar_t>::__istream_type &operator>>(double &__f);
        std::basic_istream<wchar_t>::__istream_type &operator>>(long double &__f);
        std::basic_istream<wchar_t>::__istream_type &operator>>(void *&__p);
        std::basic_istream<wchar_t>::__istream_type &operator>>(std::basic_istream<wchar_t>::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<wchar_t>::int_type get();
        std::basic_istream<wchar_t>::__istream_type &get(std::basic_istream<wchar_t>::char_type &__c);
        std::basic_istream<wchar_t>::__istream_type &get(std::basic_istream<wchar_t>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t>::char_type __delim);
        std::basic_istream<wchar_t>::__istream_type &get(std::basic_istream<wchar_t>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t>::__istream_type &get(std::basic_istream<wchar_t>::__streambuf_type &__sb, std::basic_istream<wchar_t>::char_type __delim);
        std::basic_istream<wchar_t>::__istream_type &get(std::basic_istream<wchar_t>::__streambuf_type &__sb);
        std::basic_istream<wchar_t>::__istream_type &getline(std::basic_istream<wchar_t>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t>::char_type __delim);
        std::basic_istream<wchar_t>::__istream_type &getline(std::basic_istream<wchar_t>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t>::__istream_type &ignore(std::streamsize __n, std::basic_istream<wchar_t>::int_type __delim);
        std::basic_istream<wchar_t>::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<wchar_t>::__istream_type &ignore();
        std::basic_istream<wchar_t>::int_type peek();
        std::basic_istream<wchar_t>::__istream_type &read(std::basic_istream<wchar_t>::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<wchar_t>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t>::__istream_type &putback(std::basic_istream<wchar_t>::char_type __c);
        std::basic_istream<wchar_t>::__istream_type &unget();
        int sync();
        std::basic_istream<wchar_t>::pos_type tellg();
        std::basic_istream<wchar_t>::__istream_type &seekg(std::basic_istream<wchar_t>::pos_type);
        std::basic_istream<wchar_t>::__istream_type &seekg(std::basic_istream<wchar_t>::off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const std::basic_istream<wchar_t> &) = delete
        basic_istream(std::basic_istream<wchar_t> &&__rhs);
        std::basic_istream<wchar_t> &operator=(const std::basic_istream<wchar_t> &) = delete
        std::basic_istream<wchar_t> &operator=(std::basic_istream<wchar_t> &&__rhs);
        void swap(std::basic_istream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_istream<wchar_t>::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<wchar_t> : public basic_istream<wchar_t, std::char_traits<wchar_t>>, public basic_ostream<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t>> __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        virtual ~basic_iostream<wchar_t>() throw();
    protected:
        basic_iostream();
        basic_iostream(const std::basic_iostream<wchar_t> &) = delete
        basic_iostream(std::basic_iostream<wchar_t> &&__rhs);
        std::basic_iostream<wchar_t> &operator=(const std::basic_iostream<wchar_t> &) = delete
        std::basic_iostream<wchar_t> &operator=(std::basic_iostream<wchar_t> &&__rhs);
        void swap(std::basic_iostream<wchar_t> &__rhs);
    };
}
namespace std {
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf : public basic_streambuf<_CharT, _Traits> {
            struct __xfer_bufptrs;
            using allocator_traits = std::allocator_traits<_Alloc>;
            using _Noexcept_swap = __or_<typename allocator_traits::propagate_on_container_swap, typename allocator_traits::is_always_equal>;
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_streambuf<std::basic_stringbuf::char_type, std::basic_stringbuf::traits_type> __streambuf_type;
            typedef basic_string<std::basic_stringbuf::char_type, _Traits, _Alloc> __string_type;
            typedef typename __string_type::size_type __size_type;
        protected:
            ios_base::openmode _M_mode;
            std::basic_stringbuf::__string_type _M_string;
        public:
            basic_stringbuf<_CharT, _Traits, _Alloc>() : std::basic_stringbuf::__streambuf_type(), _M_mode(ios_base::in | ios_base::out), _M_string() {
            }
            explicit basic_stringbuf<_CharT, _Traits, _Alloc>(ios_base::openmode __mode) : std::basic_stringbuf::__streambuf_type(), _M_mode(__mode), _M_string() {
            }
            explicit basic_stringbuf<_CharT, _Traits, _Alloc>(const std::basic_stringbuf::__string_type &__str, ios_base::openmode __mode = ios_base::in | ios_base::out) : std::basic_stringbuf::__streambuf_type(), _M_mode(/*implicit*/(ios_base::openmode)0), _M_string(__str.data(), __str.size(), __str.get_allocator()) {
                this->_M_stringbuf_init(__mode);
            }
            basic_stringbuf<_CharT, _Traits, _Alloc>(const basic_stringbuf<_CharT, _Traits, _Alloc> &) = delete
            basic_stringbuf<_CharT, _Traits, _Alloc>(basic_stringbuf<_CharT, _Traits, _Alloc> &&__rhs) : basic_stringbuf<_CharT, _Traits, _Alloc>(std::move(__rhs), std::basic_stringbuf::__xfer_bufptrs(__rhs, this)) {
                __rhs._M_sync(const_cast<std::basic_stringbuf::char_type *>(__rhs._M_string.data()), 0, 0);
            }
            basic_stringbuf<_CharT, _Traits, _Alloc> &operator=(const basic_stringbuf<_CharT, _Traits, _Alloc> &) = delete
            basic_stringbuf<_CharT, _Traits, _Alloc> &operator=(basic_stringbuf<_CharT, _Traits, _Alloc> &&__rhs) {
                std::basic_stringbuf::__xfer_bufptrs __st{__rhs, this};
                const std::basic_stringbuf::__streambuf_type &__base = __rhs;
                __streambuf_type::operator=(__base);
                this->pubimbue(__rhs.getloc());
                this->_M_mode = __rhs._M_mode;
                this->_M_string = std::move(__rhs._M_string);
                __rhs._M_sync(const_cast<std::basic_stringbuf::char_type *>(__rhs._M_string.data()), 0, 0);
                return *this;
            }
            void swap(basic_stringbuf<_CharT, _Traits, _Alloc> &__rhs) noexcept(_Noexcept_swap::value) {
                std::basic_stringbuf::__xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
                std::basic_stringbuf::__xfer_bufptrs __r_st{__rhs, this};
                std::basic_stringbuf::__streambuf_type &__base = __rhs;
                __streambuf_type::swap(__base);
                __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
                std::swap(this->_M_mode, __rhs._M_mode);
                std::swap(this->_M_string, __rhs._M_string);
            }
            std::basic_stringbuf::__string_type str() const {
                std::basic_stringbuf::__string_type __ret(this->_M_string.get_allocator());
                if (std::basic_stringbuf::char_type *__hi = this->_M_high_mark())
                    __ret.assign(this->pbase(), __hi);
                else
                    __ret = this->_M_string;
                return __ret;
            }
            void str(const std::basic_stringbuf::__string_type &__s) {
                this->_M_string.assign(__s.data(), __s.size());
                this->_M_stringbuf_init(this->_M_mode);
            }
        protected:
            void _M_stringbuf_init(ios_base::openmode __mode) {
                this->_M_mode = __mode;
                std::basic_stringbuf::__size_type __len = 0;
                if (this->_M_mode & (ios_base::ate | ios_base::app))
                    __len = this->_M_string.size();
                this->_M_sync(const_cast<std::basic_stringbuf::char_type *>(this->_M_string.data()), 0, __len);
            }
            virtual std::streamsize showmanyc() {
                std::streamsize __ret = -1;
                if (this->_M_mode & ios_base::in) {
                    this->_M_update_egptr();
                    __ret = this->egptr() - this->gptr();
                }
                return __ret;
            }
            virtual std::basic_stringbuf::int_type underflow();
            virtual std::basic_stringbuf::int_type pbackfail(std::basic_stringbuf::int_type __c = traits_type::eof());
            virtual std::basic_stringbuf::int_type overflow(std::basic_stringbuf::int_type __c = traits_type::eof());
            virtual std::basic_stringbuf::__streambuf_type *setbuf(std::basic_stringbuf::char_type *__s, std::streamsize __n) {
                if (__s && __n >= 0) {
                    this->_M_string.clear();
                    this->_M_sync(__s, __n, 0);
                }
                return this;
            }
            virtual std::basic_stringbuf::pos_type seekoff(std::basic_stringbuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out);
            virtual std::basic_stringbuf::pos_type seekpos(std::basic_stringbuf::pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out);
            void _M_sync(std::basic_stringbuf::char_type *__base, std::basic_stringbuf::__size_type __i, std::basic_stringbuf::__size_type __o);
            void _M_update_egptr() {
                if (std::basic_stringbuf::char_type *__pptr = this->pptr()) {
                    std::basic_stringbuf::char_type *__egptr = this->egptr();
                    if (!__egptr || __pptr > __egptr) {
                        if (this->_M_mode & ios_base::in)
                            this->setg(this->eback(), this->gptr(), __pptr);
                        else
                            this->setg(__pptr, __pptr, __pptr);
                    }
                }
            }
            void _M_pbump(std::basic_stringbuf::char_type *__pbeg, std::basic_stringbuf::char_type *__pend, std::basic_stringbuf::off_type __off);
        private:
            std::basic_stringbuf::char_type *_M_high_mark() const noexcept {
                if (std::basic_stringbuf::char_type *__pptr = this->pptr()) {
                    std::basic_stringbuf::char_type *__egptr = this->egptr();
                    if (!__egptr || __pptr > __egptr)
                        return __pptr;
                    else
                        return __egptr;
                }
                return 0;
            }
            struct __xfer_bufptrs {
                __xfer_bufptrs(const basic_stringbuf<_CharT, _Traits, _Alloc> &__from, basic_stringbuf<_CharT, _Traits, _Alloc> *__to) : _M_to({__to}), _M_goff({-1, -1, -1}), _M_poff({-1, -1, -1}) {
                    const _CharT *const __str = __from._M_string.data();
                    const _CharT *__end = nullptr;
                    if (__from.eback()) {
                        this->_M_goff[0] = __from.eback() - __str;
                        this->_M_goff[1] = __from.gptr() - __str;
                        this->_M_goff[2] = __from.egptr() - __str;
                        __end = __from.egptr();
                    }
                    if (__from.pbase()) {
                        this->_M_poff[0] = __from.pbase() - __str;
                        this->_M_poff[1] = __from.pptr() - __from.pbase();
                        this->_M_poff[2] = __from.epptr() - __str;
                        if (!__end || __from.pptr() > __end)
                            __end = __from.pptr();
                    }
                    if (__end) {
                        auto &__mut_from = const_cast<basic_stringbuf<_CharT, _Traits, _Alloc> &>(__from);
                        __mut_from._M_string._M_length(__end - __str);
                    }
                }
                ~__xfer_bufptrs() {
                    std::basic_stringbuf::char_type *__str = const_cast<std::basic_stringbuf::char_type *>(this->_M_to->_M_string.data());
                    if (this->_M_goff[0] != -1)
                        this->_M_to->setg(__str + this->_M_goff[0], __str + this->_M_goff[1], __str + this->_M_goff[2]);
                    if (this->_M_poff[0] != -1)
                        this->_M_to->_M_pbump(__str + this->_M_poff[0], __str + this->_M_poff[2], this->_M_poff[1]);
                }
                basic_stringbuf<_CharT, _Traits, _Alloc> *_M_to;
                std::basic_stringbuf::off_type _M_goff[3];
                std::basic_stringbuf::off_type _M_poff[3];
            };
            basic_stringbuf<_CharT, _Traits, _Alloc>(basic_stringbuf<_CharT, _Traits, _Alloc> &&__rhs, std::basic_stringbuf::__xfer_bufptrs &&) : std::basic_stringbuf::__streambuf_type(static_cast<const std::basic_stringbuf::__streambuf_type &>(__rhs)), _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string)) {
            }
        };
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream : public basic_istream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
            typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
            typedef basic_istream<std::basic_istringstream::char_type, std::basic_istringstream::traits_type> __istream_type;
        private:
            std::basic_istringstream::__stringbuf_type _M_stringbuf;
        public:
            basic_istringstream<_CharT, _Traits, _Alloc>() : std::basic_istringstream::__istream_type(), _M_stringbuf(ios_base::in) {
                this->init(& this->_M_stringbuf);
            }
            explicit basic_istringstream<_CharT, _Traits, _Alloc>(ios_base::openmode __mode) : std::basic_istringstream::__istream_type(), _M_stringbuf(__mode | ios_base::in) {
                this->init(& this->_M_stringbuf);
            }
            explicit basic_istringstream<_CharT, _Traits, _Alloc>(const std::basic_istringstream::__string_type &__str, ios_base::openmode __mode = ios_base::in) : std::basic_istringstream::__istream_type(), _M_stringbuf(__str, __mode | ios_base::in) {
                this->init(& this->_M_stringbuf);
            }
            ~basic_istringstream<_CharT, _Traits, _Alloc>() {
            }
            basic_istringstream<_CharT, _Traits, _Alloc>(const basic_istringstream<_CharT, _Traits, _Alloc> &) = delete
            basic_istringstream<_CharT, _Traits, _Alloc>(basic_istringstream<_CharT, _Traits, _Alloc> &&__rhs) : std::basic_istringstream::__istream_type(std::move(__rhs)), _M_stringbuf(std::move(__rhs._M_stringbuf)) {
                __istream_type::set_rdbuf(& this->_M_stringbuf);
            }
            basic_istringstream<_CharT, _Traits, _Alloc> &operator=(const basic_istringstream<_CharT, _Traits, _Alloc> &) = delete
            basic_istringstream<_CharT, _Traits, _Alloc> &operator=(basic_istringstream<_CharT, _Traits, _Alloc> &&__rhs) {
                __istream_type::operator=(std::move(__rhs));
                this->_M_stringbuf = std::move(__rhs._M_stringbuf);
                return *this;
            }
            void swap(basic_istringstream<_CharT, _Traits, _Alloc> &__rhs) {
                __istream_type::swap(__rhs);
                this->_M_stringbuf.swap(__rhs._M_stringbuf);
            }
            std::basic_istringstream::__stringbuf_type *rdbuf() const {
                return const_cast<std::basic_istringstream::__stringbuf_type *>(& this->_M_stringbuf);
            }
            std::basic_istringstream::__string_type str() const {
                return this->_M_stringbuf.str();
            }
            void str(const std::basic_istringstream::__string_type &__s) {
                this->_M_stringbuf.str(__s);
            }
        };
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream : public basic_ostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
            typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
            typedef basic_ostream<std::basic_ostringstream::char_type, std::basic_ostringstream::traits_type> __ostream_type;
        private:
            std::basic_ostringstream::__stringbuf_type _M_stringbuf;
        public:
            basic_ostringstream<_CharT, _Traits, _Alloc>() : std::basic_ostringstream::__ostream_type(), _M_stringbuf(ios_base::out) {
                this->init(& this->_M_stringbuf);
            }
            explicit basic_ostringstream<_CharT, _Traits, _Alloc>(ios_base::openmode __mode) : std::basic_ostringstream::__ostream_type(), _M_stringbuf(__mode | ios_base::out) {
                this->init(& this->_M_stringbuf);
            }
            explicit basic_ostringstream<_CharT, _Traits, _Alloc>(const std::basic_ostringstream::__string_type &__str, ios_base::openmode __mode = ios_base::out) : std::basic_ostringstream::__ostream_type(), _M_stringbuf(__str, __mode | ios_base::out) {
                this->init(& this->_M_stringbuf);
            }
            ~basic_ostringstream<_CharT, _Traits, _Alloc>() {
            }
            basic_ostringstream<_CharT, _Traits, _Alloc>(const basic_ostringstream<_CharT, _Traits, _Alloc> &) = delete
            basic_ostringstream<_CharT, _Traits, _Alloc>(basic_ostringstream<_CharT, _Traits, _Alloc> &&__rhs) : std::basic_ostringstream::__ostream_type(std::move(__rhs)), _M_stringbuf(std::move(__rhs._M_stringbuf)) {
                __ostream_type::set_rdbuf(& this->_M_stringbuf);
            }
            basic_ostringstream<_CharT, _Traits, _Alloc> &operator=(const basic_ostringstream<_CharT, _Traits, _Alloc> &) = delete
            basic_ostringstream<_CharT, _Traits, _Alloc> &operator=(basic_ostringstream<_CharT, _Traits, _Alloc> &&__rhs) {
                __ostream_type::operator=(std::move(__rhs));
                this->_M_stringbuf = std::move(__rhs._M_stringbuf);
                return *this;
            }
            void swap(basic_ostringstream<_CharT, _Traits, _Alloc> &__rhs) {
                __ostream_type::swap(__rhs);
                this->_M_stringbuf.swap(__rhs._M_stringbuf);
            }
            std::basic_ostringstream::__stringbuf_type *rdbuf() const {
                return const_cast<std::basic_ostringstream::__stringbuf_type *>(& this->_M_stringbuf);
            }
            std::basic_ostringstream::__string_type str() const {
                return this->_M_stringbuf.str();
            }
            void str(const std::basic_ostringstream::__string_type &__s) {
                this->_M_stringbuf.str(__s);
            }
        };
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream : public basic_iostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
            typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
            typedef basic_iostream<std::basic_stringstream::char_type, std::basic_stringstream::traits_type> __iostream_type;
        private:
            std::basic_stringstream::__stringbuf_type _M_stringbuf;
        public:
            basic_stringstream<_CharT, _Traits, _Alloc>() : std::basic_stringstream::__iostream_type(), _M_stringbuf(ios_base::out | ios_base::in) {
                this->init(& this->_M_stringbuf);
            }
            explicit basic_stringstream<_CharT, _Traits, _Alloc>(ios_base::openmode __m) : std::basic_stringstream::__iostream_type(), _M_stringbuf(__m) {
                this->init(& this->_M_stringbuf);
            }
            explicit basic_stringstream<_CharT, _Traits, _Alloc>(const std::basic_stringstream::__string_type &__str, ios_base::openmode __m = ios_base::out | ios_base::in) : std::basic_stringstream::__iostream_type(), _M_stringbuf(__str, __m) {
                this->init(& this->_M_stringbuf);
            }
            ~basic_stringstream<_CharT, _Traits, _Alloc>() {
            }
            basic_stringstream<_CharT, _Traits, _Alloc>(const basic_stringstream<_CharT, _Traits, _Alloc> &) = delete
            basic_stringstream<_CharT, _Traits, _Alloc>(basic_stringstream<_CharT, _Traits, _Alloc> &&__rhs) : std::basic_stringstream::__iostream_type(std::move(__rhs)), _M_stringbuf(std::move(__rhs._M_stringbuf)) {
                __iostream_type::set_rdbuf(& this->_M_stringbuf);
            }
            basic_stringstream<_CharT, _Traits, _Alloc> &operator=(const basic_stringstream<_CharT, _Traits, _Alloc> &) = delete
            basic_stringstream<_CharT, _Traits, _Alloc> &operator=(basic_stringstream<_CharT, _Traits, _Alloc> &&__rhs) {
                __iostream_type::operator=(std::move(__rhs));
                this->_M_stringbuf = std::move(__rhs._M_stringbuf);
                return *this;
            }
            void swap(basic_stringstream<_CharT, _Traits, _Alloc> &__rhs) {
                __iostream_type::swap(__rhs);
                this->_M_stringbuf.swap(__rhs._M_stringbuf);
            }
            std::basic_stringstream::__stringbuf_type *rdbuf() const {
                return const_cast<std::basic_stringstream::__stringbuf_type *>(& this->_M_stringbuf);
            }
            std::basic_stringstream::__string_type str() const {
                return this->_M_stringbuf.str();
            }
            void str(const std::basic_stringstream::__string_type &__s) {
                this->_M_stringbuf.str(__s);
            }
        };
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_stringbuf<_CharT, _Traits, _Allocator> &__x, basic_stringbuf<_CharT, _Traits, _Allocator> &__y) noexcept(noexcept(__x.swap(__y))) {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_istringstream<_CharT, _Traits, _Allocator> &__x, basic_istringstream<_CharT, _Traits, _Allocator> &__y) {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_ostringstream<_CharT, _Traits, _Allocator> &__x, basic_ostringstream<_CharT, _Traits, _Allocator> &__y) {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_stringstream<_CharT, _Traits, _Allocator> &__x, basic_stringstream<_CharT, _Traits, _Allocator> &__y) {
            __x.swap(__y);
        }
    }
}
namespace std {
    template <class _CharT, class _Traits, class _Alloc> typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::pbackfail(std::basic_stringbuf::int_type __c = traits_type::eof()) {
        std::basic_stringbuf::int_type __ret = traits_type::eof();
        if (this->eback() < this->gptr()) {
            const bool __testeof = traits_type::eq_int_type(__c, __ret);
            if (!__testeof) {
                const bool __testeq = traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]);
                const bool __testout = this->_M_mode & ios_base::out;
                if (__testeq || __testout) {
                    this->gbump(-1);
                    if (!__testeq)
                        *this->gptr() = traits_type::to_char_type(__c);
                    __ret = __c;
                }
            } else {
                this->gbump(-1);
                __ret = traits_type::not_eof(__c);
            }
        }
        return __ret;
    }
    template <class _CharT, class _Traits, class _Alloc> typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::overflow(std::basic_stringbuf::int_type __c = traits_type::eof()) {
        const bool __testout = this->_M_mode & ios_base::out;
        if (__builtin_expect(!__testout, false))
            return traits_type::eof();
        const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
        if (__builtin_expect(__testeof, false))
            return traits_type::not_eof(__c);
        const std::basic_stringbuf::__size_type __capacity = this->_M_string.capacity();
        if (std::size_t(this->epptr() - this->pbase()) < __capacity) {
            std::basic_stringbuf::char_type *__base = const_cast<std::basic_stringbuf::char_type *>(this->_M_string.data());
            this->_M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
            if (this->_M_mode & ios_base::in) {
                const std::basic_stringbuf::__size_type __nget = this->gptr() - this->eback();
                const std::basic_stringbuf::__size_type __eget = this->egptr() - this->eback();
                this->setg(__base, __base + __nget, __base + __eget + 1);
            }
            *this->pptr() = traits_type::to_char_type(__c);
            this->pbump(1);
            return __c;
        }
        const std::basic_stringbuf::__size_type __max_size = this->_M_string.max_size();
        const bool __testput = this->pptr() < this->epptr();
        if (__builtin_expect(!__testput && __capacity == __max_size, false))
            return traits_type::eof();
        const std::basic_stringbuf::char_type __conv = traits_type::to_char_type(__c);
        if (!__testput) {
            const std::basic_stringbuf::__size_type __opt_len = std::max(std::basic_stringbuf::__size_type(2 * __capacity), std::basic_stringbuf::__size_type(512));
            const std::basic_stringbuf::__size_type __len = std::min(__opt_len, __max_size);
            std::basic_stringbuf::__string_type __tmp(this->_M_string.get_allocator());
            __tmp.reserve(__len);
            if (this->pbase())
                __tmp.assign(this->pbase(), this->epptr() - this->pbase());
            __tmp.push_back(__conv);
            this->_M_string.swap(__tmp);
            this->_M_sync(const_cast<std::basic_stringbuf::char_type *>(this->_M_string.data()), this->gptr() - this->eback(), this->pptr() - this->pbase());
        } else
            *this->pptr() = __conv;
        this->pbump(1);
        return __c;
    }
    template <class _CharT, class _Traits, class _Alloc> typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::underflow() {
        std::basic_stringbuf::int_type __ret = traits_type::eof();
        const bool __testin = this->_M_mode & ios_base::in;
        if (__testin) {
            this->_M_update_egptr();
            if (this->gptr() < this->egptr())
                __ret = traits_type::to_int_type(*this->gptr());
        }
        return __ret;
    }
    template <class _CharT, class _Traits, class _Alloc> typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type basic_stringbuf<_CharT, _Traits, _Alloc>::seekoff(std::basic_stringbuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out) {
        std::basic_stringbuf::pos_type __ret = std::basic_stringbuf::pos_type(std::basic_stringbuf::off_type(-1));
        bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
        bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
        const bool __testboth = __testin && __testout && __way != ios_base::cur;
        __testin &= !(__mode & ios_base::out);
        __testout &= !(__mode & ios_base::in);
        const std::basic_stringbuf::char_type *__beg = __testin ? this->eback() : this->pbase();
        if ((__beg || !__off) && (__testin || __testout || __testboth)) {
            this->_M_update_egptr();
            std::basic_stringbuf::off_type __newoffi = __off;
            std::basic_stringbuf::off_type __newoffo = __newoffi;
            if (__way == ios_base::cur) {
                __newoffi += this->gptr() - __beg;
                __newoffo += this->pptr() - __beg;
            } else if (__way == ios_base::end)
                __newoffo = __newoffi += this->egptr() - __beg;
            if ((__testin || __testboth) && __newoffi >= 0 && this->egptr() - __beg >= __newoffi) {
                this->setg(this->eback(), this->eback() + __newoffi, this->egptr());
                __ret = std::basic_stringbuf::pos_type(__newoffi);
            }
            if ((__testout || __testboth) && __newoffo >= 0 && this->egptr() - __beg >= __newoffo) {
                this->_M_pbump(this->pbase(), this->epptr(), __newoffo);
                __ret = std::basic_stringbuf::pos_type(__newoffo);
            }
        }
        return __ret;
    }
    template <class _CharT, class _Traits, class _Alloc> typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type basic_stringbuf<_CharT, _Traits, _Alloc>::seekpos(std::basic_stringbuf::pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out) {
        std::basic_stringbuf::pos_type __ret = std::basic_stringbuf::pos_type(std::basic_stringbuf::off_type(-1));
        const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
        const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
        const std::basic_stringbuf::char_type *__beg = __testin ? this->eback() : this->pbase();
        if ((__beg || !std::basic_stringbuf::off_type(__sp)) && (__testin || __testout)) {
            this->_M_update_egptr();
            const std::basic_stringbuf::off_type __pos(__sp);
            const bool __testpos = (0 <= __pos && __pos <= this->egptr() - __beg);
            if (__testpos) {
                if (__testin)
                    this->setg(this->eback(), this->eback() + __pos, this->egptr());
                if (__testout)
                    this->_M_pbump(this->pbase(), this->epptr(), __pos);
                __ret = __sp;
            }
        }
        return __ret;
    }
    template <class _CharT, class _Traits, class _Alloc> void basic_stringbuf<_CharT, _Traits, _Alloc>::_M_sync(std::basic_stringbuf::char_type *__base, std::basic_stringbuf::__size_type __i, std::basic_stringbuf::__size_type __o) {
        const bool __testin = this->_M_mode & ios_base::in;
        const bool __testout = this->_M_mode & ios_base::out;
        std::basic_stringbuf::char_type *__endg = __base + this->_M_string.size();
        std::basic_stringbuf::char_type *__endp = __base + this->_M_string.capacity();
        if (__base != this->_M_string.data()) {
            __endg += __i;
            __i = 0;
            __endp = __endg;
        }
        if (__testin)
            this->setg(__base, __base + __i, __endg);
        if (__testout) {
            this->_M_pbump(__base, __endp, __o);
            if (!__testin)
                this->setg(__endg, __endg, __endg);
        }
    }
    template <class _CharT, class _Traits, class _Alloc> void basic_stringbuf<_CharT, _Traits, _Alloc>::_M_pbump(std::basic_stringbuf::char_type *__pbeg, std::basic_stringbuf::char_type *__pend, std::basic_stringbuf::off_type __off) {
        this->setp(__pbeg, __pend);
        while (__off > __gnu_cxx::__numeric_traits<int>::__max)
            {
                this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
                __off -= __gnu_cxx::__numeric_traits<int>::__max;
            }
        this->pbump(__off);
    }
    template<> class basic_stringbuf<char> : public basic_streambuf<char, std::char_traits<char>> {
        struct __xfer_bufptrs {
            __xfer_bufptrs(const std::basic_stringbuf<char> &__from, std::basic_stringbuf<char> *__to);
            ~__xfer_bufptrs();
            std::basic_stringbuf<char> *_M_to;
            std::basic_stringbuf<char>::off_type _M_goff[3];
            std::basic_stringbuf<char>::off_type _M_poff[3];
        };
        using allocator_traits = std::allocator_traits<allocator<char>>;
        using _Noexcept_swap = __or_<typename allocator_traits::propagate_on_container_swap, typename allocator_traits::is_always_equal>;
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef std::allocator<char> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_stringbuf<char>::char_type, std::basic_stringbuf<char>::traits_type> __streambuf_type;
        typedef basic_string<std::basic_stringbuf<char>::char_type, std::char_traits<char>, std::allocator<char>> __string_type;
        typedef typename __string_type::size_type __size_type;
    protected:
        ios_base::openmode _M_mode;
        std::basic_stringbuf<char>::__string_type _M_string;
    public:
        basic_stringbuf();
        explicit basic_stringbuf(ios_base::openmode __mode) : std::basic_stringbuf<char>::__streambuf_type(), _M_mode(__mode), _M_string() {
        }
        explicit basic_stringbuf(const std::basic_stringbuf<char>::__string_type &__str, ios_base::openmode __mode);
        basic_stringbuf(const std::basic_stringbuf<char> &) = delete
        basic_stringbuf(std::basic_stringbuf<char> &&__rhs);
        std::basic_stringbuf<char> &operator=(const std::basic_stringbuf<char> &) = delete
        std::basic_stringbuf<char> &operator=(std::basic_stringbuf<char> &&__rhs);
        void swap(std::basic_stringbuf<char> &__rhs);
        std::basic_stringbuf<char>::__string_type str() const {
            std::basic_stringbuf<char>::__string_type __ret(this->_M_string.get_allocator());
            if (std::basic_stringbuf<char>::char_type *__hi = this->_M_high_mark())
                __ret.assign(this->pbase(), __hi);
            else
                __ret = this->_M_string;
            return __ret;
        }
        void str(const std::basic_stringbuf<char>::__string_type &__s);
    protected:
        void _M_stringbuf_init(ios_base::openmode __mode);
        virtual std::streamsize showmanyc();
        virtual std::basic_stringbuf<char>::int_type underflow();
        virtual std::basic_stringbuf<char>::int_type pbackfail(std::basic_stringbuf<char>::int_type __c);
        virtual std::basic_stringbuf<char>::int_type overflow(std::basic_stringbuf<char>::int_type __c);
        virtual std::basic_stringbuf<char>::__streambuf_type *setbuf(std::basic_stringbuf<char>::char_type *__s, std::streamsize __n);
        virtual std::basic_stringbuf<char>::pos_type seekoff(std::basic_stringbuf<char>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        virtual std::basic_stringbuf<char>::pos_type seekpos(std::basic_stringbuf<char>::pos_type __sp, ios_base::openmode __mode);
        void _M_sync(std::basic_stringbuf<char>::char_type *__base, std::basic_stringbuf<char>::__size_type __i, std::basic_stringbuf<char>::__size_type __o);
        void _M_update_egptr();
        void _M_pbump(std::basic_stringbuf<char>::char_type *__pbeg, std::basic_stringbuf<char>::char_type *__pend, std::basic_stringbuf<char>::off_type __off);
    private:
        std::basic_stringbuf<char>::char_type *_M_high_mark() const noexcept {
            if (std::basic_stringbuf<char>::char_type *__pptr = this->pptr()) {
                std::basic_stringbuf<char>::char_type *__egptr = this->egptr();
                if (!__egptr || __pptr > __egptr)
                    return __pptr;
                else
                    return __egptr;
            }
            return 0;
        }
        struct __xfer_bufptrs;
        basic_stringbuf(std::basic_stringbuf<char> &&__rhs, std::basic_stringbuf<char>::__xfer_bufptrs &&);
    };
    template<> class basic_istringstream<char> : public basic_istream<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef std::allocator<char> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_string<char, std::char_traits<char>, std::allocator<char>> __string_type;
        typedef basic_stringbuf<char, std::char_traits<char>, std::allocator<char>> __stringbuf_type;
        typedef basic_istream<std::basic_istringstream<char>::char_type, std::basic_istringstream<char>::traits_type> __istream_type;
    private:
        std::basic_istringstream<char>::__stringbuf_type _M_stringbuf;
    public:
        basic_istringstream();
        explicit basic_istringstream(ios_base::openmode __mode);
        explicit basic_istringstream(const std::basic_istringstream<char>::__string_type &__str, ios_base::openmode __mode);
        ~basic_istringstream<char>() throw();
        basic_istringstream(const std::basic_istringstream<char> &) = delete
        basic_istringstream(std::basic_istringstream<char> &&__rhs);
        std::basic_istringstream<char> &operator=(const std::basic_istringstream<char> &) = delete
        std::basic_istringstream<char> &operator=(std::basic_istringstream<char> &&__rhs);
        void swap(std::basic_istringstream<char> &__rhs);
        std::basic_istringstream<char>::__stringbuf_type *rdbuf() const;
        std::basic_istringstream<char>::__string_type str() const;
        void str(const std::basic_istringstream<char>::__string_type &__s);
    };
    template<> class basic_ostringstream<char> : public basic_ostream<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef std::allocator<char> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_string<char, std::char_traits<char>, std::allocator<char>> __string_type;
        typedef basic_stringbuf<char, std::char_traits<char>, std::allocator<char>> __stringbuf_type;
        typedef basic_ostream<std::basic_ostringstream<char>::char_type, std::basic_ostringstream<char>::traits_type> __ostream_type;
    private:
        std::basic_ostringstream<char>::__stringbuf_type _M_stringbuf;
    public:
        basic_ostringstream();
        explicit basic_ostringstream(ios_base::openmode __mode);
        explicit basic_ostringstream(const std::basic_ostringstream<char>::__string_type &__str, ios_base::openmode __mode);
        ~basic_ostringstream<char>() throw();
        basic_ostringstream(const std::basic_ostringstream<char> &) = delete
        basic_ostringstream(std::basic_ostringstream<char> &&__rhs);
        std::basic_ostringstream<char> &operator=(const std::basic_ostringstream<char> &) = delete
        std::basic_ostringstream<char> &operator=(std::basic_ostringstream<char> &&__rhs);
        void swap(std::basic_ostringstream<char> &__rhs);
        std::basic_ostringstream<char>::__stringbuf_type *rdbuf() const;
        std::basic_ostringstream<char>::__string_type str() const;
        void str(const std::basic_ostringstream<char>::__string_type &__s);
    };
    template<> class basic_stringstream<char> : public basic_iostream<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef std::allocator<char> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_string<char, std::char_traits<char>, std::allocator<char>> __string_type;
        typedef basic_stringbuf<char, std::char_traits<char>, std::allocator<char>> __stringbuf_type;
        typedef basic_iostream<std::basic_stringstream<char>::char_type, std::basic_stringstream<char>::traits_type> __iostream_type;
    private:
        std::basic_stringstream<char>::__stringbuf_type _M_stringbuf;
    public:
        basic_stringstream() : basic_ios<char, std::char_traits<char>>(), std::basic_stringstream<char>::__iostream_type(), _M_stringbuf(ios_base::out | ios_base::in) {
            this->init(&this->_M_stringbuf);
        }
        explicit basic_stringstream(ios_base::openmode __m);
        explicit basic_stringstream(const std::basic_stringstream<char>::__string_type &__str, ios_base::openmode __m);
        ~basic_stringstream<char>() throw() {
        }
        basic_stringstream(const std::basic_stringstream<char> &) = delete
        basic_stringstream(std::basic_stringstream<char> &&__rhs);
        std::basic_stringstream<char> &operator=(const std::basic_stringstream<char> &) = delete
        std::basic_stringstream<char> &operator=(std::basic_stringstream<char> &&__rhs);
        void swap(std::basic_stringstream<char> &__rhs);
        std::basic_stringstream<char>::__stringbuf_type *rdbuf() const;
        std::basic_stringstream<char>::__string_type str() const {
            return this->_M_stringbuf.str();
        }
        void str(const std::basic_stringstream<char>::__string_type &__s);
    };
    template<> class basic_stringbuf<wchar_t> : public basic_streambuf<wchar_t, std::char_traits<wchar_t>> {
        struct __xfer_bufptrs {
            __xfer_bufptrs(const std::basic_stringbuf<wchar_t> &__from, std::basic_stringbuf<wchar_t> *__to);
            ~__xfer_bufptrs();
            std::basic_stringbuf<wchar_t> *_M_to;
            std::basic_stringbuf<wchar_t>::off_type _M_goff[3];
            std::basic_stringbuf<wchar_t>::off_type _M_poff[3];
        };
        using allocator_traits = std::allocator_traits<allocator<wchar_t>>;
        using _Noexcept_swap = __or_<typename allocator_traits::propagate_on_container_swap, typename allocator_traits::is_always_equal>;
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef std::allocator<wchar_t> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_stringbuf<wchar_t>::char_type, std::basic_stringbuf<wchar_t>::traits_type> __streambuf_type;
        typedef basic_string<std::basic_stringbuf<wchar_t>::char_type, std::char_traits<wchar_t>, std::allocator<wchar_t>> __string_type;
        typedef typename __string_type::size_type __size_type;
    protected:
        ios_base::openmode _M_mode;
        std::basic_stringbuf<wchar_t>::__string_type _M_string;
    public:
        basic_stringbuf();
        explicit basic_stringbuf(ios_base::openmode __mode);
        explicit basic_stringbuf(const std::basic_stringbuf<wchar_t>::__string_type &__str, ios_base::openmode __mode);
        basic_stringbuf(const std::basic_stringbuf<wchar_t> &) = delete
        basic_stringbuf(std::basic_stringbuf<wchar_t> &&__rhs);
        std::basic_stringbuf<wchar_t> &operator=(const std::basic_stringbuf<wchar_t> &) = delete
        std::basic_stringbuf<wchar_t> &operator=(std::basic_stringbuf<wchar_t> &&__rhs);
        void swap(std::basic_stringbuf<wchar_t> &__rhs);
        std::basic_stringbuf<wchar_t>::__string_type str() const;
        void str(const std::basic_stringbuf<wchar_t>::__string_type &__s);
    protected:
        void _M_stringbuf_init(ios_base::openmode __mode);
        virtual std::streamsize showmanyc();
        virtual std::basic_stringbuf<wchar_t>::int_type underflow();
        virtual std::basic_stringbuf<wchar_t>::int_type pbackfail(std::basic_stringbuf<wchar_t>::int_type __c);
        virtual std::basic_stringbuf<wchar_t>::int_type overflow(std::basic_stringbuf<wchar_t>::int_type __c);
        virtual std::basic_stringbuf<wchar_t>::__streambuf_type *setbuf(std::basic_stringbuf<wchar_t>::char_type *__s, std::streamsize __n);
        virtual std::basic_stringbuf<wchar_t>::pos_type seekoff(std::basic_stringbuf<wchar_t>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        virtual std::basic_stringbuf<wchar_t>::pos_type seekpos(std::basic_stringbuf<wchar_t>::pos_type __sp, ios_base::openmode __mode);
        void _M_sync(std::basic_stringbuf<wchar_t>::char_type *__base, std::basic_stringbuf<wchar_t>::__size_type __i, std::basic_stringbuf<wchar_t>::__size_type __o);
        void _M_update_egptr();
        void _M_pbump(std::basic_stringbuf<wchar_t>::char_type *__pbeg, std::basic_stringbuf<wchar_t>::char_type *__pend, std::basic_stringbuf<wchar_t>::off_type __off);
    private:
        std::basic_stringbuf<wchar_t>::char_type *_M_high_mark() const noexcept;
        struct __xfer_bufptrs;
        basic_stringbuf(std::basic_stringbuf<wchar_t> &&__rhs, std::basic_stringbuf<wchar_t>::__xfer_bufptrs &&);
    };
    template<> class basic_istringstream<wchar_t> : public basic_istream<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef std::allocator<wchar_t> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> __string_type;
        typedef basic_stringbuf<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> __stringbuf_type;
        typedef basic_istream<std::basic_istringstream<wchar_t>::char_type, std::basic_istringstream<wchar_t>::traits_type> __istream_type;
    private:
        std::basic_istringstream<wchar_t>::__stringbuf_type _M_stringbuf;
    public:
        basic_istringstream();
        explicit basic_istringstream(ios_base::openmode __mode);
        explicit basic_istringstream(const std::basic_istringstream<wchar_t>::__string_type &__str, ios_base::openmode __mode);
        ~basic_istringstream<wchar_t>() throw();
        basic_istringstream(const std::basic_istringstream<wchar_t> &) = delete
        basic_istringstream(std::basic_istringstream<wchar_t> &&__rhs);
        std::basic_istringstream<wchar_t> &operator=(const std::basic_istringstream<wchar_t> &) = delete
        std::basic_istringstream<wchar_t> &operator=(std::basic_istringstream<wchar_t> &&__rhs);
        void swap(std::basic_istringstream<wchar_t> &__rhs);
        std::basic_istringstream<wchar_t>::__stringbuf_type *rdbuf() const;
        std::basic_istringstream<wchar_t>::__string_type str() const;
        void str(const std::basic_istringstream<wchar_t>::__string_type &__s);
    };
    template<> class basic_ostringstream<wchar_t> : public basic_ostream<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef std::allocator<wchar_t> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> __string_type;
        typedef basic_stringbuf<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> __stringbuf_type;
        typedef basic_ostream<std::basic_ostringstream<wchar_t>::char_type, std::basic_ostringstream<wchar_t>::traits_type> __ostream_type;
    private:
        std::basic_ostringstream<wchar_t>::__stringbuf_type _M_stringbuf;
    public:
        basic_ostringstream();
        explicit basic_ostringstream(ios_base::openmode __mode);
        explicit basic_ostringstream(const std::basic_ostringstream<wchar_t>::__string_type &__str, ios_base::openmode __mode);
        ~basic_ostringstream<wchar_t>() throw();
        basic_ostringstream(const std::basic_ostringstream<wchar_t> &) = delete
        basic_ostringstream(std::basic_ostringstream<wchar_t> &&__rhs);
        std::basic_ostringstream<wchar_t> &operator=(const std::basic_ostringstream<wchar_t> &) = delete
        std::basic_ostringstream<wchar_t> &operator=(std::basic_ostringstream<wchar_t> &&__rhs);
        void swap(std::basic_ostringstream<wchar_t> &__rhs);
        std::basic_ostringstream<wchar_t>::__stringbuf_type *rdbuf() const;
        std::basic_ostringstream<wchar_t>::__string_type str() const;
        void str(const std::basic_ostringstream<wchar_t>::__string_type &__s);
    };
    template<> class basic_stringstream<wchar_t> : public basic_iostream<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef std::allocator<wchar_t> allocator_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> __string_type;
        typedef basic_stringbuf<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> __stringbuf_type;
        typedef basic_iostream<std::basic_stringstream<wchar_t>::char_type, std::basic_stringstream<wchar_t>::traits_type> __iostream_type;
    private:
        std::basic_stringstream<wchar_t>::__stringbuf_type _M_stringbuf;
    public:
        basic_stringstream();
        explicit basic_stringstream(ios_base::openmode __m);
        explicit basic_stringstream(const std::basic_stringstream<wchar_t>::__string_type &__str, ios_base::openmode __m);
        ~basic_stringstream<wchar_t>() throw();
        basic_stringstream(const std::basic_stringstream<wchar_t> &) = delete
        basic_stringstream(std::basic_stringstream<wchar_t> &&__rhs);
        std::basic_stringstream<wchar_t> &operator=(const std::basic_stringstream<wchar_t> &) = delete
        std::basic_stringstream<wchar_t> &operator=(std::basic_stringstream<wchar_t> &&__rhs);
        void swap(std::basic_stringstream<wchar_t> &__rhs);
        std::basic_stringstream<wchar_t>::__stringbuf_type *rdbuf() const;
        std::basic_stringstream<wchar_t>::__string_type str() const;
        void str(const std::basic_stringstream<wchar_t>::__string_type &__s);
    };
}
namespace utility {
    template <typename T> std::string typeInfo(T &t) {
        int status;
        char *realname;
        const std::type_info &ti = typeid(t);
        realname = abi::__cxa_demangle(ti.name(), __null, __null, &status);
        std::stringstream ss;
        ss << "Type Signature: " << ti.name() << "\t=> " << realname << "\t: " << status;
        return ss.str();
    }
    template<> std::string typeInfo<Filter<Scott>>(Filter<Scott> &t) {
        int status;
        char *realname;
        const std::type_info &ti = typeid(t);
        realname = abi::__cxa_demangle(ti.name(), __null, __null, &status);
        std::stringstream ss;
        ss << "Type Signature: " << ti.name() << "\t=> " << realname << "\t: " << status;
        return ss.str();
    }
    template<> std::string typeInfo<Filter<David>>(Filter<David> &t) {
        int status;
        char *realname;
        const std::type_info &ti = typeid(t);
        realname = abi::__cxa_demangle(ti.name(), __null, __null, &status);
        std::stringstream ss;
        ss << "Type Signature: " << ti.name() << "\t=> " << realname << "\t: " << status;
        return ss.str();
    }
    template<> std::string typeInfo<Filter<Mario>>(Filter<Mario> &t) {
        int status;
        char *realname;
        const std::type_info &ti = typeid(t);
        realname = abi::__cxa_demangle(ti.name(), __null, __null, &status);
        std::stringstream ss;
        ss << "Type Signature: " << ti.name() << "\t=> " << realname << "\t: " << status;
        return ss.str();
    }
}
namespace std {
    namespace rel_ops {
        template <class _Tp> inline bool operator!=(const _Tp &__x, const _Tp &__y) {
            return !(__x == __y);
        }
        template <class _Tp> inline bool operator>(const _Tp &__x, const _Tp &__y) {
            return __y < __x;
        }
        template <class _Tp> inline bool operator<=(const _Tp &__x, const _Tp &__y) {
            return !(__y < __x);
        }
        template <class _Tp> inline bool operator>=(const _Tp &__x, const _Tp &__y) {
            return !(__x < __y);
        }
    }
}
namespace std {
    template <typename _Tp, typename _Up = _Tp> inline _Tp exchange(_Tp &__obj, _Up &&__new_val) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_assignable<_Tp &, _Up>>::value) {
        return std::__exchange(__obj, std::forward<_Up>(__new_val));
    }
}
namespace std {
    template <typename _Tp, std::size_t _Nm> struct __array_traits {
        typedef _Tp _Type[_Nm];
        typedef __is_swappable<_Tp> _Is_swappable;
        typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
        static constexpr _Tp &_S_ref(const std::__array_traits::_Type &__t, std::size_t __n) noexcept {
            return const_cast<_Tp &>(__t[__n]);
        }
        static constexpr _Tp *_S_ptr(const std::__array_traits::_Type &__t) noexcept {
            return const_cast<_Tp *>(__t);
        }
    };
    template <typename _Tp> struct __array_traits<_Tp, 0> {
        struct _Type {
        };
        typedef std::true_type _Is_swappable;
        typedef std::true_type _Is_nothrow_swappable;
        static constexpr _Tp &_S_ref(const std::__array_traits<type-parameter-0-0, 0>::_Type &, std::size_t) noexcept {
            return *static_cast<_Tp *>(nullptr);
        }
        static constexpr _Tp *_S_ptr(const std::__array_traits<type-parameter-0-0, 0>::_Type &) noexcept {
            return nullptr;
        }
    };
    template <typename _Tp, std::size_t _Nm> struct array {
        typedef _Tp value_type;
        typedef std::array::value_type *pointer;
        typedef const std::array::value_type *const_pointer;
        typedef std::array::value_type &reference;
        typedef const std::array::value_type &const_reference;
        typedef std::array::value_type *iterator;
        typedef const std::array::value_type *const_iterator;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef __array_traits<_Tp, _Nm> _AT_Type;
        typename _AT_Type::_Type _M_elems;
        void fill(const std::array::value_type &__u) {
            std::fill_n(begin(), this->size(), __u);
        }
        void swap(array<_Tp, _Nm> &__other) noexcept(_AT_Type::_Is_nothrow_swappable::value) {
            std::swap_ranges(begin(), end(), __other.begin());
        }
        std::array::iterator begin() noexcept [[gnu::const]] [[nodiscard("")]] {
            return std::array::iterator(data());
        }
        std::array::const_iterator begin() const noexcept [[nodiscard("")]] {
            return std::array::const_iterator(data());
        }
        std::array::iterator end() noexcept [[gnu::const]] [[nodiscard("")]] {
            return std::array::iterator(data() + _Nm);
        }
        std::array::const_iterator end() const noexcept [[nodiscard("")]] {
            return std::array::const_iterator(data() + _Nm);
        }
        std::array::reverse_iterator rbegin() noexcept [[gnu::const]] [[nodiscard("")]] {
            return std::array::reverse_iterator(end());
        }
        std::array::const_reverse_iterator rbegin() const noexcept [[nodiscard("")]] {
            return std::array::const_reverse_iterator(end());
        }
        std::array::reverse_iterator rend() noexcept [[gnu::const]] [[nodiscard("")]] {
            return std::array::reverse_iterator(begin());
        }
        std::array::const_reverse_iterator rend() const noexcept [[nodiscard("")]] {
            return std::array::const_reverse_iterator(begin());
        }
        std::array::const_iterator cbegin() const noexcept [[nodiscard("")]] {
            return std::array::const_iterator(data());
        }
        std::array::const_iterator cend() const noexcept [[nodiscard("")]] {
            return std::array::const_iterator(data() + _Nm);
        }
        std::array::const_reverse_iterator crbegin() const noexcept [[nodiscard("")]] {
            return std::array::const_reverse_iterator(end());
        }
        std::array::const_reverse_iterator crend() const noexcept [[nodiscard("")]] {
            return std::array::const_reverse_iterator(begin());
        }
        constexpr std::array::size_type size() const noexcept [[gnu::const]] [[nodiscard("")]] {
            return _Nm;
        }
        constexpr std::array::size_type max_size() const noexcept [[gnu::const]] [[nodiscard("")]] {
            return _Nm;
        }
        constexpr bool empty() const noexcept [[gnu::const]] [[nodiscard("")]] {
            return this->size() == 0;
        }
        std::array::reference operator[](std::array::size_type __n) noexcept [[nodiscard("")]] {
            ;
            return _AT_Type::_S_ref(this->_M_elems, __n);
        }
        constexpr std::array::const_reference operator[](std::array::size_type __n) const noexcept [[nodiscard("")]] {
            ;
            return _AT_Type::_S_ref(this->_M_elems, __n);
        }
        std::array::reference at(std::array::size_type __n) {
            if (__n >= _Nm)
                std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) >= _Nm (which is %zu)"), __n, _Nm);
            return _AT_Type::_S_ref(this->_M_elems, __n);
        }
        constexpr std::array::const_reference at(std::array::size_type __n) const {
            return __n < _Nm ? _AT_Type::_S_ref(this->_M_elems, __n) : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) >= _Nm (which is %zu)"), __n, _Nm) , _AT_Type::_S_ref(this->_M_elems, 0));
        }
        std::array::reference front() noexcept [[nodiscard("")]] {
            ;
            return *begin();
        }
        constexpr std::array::const_reference front() const noexcept [[nodiscard("")]] {
            ;
            return _AT_Type::_S_ref(this->_M_elems, 0);
        }
        std::array::reference back() noexcept [[nodiscard("")]] {
            ;
            return _Nm ? *(end() - 1) : *end();
        }
        constexpr std::array::const_reference back() const noexcept [[nodiscard("")]] {
            ;
            return _Nm ? _AT_Type::_S_ref(this->_M_elems, _Nm - 1) : _AT_Type::_S_ref(this->_M_elems, 0);
        }
        std::array::pointer data() noexcept [[gnu::const]] [[nodiscard("")]] {
            return _AT_Type::_S_ptr(this->_M_elems);
        }
        std::array::const_pointer data() const noexcept [[nodiscard("")]] {
            return _AT_Type::_S_ptr(this->_M_elems);
        }
    };
    template <typename _Tp, std::size_t _Nm> inline bool operator==(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two) [[nodiscard("")]] {
        return std::equal(__one.begin(), __one.end(), __two.begin());
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator!=(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two) [[nodiscard("")]] {
        return !(__one == __two);
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator<(const array<_Tp, _Nm> &__a, const array<_Tp, _Nm> &__b) [[nodiscard("")]] {
        return std::lexicographical_compare(__a.begin(), __a.end(), __b.begin(), __b.end());
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator>(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two) [[nodiscard("")]] {
        return __two < __one;
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator<=(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two) [[nodiscard("")]] {
        return !(__one > __two);
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator>=(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two) [[nodiscard("")]] {
        return !(__one < __two);
    }
    template <typename _Tp, std::size_t _Nm> inline typename enable_if<__array_traits<_Tp, _Nm>::_Is_swappable::value>::type swap(array<_Tp, _Nm> &__one, array<_Tp, _Nm> &__two) noexcept(noexcept(__one.swap(__two))) {
        __one.swap(__two);
    }
    template <typename _Tp, std::size_t _Nm> typename enable_if<!__array_traits<_Tp, _Nm>::_Is_swappable::value>::type swap(array<_Tp, _Nm> &, array<_Tp, _Nm> &) = delete
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr _Tp &get(array<_Tp, _Nm> &__arr) noexcept [[nodiscard("")]] {
        static_assert(_Int < _Nm, "array index is within bounds");
        return __array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
    }
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr _Tp &&get(array<_Tp, _Nm> &&__arr) noexcept [[nodiscard("")]] {
        static_assert(_Int < _Nm, "array index is within bounds");
        return std::move(std::get<_Int>(__arr));
    }
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr const _Tp &get(const array<_Tp, _Nm> &__arr) noexcept [[nodiscard("")]] {
        static_assert(_Int < _Nm, "array index is within bounds");
        return __array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
    }
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr const _Tp &&get(const array<_Tp, _Nm> &&__arr) noexcept [[nodiscard("")]] {
        static_assert(_Int < _Nm, "array index is within bounds");
        return std::move(std::get<_Int>(__arr));
    }
    template <typename _Tp, std::size_t _Nm> struct tuple_size<array<_Tp, _Nm>> : public integral_constant<std::size_t, _Nm> {
    };
    template <std::size_t _Ind, typename _Tp, std::size_t _Nm> struct tuple_element<_Ind, array<_Tp, _Nm>> {
        static_assert(_Ind < _Nm, "array index is in range");
        using type = _Tp;
    };
    template <typename _Tp, std::size_t _Nm> struct __is_tuple_like_impl<array<_Tp, _Nm>> : std::true_type {
    };
}
extern "C" {
    typedef float float_t;
    typedef double double_t;
    enum {
        FP_INT_UPWARD = 0,
        FP_INT_DOWNWARD = 1,
        FP_INT_TOWARDZERO = 2,
        FP_INT_TONEARESTFROMZERO = 3,
        FP_INT_TONEAREST = 4
    };
    extern int __fpclassify(double __value) noexcept(true) __attribute__((const));
    extern int __signbit(double __value) noexcept(true) __attribute__((const));
    extern int __isinf(double __value) noexcept(true) __attribute__((const));
    extern int __finite(double __value) noexcept(true) __attribute__((const));
    extern int __isnan(double __value) noexcept(true) __attribute__((const));
    extern int __iseqsig(double __x, double __y) noexcept(true);
    extern int __issignaling(double __value) noexcept(true) __attribute__((const));
    extern double acos(double __x) noexcept(true);
    extern double __acos(double __x) noexcept(true);
    extern double asin(double __x) noexcept(true);
    extern double __asin(double __x) noexcept(true);
    extern double atan(double __x) noexcept(true);
    extern double __atan(double __x) noexcept(true);
    extern double atan2(double __y, double __x) noexcept(true);
    extern double __atan2(double __y, double __x) noexcept(true);
    extern double cos(double __x) noexcept(true);
    extern double __cos(double __x) noexcept(true);
    extern double sin(double __x) noexcept(true);
    extern double __sin(double __x) noexcept(true);
    extern double tan(double __x) noexcept(true);
    extern double __tan(double __x) noexcept(true);
    extern double cosh(double __x) noexcept(true);
    extern double __cosh(double __x) noexcept(true);
    extern double sinh(double __x) noexcept(true);
    extern double __sinh(double __x) noexcept(true);
    extern double tanh(double __x) noexcept(true);
    extern double __tanh(double __x) noexcept(true);
    extern void sincos(double __x, double *__sinx, double *__cosx) noexcept(true);
    extern void __sincos(double __x, double *__sinx, double *__cosx) noexcept(true);
    extern double acosh(double __x) noexcept(true);
    extern double __acosh(double __x) noexcept(true);
    extern double asinh(double __x) noexcept(true);
    extern double __asinh(double __x) noexcept(true);
    extern double atanh(double __x) noexcept(true);
    extern double __atanh(double __x) noexcept(true);
    extern double exp(double __x) noexcept(true);
    extern double __exp(double __x) noexcept(true);
    extern double frexp(double __x, int *__exponent) noexcept(true);
    extern double __frexp(double __x, int *__exponent) noexcept(true);
    extern double ldexp(double __x, int __exponent) noexcept(true);
    extern double __ldexp(double __x, int __exponent) noexcept(true);
    extern double log(double __x) noexcept(true);
    extern double __log(double __x) noexcept(true);
    extern double log10(double __x) noexcept(true);
    extern double __log10(double __x) noexcept(true);
    extern double modf(double __x, double *__iptr) noexcept(true);
    extern double __modf(double __x, double *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern double exp10(double __x) noexcept(true);
    extern double __exp10(double __x) noexcept(true);
    extern double expm1(double __x) noexcept(true);
    extern double __expm1(double __x) noexcept(true);
    extern double log1p(double __x) noexcept(true);
    extern double __log1p(double __x) noexcept(true);
    extern double logb(double __x) noexcept(true);
    extern double __logb(double __x) noexcept(true);
    extern double exp2(double __x) noexcept(true);
    extern double __exp2(double __x) noexcept(true);
    extern double log2(double __x) noexcept(true);
    extern double __log2(double __x) noexcept(true);
    extern double pow(double __x, double __y) noexcept(true);
    extern double __pow(double __x, double __y) noexcept(true);
    extern double sqrt(double __x) noexcept(true);
    extern double __sqrt(double __x) noexcept(true);
    extern double hypot(double __x, double __y) noexcept(true);
    extern double __hypot(double __x, double __y) noexcept(true);
    extern double cbrt(double __x) noexcept(true);
    extern double __cbrt(double __x) noexcept(true);
    extern double ceil(double __x) noexcept(true) __attribute__((const));
    extern double __ceil(double __x) noexcept(true) __attribute__((const));
    extern double fabs(double __x) noexcept(true) __attribute__((const));
    extern double __fabs(double __x) noexcept(true) __attribute__((const));
    extern double floor(double __x) noexcept(true) __attribute__((const));
    extern double __floor(double __x) noexcept(true) __attribute__((const));
    extern double fmod(double __x, double __y) noexcept(true);
    extern double __fmod(double __x, double __y) noexcept(true);
    extern int finite(double __value) noexcept(true) __attribute__((const));
    extern double drem(double __x, double __y) noexcept(true);
    extern double __drem(double __x, double __y) noexcept(true);
    extern double significand(double __x) noexcept(true);
    extern double __significand(double __x) noexcept(true);
    extern double copysign(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __copysign(double __x, double __y) noexcept(true) __attribute__((const));
    extern double nan(const char *__tagb) noexcept(true);
    extern double __nan(const char *__tagb) noexcept(true);
    extern double j0(double) noexcept(true);
    extern double __j0(double) noexcept(true);
    extern double j1(double) noexcept(true);
    extern double __j1(double) noexcept(true);
    extern double jn(int, double) noexcept(true);
    extern double __jn(int, double) noexcept(true);
    extern double y0(double) noexcept(true);
    extern double __y0(double) noexcept(true);
    extern double y1(double) noexcept(true);
    extern double __y1(double) noexcept(true);
    extern double yn(int, double) noexcept(true);
    extern double __yn(int, double) noexcept(true);
    extern double erf(double) noexcept(true);
    extern double __erf(double) noexcept(true);
    extern double erfc(double) noexcept(true);
    extern double __erfc(double) noexcept(true);
    extern double lgamma(double) noexcept(true);
    extern double __lgamma(double) noexcept(true);
    extern double tgamma(double) noexcept(true);
    extern double __tgamma(double) noexcept(true);
    extern double gamma(double) noexcept(true);
    extern double __gamma(double) noexcept(true);
    extern double lgamma_r(double, int *__signgamp) noexcept(true);
    extern double __lgamma_r(double, int *__signgamp) noexcept(true);
    extern double rint(double __x) noexcept(true);
    extern double __rint(double __x) noexcept(true);
    extern double nextafter(double __x, double __y) noexcept(true);
    extern double __nextafter(double __x, double __y) noexcept(true);
    extern double nexttoward(double __x, long double __y) noexcept(true);
    extern double __nexttoward(double __x, long double __y) noexcept(true);
    extern double nextdown(double __x) noexcept(true);
    extern double __nextdown(double __x) noexcept(true);
    extern double nextup(double __x) noexcept(true);
    extern double __nextup(double __x) noexcept(true);
    extern double remainder(double __x, double __y) noexcept(true);
    extern double __remainder(double __x, double __y) noexcept(true);
    extern double scalbn(double __x, int __n) noexcept(true);
    extern double __scalbn(double __x, int __n) noexcept(true);
    extern int ilogb(double __x) noexcept(true);
    extern int __ilogb(double __x) noexcept(true);
    extern long llogb(double __x) noexcept(true);
    extern long __llogb(double __x) noexcept(true);
    extern double scalbln(double __x, long __n) noexcept(true);
    extern double __scalbln(double __x, long __n) noexcept(true);
    extern double nearbyint(double __x) noexcept(true);
    extern double __nearbyint(double __x) noexcept(true);
    extern double round(double __x) noexcept(true) __attribute__((const));
    extern double __round(double __x) noexcept(true) __attribute__((const));
    extern double trunc(double __x) noexcept(true) __attribute__((const));
    extern double __trunc(double __x) noexcept(true) __attribute__((const));
    extern double remquo(double __x, double __y, int *__quo) noexcept(true);
    extern double __remquo(double __x, double __y, int *__quo) noexcept(true);
    extern long lrint(double __x) noexcept(true);
    extern long __lrint(double __x) noexcept(true);
    extern long long llrint(double __x) noexcept(true);
    extern long long __llrint(double __x) noexcept(true);
    extern long lround(double __x) noexcept(true);
    extern long __lround(double __x) noexcept(true);
    extern long long llround(double __x) noexcept(true);
    extern long long __llround(double __x) noexcept(true);
    extern double fdim(double __x, double __y) noexcept(true);
    extern double __fdim(double __x, double __y) noexcept(true);
    extern double fmax(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmax(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmin(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmin(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fma(double __x, double __y, double __z) noexcept(true);
    extern double __fma(double __x, double __y, double __z) noexcept(true);
    extern double roundeven(double __x) noexcept(true) __attribute__((const));
    extern double __roundeven(double __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalize(double *__cx, const double *__x) noexcept(true);
    extern double fmaxmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaxmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern int totalorder(const double *__x, const double *__y) noexcept(true) __attribute__((pure));
    extern int totalordermag(const double *__x, const double *__y) noexcept(true) __attribute__((pure));
    extern double getpayload(const double *__x) noexcept(true);
    extern double __getpayload(const double *__x) noexcept(true);
    extern int setpayload(double *__x, double __payload) noexcept(true);
    extern int setpayloadsig(double *__x, double __payload) noexcept(true);
    extern double scalb(double __x, double __n) noexcept(true);
    extern double __scalb(double __x, double __n) noexcept(true);
    extern int __fpclassifyf(float __value) noexcept(true) __attribute__((const));
    extern int __signbitf(float __value) noexcept(true) __attribute__((const));
    extern int __isinff(float __value) noexcept(true) __attribute__((const));
    extern int __finitef(float __value) noexcept(true) __attribute__((const));
    extern int __isnanf(float __value) noexcept(true) __attribute__((const));
    extern int __iseqsigf(float __x, float __y) noexcept(true);
    extern int __issignalingf(float __value) noexcept(true) __attribute__((const));
    extern float acosf(float __x) noexcept(true);
    extern float __acosf(float __x) noexcept(true);
    extern float asinf(float __x) noexcept(true);
    extern float __asinf(float __x) noexcept(true);
    extern float atanf(float __x) noexcept(true);
    extern float __atanf(float __x) noexcept(true);
    extern float atan2f(float __y, float __x) noexcept(true);
    extern float __atan2f(float __y, float __x) noexcept(true);
    extern float cosf(float __x) noexcept(true);
    extern float __cosf(float __x) noexcept(true);
    extern float sinf(float __x) noexcept(true);
    extern float __sinf(float __x) noexcept(true);
    extern float tanf(float __x) noexcept(true);
    extern float __tanf(float __x) noexcept(true);
    extern float coshf(float __x) noexcept(true);
    extern float __coshf(float __x) noexcept(true);
    extern float sinhf(float __x) noexcept(true);
    extern float __sinhf(float __x) noexcept(true);
    extern float tanhf(float __x) noexcept(true);
    extern float __tanhf(float __x) noexcept(true);
    extern void sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);
    extern void __sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);
    extern float acoshf(float __x) noexcept(true);
    extern float __acoshf(float __x) noexcept(true);
    extern float asinhf(float __x) noexcept(true);
    extern float __asinhf(float __x) noexcept(true);
    extern float atanhf(float __x) noexcept(true);
    extern float __atanhf(float __x) noexcept(true);
    extern float expf(float __x) noexcept(true);
    extern float __expf(float __x) noexcept(true);
    extern float frexpf(float __x, int *__exponent) noexcept(true);
    extern float __frexpf(float __x, int *__exponent) noexcept(true);
    extern float ldexpf(float __x, int __exponent) noexcept(true);
    extern float __ldexpf(float __x, int __exponent) noexcept(true);
    extern float logf(float __x) noexcept(true);
    extern float __logf(float __x) noexcept(true);
    extern float log10f(float __x) noexcept(true);
    extern float __log10f(float __x) noexcept(true);
    extern float modff(float __x, float *__iptr) noexcept(true);
    extern float __modff(float __x, float *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern float exp10f(float __x) noexcept(true);
    extern float __exp10f(float __x) noexcept(true);
    extern float expm1f(float __x) noexcept(true);
    extern float __expm1f(float __x) noexcept(true);
    extern float log1pf(float __x) noexcept(true);
    extern float __log1pf(float __x) noexcept(true);
    extern float logbf(float __x) noexcept(true);
    extern float __logbf(float __x) noexcept(true);
    extern float exp2f(float __x) noexcept(true);
    extern float __exp2f(float __x) noexcept(true);
    extern float log2f(float __x) noexcept(true);
    extern float __log2f(float __x) noexcept(true);
    extern float powf(float __x, float __y) noexcept(true);
    extern float __powf(float __x, float __y) noexcept(true);
    extern float sqrtf(float __x) noexcept(true);
    extern float __sqrtf(float __x) noexcept(true);
    extern float hypotf(float __x, float __y) noexcept(true);
    extern float __hypotf(float __x, float __y) noexcept(true);
    extern float cbrtf(float __x) noexcept(true);
    extern float __cbrtf(float __x) noexcept(true);
    extern float ceilf(float __x) noexcept(true) __attribute__((const));
    extern float __ceilf(float __x) noexcept(true) __attribute__((const));
    extern float fabsf(float __x) noexcept(true) __attribute__((const));
    extern float __fabsf(float __x) noexcept(true) __attribute__((const));
    extern float floorf(float __x) noexcept(true) __attribute__((const));
    extern float __floorf(float __x) noexcept(true) __attribute__((const));
    extern float fmodf(float __x, float __y) noexcept(true);
    extern float __fmodf(float __x, float __y) noexcept(true);
    extern int isinff(float __value) noexcept(true) __attribute__((const));
    extern int finitef(float __value) noexcept(true) __attribute__((const));
    extern float dremf(float __x, float __y) noexcept(true);
    extern float __dremf(float __x, float __y) noexcept(true);
    extern float significandf(float __x) noexcept(true);
    extern float __significandf(float __x) noexcept(true);
    extern float copysignf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __copysignf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float nanf(const char *__tagb) noexcept(true);
    extern float __nanf(const char *__tagb) noexcept(true);
    extern int isnanf(float __value) noexcept(true) __attribute__((const));
    extern float j0f(float) noexcept(true);
    extern float __j0f(float) noexcept(true);
    extern float j1f(float) noexcept(true);
    extern float __j1f(float) noexcept(true);
    extern float jnf(int, float) noexcept(true);
    extern float __jnf(int, float) noexcept(true);
    extern float y0f(float) noexcept(true);
    extern float __y0f(float) noexcept(true);
    extern float y1f(float) noexcept(true);
    extern float __y1f(float) noexcept(true);
    extern float ynf(int, float) noexcept(true);
    extern float __ynf(int, float) noexcept(true);
    extern float erff(float) noexcept(true);
    extern float __erff(float) noexcept(true);
    extern float erfcf(float) noexcept(true);
    extern float __erfcf(float) noexcept(true);
    extern float lgammaf(float) noexcept(true);
    extern float __lgammaf(float) noexcept(true);
    extern float tgammaf(float) noexcept(true);
    extern float __tgammaf(float) noexcept(true);
    extern float gammaf(float) noexcept(true);
    extern float __gammaf(float) noexcept(true);
    extern float lgammaf_r(float, int *__signgamp) noexcept(true);
    extern float __lgammaf_r(float, int *__signgamp) noexcept(true);
    extern float rintf(float __x) noexcept(true);
    extern float __rintf(float __x) noexcept(true);
    extern float nextafterf(float __x, float __y) noexcept(true);
    extern float __nextafterf(float __x, float __y) noexcept(true);
    extern float nexttowardf(float __x, long double __y) noexcept(true);
    extern float __nexttowardf(float __x, long double __y) noexcept(true);
    extern float nextdownf(float __x) noexcept(true);
    extern float __nextdownf(float __x) noexcept(true);
    extern float nextupf(float __x) noexcept(true);
    extern float __nextupf(float __x) noexcept(true);
    extern float remainderf(float __x, float __y) noexcept(true);
    extern float __remainderf(float __x, float __y) noexcept(true);
    extern float scalbnf(float __x, int __n) noexcept(true);
    extern float __scalbnf(float __x, int __n) noexcept(true);
    extern int ilogbf(float __x) noexcept(true);
    extern int __ilogbf(float __x) noexcept(true);
    extern long llogbf(float __x) noexcept(true);
    extern long __llogbf(float __x) noexcept(true);
    extern float scalblnf(float __x, long __n) noexcept(true);
    extern float __scalblnf(float __x, long __n) noexcept(true);
    extern float nearbyintf(float __x) noexcept(true);
    extern float __nearbyintf(float __x) noexcept(true);
    extern float roundf(float __x) noexcept(true) __attribute__((const));
    extern float __roundf(float __x) noexcept(true) __attribute__((const));
    extern float truncf(float __x) noexcept(true) __attribute__((const));
    extern float __truncf(float __x) noexcept(true) __attribute__((const));
    extern float remquof(float __x, float __y, int *__quo) noexcept(true);
    extern float __remquof(float __x, float __y, int *__quo) noexcept(true);
    extern long lrintf(float __x) noexcept(true);
    extern long __lrintf(float __x) noexcept(true);
    extern long long llrintf(float __x) noexcept(true);
    extern long long __llrintf(float __x) noexcept(true);
    extern long lroundf(float __x) noexcept(true);
    extern long __lroundf(float __x) noexcept(true);
    extern long long llroundf(float __x) noexcept(true);
    extern long long __llroundf(float __x) noexcept(true);
    extern float fdimf(float __x, float __y) noexcept(true);
    extern float __fdimf(float __x, float __y) noexcept(true);
    extern float fmaxf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaxf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaf(float __x, float __y, float __z) noexcept(true);
    extern float __fmaf(float __x, float __y, float __z) noexcept(true);
    extern float roundevenf(float __x) noexcept(true) __attribute__((const));
    extern float __roundevenf(float __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef(float *__cx, const float *__x) noexcept(true);
    extern float fmaxmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaxmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern int totalorderf(const float *__x, const float *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf(const float *__x, const float *__y) noexcept(true) __attribute__((pure));
    extern float getpayloadf(const float *__x) noexcept(true);
    extern float __getpayloadf(const float *__x) noexcept(true);
    extern int setpayloadf(float *__x, float __payload) noexcept(true);
    extern int setpayloadsigf(float *__x, float __payload) noexcept(true);
    extern float scalbf(float __x, float __n) noexcept(true);
    extern float __scalbf(float __x, float __n) noexcept(true);
    extern int __fpclassifyl(long double __value) noexcept(true) __attribute__((const));
    extern int __signbitl(long double __value) noexcept(true) __attribute__((const));
    extern int __isinfl(long double __value) noexcept(true) __attribute__((const));
    extern int __finitel(long double __value) noexcept(true) __attribute__((const));
    extern int __isnanl(long double __value) noexcept(true) __attribute__((const));
    extern int __iseqsigl(long double __x, long double __y) noexcept(true);
    extern int __issignalingl(long double __value) noexcept(true) __attribute__((const));
    extern long double acosl(long double __x) noexcept(true);
    extern long double __acosl(long double __x) noexcept(true);
    extern long double asinl(long double __x) noexcept(true);
    extern long double __asinl(long double __x) noexcept(true);
    extern long double atanl(long double __x) noexcept(true);
    extern long double __atanl(long double __x) noexcept(true);
    extern long double atan2l(long double __y, long double __x) noexcept(true);
    extern long double __atan2l(long double __y, long double __x) noexcept(true);
    extern long double cosl(long double __x) noexcept(true);
    extern long double __cosl(long double __x) noexcept(true);
    extern long double sinl(long double __x) noexcept(true);
    extern long double __sinl(long double __x) noexcept(true);
    extern long double tanl(long double __x) noexcept(true);
    extern long double __tanl(long double __x) noexcept(true);
    extern long double coshl(long double __x) noexcept(true);
    extern long double __coshl(long double __x) noexcept(true);
    extern long double sinhl(long double __x) noexcept(true);
    extern long double __sinhl(long double __x) noexcept(true);
    extern long double tanhl(long double __x) noexcept(true);
    extern long double __tanhl(long double __x) noexcept(true);
    extern void sincosl(long double __x, long double *__sinx, long double *__cosx) noexcept(true);
    extern void __sincosl(long double __x, long double *__sinx, long double *__cosx) noexcept(true);
    extern long double acoshl(long double __x) noexcept(true);
    extern long double __acoshl(long double __x) noexcept(true);
    extern long double asinhl(long double __x) noexcept(true);
    extern long double __asinhl(long double __x) noexcept(true);
    extern long double atanhl(long double __x) noexcept(true);
    extern long double __atanhl(long double __x) noexcept(true);
    extern long double expl(long double __x) noexcept(true);
    extern long double __expl(long double __x) noexcept(true);
    extern long double frexpl(long double __x, int *__exponent) noexcept(true);
    extern long double __frexpl(long double __x, int *__exponent) noexcept(true);
    extern long double ldexpl(long double __x, int __exponent) noexcept(true);
    extern long double __ldexpl(long double __x, int __exponent) noexcept(true);
    extern long double logl(long double __x) noexcept(true);
    extern long double __logl(long double __x) noexcept(true);
    extern long double log10l(long double __x) noexcept(true);
    extern long double __log10l(long double __x) noexcept(true);
    extern long double modfl(long double __x, long double *__iptr) noexcept(true);
    extern long double __modfl(long double __x, long double *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern long double exp10l(long double __x) noexcept(true);
    extern long double __exp10l(long double __x) noexcept(true);
    extern long double expm1l(long double __x) noexcept(true);
    extern long double __expm1l(long double __x) noexcept(true);
    extern long double log1pl(long double __x) noexcept(true);
    extern long double __log1pl(long double __x) noexcept(true);
    extern long double logbl(long double __x) noexcept(true);
    extern long double __logbl(long double __x) noexcept(true);
    extern long double exp2l(long double __x) noexcept(true);
    extern long double __exp2l(long double __x) noexcept(true);
    extern long double log2l(long double __x) noexcept(true);
    extern long double __log2l(long double __x) noexcept(true);
    extern long double powl(long double __x, long double __y) noexcept(true);
    extern long double __powl(long double __x, long double __y) noexcept(true);
    extern long double sqrtl(long double __x) noexcept(true);
    extern long double __sqrtl(long double __x) noexcept(true);
    extern long double hypotl(long double __x, long double __y) noexcept(true);
    extern long double __hypotl(long double __x, long double __y) noexcept(true);
    extern long double cbrtl(long double __x) noexcept(true);
    extern long double __cbrtl(long double __x) noexcept(true);
    extern long double ceill(long double __x) noexcept(true) __attribute__((const));
    extern long double __ceill(long double __x) noexcept(true) __attribute__((const));
    extern long double fabsl(long double __x) noexcept(true) __attribute__((const));
    extern long double __fabsl(long double __x) noexcept(true) __attribute__((const));
    extern long double floorl(long double __x) noexcept(true) __attribute__((const));
    extern long double __floorl(long double __x) noexcept(true) __attribute__((const));
    extern long double fmodl(long double __x, long double __y) noexcept(true);
    extern long double __fmodl(long double __x, long double __y) noexcept(true);
    extern int isinfl(long double __value) noexcept(true) __attribute__((const));
    extern int finitel(long double __value) noexcept(true) __attribute__((const));
    extern long double dreml(long double __x, long double __y) noexcept(true);
    extern long double __dreml(long double __x, long double __y) noexcept(true);
    extern long double significandl(long double __x) noexcept(true);
    extern long double __significandl(long double __x) noexcept(true);
    extern long double copysignl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __copysignl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double nanl(const char *__tagb) noexcept(true);
    extern long double __nanl(const char *__tagb) noexcept(true);
    extern int isnanl(long double __value) noexcept(true) __attribute__((const));
    extern long double j0l(long double) noexcept(true);
    extern long double __j0l(long double) noexcept(true);
    extern long double j1l(long double) noexcept(true);
    extern long double __j1l(long double) noexcept(true);
    extern long double jnl(int, long double) noexcept(true);
    extern long double __jnl(int, long double) noexcept(true);
    extern long double y0l(long double) noexcept(true);
    extern long double __y0l(long double) noexcept(true);
    extern long double y1l(long double) noexcept(true);
    extern long double __y1l(long double) noexcept(true);
    extern long double ynl(int, long double) noexcept(true);
    extern long double __ynl(int, long double) noexcept(true);
    extern long double erfl(long double) noexcept(true);
    extern long double __erfl(long double) noexcept(true);
    extern long double erfcl(long double) noexcept(true);
    extern long double __erfcl(long double) noexcept(true);
    extern long double lgammal(long double) noexcept(true);
    extern long double __lgammal(long double) noexcept(true);
    extern long double tgammal(long double) noexcept(true);
    extern long double __tgammal(long double) noexcept(true);
    extern long double gammal(long double) noexcept(true);
    extern long double __gammal(long double) noexcept(true);
    extern long double lgammal_r(long double, int *__signgamp) noexcept(true);
    extern long double __lgammal_r(long double, int *__signgamp) noexcept(true);
    extern long double rintl(long double __x) noexcept(true);
    extern long double __rintl(long double __x) noexcept(true);
    extern long double nextafterl(long double __x, long double __y) noexcept(true);
    extern long double __nextafterl(long double __x, long double __y) noexcept(true);
    extern long double nexttowardl(long double __x, long double __y) noexcept(true);
    extern long double __nexttowardl(long double __x, long double __y) noexcept(true);
    extern long double nextdownl(long double __x) noexcept(true);
    extern long double __nextdownl(long double __x) noexcept(true);
    extern long double nextupl(long double __x) noexcept(true);
    extern long double __nextupl(long double __x) noexcept(true);
    extern long double remainderl(long double __x, long double __y) noexcept(true);
    extern long double __remainderl(long double __x, long double __y) noexcept(true);
    extern long double scalbnl(long double __x, int __n) noexcept(true);
    extern long double __scalbnl(long double __x, int __n) noexcept(true);
    extern int ilogbl(long double __x) noexcept(true);
    extern int __ilogbl(long double __x) noexcept(true);
    extern long llogbl(long double __x) noexcept(true);
    extern long __llogbl(long double __x) noexcept(true);
    extern long double scalblnl(long double __x, long __n) noexcept(true);
    extern long double __scalblnl(long double __x, long __n) noexcept(true);
    extern long double nearbyintl(long double __x) noexcept(true);
    extern long double __nearbyintl(long double __x) noexcept(true);
    extern long double roundl(long double __x) noexcept(true) __attribute__((const));
    extern long double __roundl(long double __x) noexcept(true) __attribute__((const));
    extern long double truncl(long double __x) noexcept(true) __attribute__((const));
    extern long double __truncl(long double __x) noexcept(true) __attribute__((const));
    extern long double remquol(long double __x, long double __y, int *__quo) noexcept(true);
    extern long double __remquol(long double __x, long double __y, int *__quo) noexcept(true);
    extern long lrintl(long double __x) noexcept(true);
    extern long __lrintl(long double __x) noexcept(true);
    extern long long llrintl(long double __x) noexcept(true);
    extern long long __llrintl(long double __x) noexcept(true);
    extern long lroundl(long double __x) noexcept(true);
    extern long __lroundl(long double __x) noexcept(true);
    extern long long llroundl(long double __x) noexcept(true);
    extern long long __llroundl(long double __x) noexcept(true);
    extern long double fdiml(long double __x, long double __y) noexcept(true);
    extern long double __fdiml(long double __x, long double __y) noexcept(true);
    extern long double fmaxl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaxl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmal(long double __x, long double __y, long double __z) noexcept(true);
    extern long double __fmal(long double __x, long double __y, long double __z) noexcept(true);
    extern long double roundevenl(long double __x) noexcept(true) __attribute__((const));
    extern long double __roundevenl(long double __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizel(long double *__cx, const long double *__x) noexcept(true);
    extern long double fmaxmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaxmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern int totalorderl(const long double *__x, const long double *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagl(const long double *__x, const long double *__y) noexcept(true) __attribute__((pure));
    extern long double getpayloadl(const long double *__x) noexcept(true);
    extern long double __getpayloadl(const long double *__x) noexcept(true);
    extern int setpayloadl(long double *__x, long double __payload) noexcept(true);
    extern int setpayloadsigl(long double *__x, long double __payload) noexcept(true);
    extern long double scalbl(long double __x, long double __n) noexcept(true);
    extern long double __scalbl(long double __x, long double __n) noexcept(true);
    extern _Float32 acosf32(_Float32 __x) noexcept(true);
    extern _Float32 __acosf32(_Float32 __x) noexcept(true);
    extern _Float32 asinf32(_Float32 __x) noexcept(true);
    extern _Float32 __asinf32(_Float32 __x) noexcept(true);
    extern _Float32 atanf32(_Float32 __x) noexcept(true);
    extern _Float32 __atanf32(_Float32 __x) noexcept(true);
    extern _Float32 atan2f32(_Float32 __y, _Float32 __x) noexcept(true);
    extern _Float32 __atan2f32(_Float32 __y, _Float32 __x) noexcept(true);
    extern _Float32 cosf32(_Float32 __x) noexcept(true);
    extern _Float32 __cosf32(_Float32 __x) noexcept(true);
    extern _Float32 sinf32(_Float32 __x) noexcept(true);
    extern _Float32 __sinf32(_Float32 __x) noexcept(true);
    extern _Float32 tanf32(_Float32 __x) noexcept(true);
    extern _Float32 __tanf32(_Float32 __x) noexcept(true);
    extern _Float32 coshf32(_Float32 __x) noexcept(true);
    extern _Float32 __coshf32(_Float32 __x) noexcept(true);
    extern _Float32 sinhf32(_Float32 __x) noexcept(true);
    extern _Float32 __sinhf32(_Float32 __x) noexcept(true);
    extern _Float32 tanhf32(_Float32 __x) noexcept(true);
    extern _Float32 __tanhf32(_Float32 __x) noexcept(true);
    extern void sincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept(true);
    extern void __sincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept(true);
    extern _Float32 acoshf32(_Float32 __x) noexcept(true);
    extern _Float32 __acoshf32(_Float32 __x) noexcept(true);
    extern _Float32 asinhf32(_Float32 __x) noexcept(true);
    extern _Float32 __asinhf32(_Float32 __x) noexcept(true);
    extern _Float32 atanhf32(_Float32 __x) noexcept(true);
    extern _Float32 __atanhf32(_Float32 __x) noexcept(true);
    extern _Float32 expf32(_Float32 __x) noexcept(true);
    extern _Float32 __expf32(_Float32 __x) noexcept(true);
    extern _Float32 frexpf32(_Float32 __x, int *__exponent) noexcept(true);
    extern _Float32 __frexpf32(_Float32 __x, int *__exponent) noexcept(true);
    extern _Float32 ldexpf32(_Float32 __x, int __exponent) noexcept(true);
    extern _Float32 __ldexpf32(_Float32 __x, int __exponent) noexcept(true);
    extern _Float32 logf32(_Float32 __x) noexcept(true);
    extern _Float32 __logf32(_Float32 __x) noexcept(true);
    extern _Float32 log10f32(_Float32 __x) noexcept(true);
    extern _Float32 __log10f32(_Float32 __x) noexcept(true);
    extern _Float32 modff32(_Float32 __x, _Float32 *__iptr) noexcept(true);
    extern _Float32 __modff32(_Float32 __x, _Float32 *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float32 exp10f32(_Float32 __x) noexcept(true);
    extern _Float32 __exp10f32(_Float32 __x) noexcept(true);
    extern _Float32 expm1f32(_Float32 __x) noexcept(true);
    extern _Float32 __expm1f32(_Float32 __x) noexcept(true);
    extern _Float32 log1pf32(_Float32 __x) noexcept(true);
    extern _Float32 __log1pf32(_Float32 __x) noexcept(true);
    extern _Float32 logbf32(_Float32 __x) noexcept(true);
    extern _Float32 __logbf32(_Float32 __x) noexcept(true);
    extern _Float32 exp2f32(_Float32 __x) noexcept(true);
    extern _Float32 __exp2f32(_Float32 __x) noexcept(true);
    extern _Float32 log2f32(_Float32 __x) noexcept(true);
    extern _Float32 __log2f32(_Float32 __x) noexcept(true);
    extern _Float32 powf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __powf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 sqrtf32(_Float32 __x) noexcept(true);
    extern _Float32 __sqrtf32(_Float32 __x) noexcept(true);
    extern _Float32 hypotf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __hypotf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 cbrtf32(_Float32 __x) noexcept(true);
    extern _Float32 __cbrtf32(_Float32 __x) noexcept(true);
    extern _Float32 ceilf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __ceilf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 fabsf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __fabsf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 floorf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __floorf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 copysignf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __copysignf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 nanf32(const char *__tagb) noexcept(true);
    extern _Float32 __nanf32(const char *__tagb) noexcept(true);
    extern _Float32 j0f32(_Float32) noexcept(true);
    extern _Float32 __j0f32(_Float32) noexcept(true);
    extern _Float32 j1f32(_Float32) noexcept(true);
    extern _Float32 __j1f32(_Float32) noexcept(true);
    extern _Float32 jnf32(int, _Float32) noexcept(true);
    extern _Float32 __jnf32(int, _Float32) noexcept(true);
    extern _Float32 y0f32(_Float32) noexcept(true);
    extern _Float32 __y0f32(_Float32) noexcept(true);
    extern _Float32 y1f32(_Float32) noexcept(true);
    extern _Float32 __y1f32(_Float32) noexcept(true);
    extern _Float32 ynf32(int, _Float32) noexcept(true);
    extern _Float32 __ynf32(int, _Float32) noexcept(true);
    extern _Float32 erff32(_Float32) noexcept(true);
    extern _Float32 __erff32(_Float32) noexcept(true);
    extern _Float32 erfcf32(_Float32) noexcept(true);
    extern _Float32 __erfcf32(_Float32) noexcept(true);
    extern _Float32 lgammaf32(_Float32) noexcept(true);
    extern _Float32 __lgammaf32(_Float32) noexcept(true);
    extern _Float32 tgammaf32(_Float32) noexcept(true);
    extern _Float32 __tgammaf32(_Float32) noexcept(true);
    extern _Float32 lgammaf32_r(_Float32, int *__signgamp) noexcept(true);
    extern _Float32 __lgammaf32_r(_Float32, int *__signgamp) noexcept(true);
    extern _Float32 rintf32(_Float32 __x) noexcept(true);
    extern _Float32 __rintf32(_Float32 __x) noexcept(true);
    extern _Float32 nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 nextdownf32(_Float32 __x) noexcept(true);
    extern _Float32 __nextdownf32(_Float32 __x) noexcept(true);
    extern _Float32 nextupf32(_Float32 __x) noexcept(true);
    extern _Float32 __nextupf32(_Float32 __x) noexcept(true);
    extern _Float32 remainderf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __remainderf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 scalbnf32(_Float32 __x, int __n) noexcept(true);
    extern _Float32 __scalbnf32(_Float32 __x, int __n) noexcept(true);
    extern int ilogbf32(_Float32 __x) noexcept(true);
    extern int __ilogbf32(_Float32 __x) noexcept(true);
    extern long llogbf32(_Float32 __x) noexcept(true);
    extern long __llogbf32(_Float32 __x) noexcept(true);
    extern _Float32 scalblnf32(_Float32 __x, long __n) noexcept(true);
    extern _Float32 __scalblnf32(_Float32 __x, long __n) noexcept(true);
    extern _Float32 nearbyintf32(_Float32 __x) noexcept(true);
    extern _Float32 __nearbyintf32(_Float32 __x) noexcept(true);
    extern _Float32 roundf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __roundf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 truncf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __truncf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 remquof32(_Float32 __x, _Float32 __y, int *__quo) noexcept(true);
    extern _Float32 __remquof32(_Float32 __x, _Float32 __y, int *__quo) noexcept(true);
    extern long lrintf32(_Float32 __x) noexcept(true);
    extern long __lrintf32(_Float32 __x) noexcept(true);
    extern long long llrintf32(_Float32 __x) noexcept(true);
    extern long long __llrintf32(_Float32 __x) noexcept(true);
    extern long lroundf32(_Float32 __x) noexcept(true);
    extern long __lroundf32(_Float32 __x) noexcept(true);
    extern long long llroundf32(_Float32 __x) noexcept(true);
    extern long long __llroundf32(_Float32 __x) noexcept(true);
    extern _Float32 fdimf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __fdimf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 fmaxf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaxf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true);
    extern _Float32 __fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true);
    extern _Float32 roundevenf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __roundevenf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef32(_Float32 *__cx, const _Float32 *__x) noexcept(true);
    extern _Float32 fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern int totalorderf32(const _Float32 *__x, const _Float32 *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf32(const _Float32 *__x, const _Float32 *__y) noexcept(true) __attribute__((pure));
    extern _Float32 getpayloadf32(const _Float32 *__x) noexcept(true);
    extern _Float32 __getpayloadf32(const _Float32 *__x) noexcept(true);
    extern int setpayloadf32(_Float32 *__x, _Float32 __payload) noexcept(true);
    extern int setpayloadsigf32(_Float32 *__x, _Float32 __payload) noexcept(true);
    extern _Float64 acosf64(_Float64 __x) noexcept(true);
    extern _Float64 __acosf64(_Float64 __x) noexcept(true);
    extern _Float64 asinf64(_Float64 __x) noexcept(true);
    extern _Float64 __asinf64(_Float64 __x) noexcept(true);
    extern _Float64 atanf64(_Float64 __x) noexcept(true);
    extern _Float64 __atanf64(_Float64 __x) noexcept(true);
    extern _Float64 atan2f64(_Float64 __y, _Float64 __x) noexcept(true);
    extern _Float64 __atan2f64(_Float64 __y, _Float64 __x) noexcept(true);
    extern _Float64 cosf64(_Float64 __x) noexcept(true);
    extern _Float64 __cosf64(_Float64 __x) noexcept(true);
    extern _Float64 sinf64(_Float64 __x) noexcept(true);
    extern _Float64 __sinf64(_Float64 __x) noexcept(true);
    extern _Float64 tanf64(_Float64 __x) noexcept(true);
    extern _Float64 __tanf64(_Float64 __x) noexcept(true);
    extern _Float64 coshf64(_Float64 __x) noexcept(true);
    extern _Float64 __coshf64(_Float64 __x) noexcept(true);
    extern _Float64 sinhf64(_Float64 __x) noexcept(true);
    extern _Float64 __sinhf64(_Float64 __x) noexcept(true);
    extern _Float64 tanhf64(_Float64 __x) noexcept(true);
    extern _Float64 __tanhf64(_Float64 __x) noexcept(true);
    extern void sincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept(true);
    extern void __sincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept(true);
    extern _Float64 acoshf64(_Float64 __x) noexcept(true);
    extern _Float64 __acoshf64(_Float64 __x) noexcept(true);
    extern _Float64 asinhf64(_Float64 __x) noexcept(true);
    extern _Float64 __asinhf64(_Float64 __x) noexcept(true);
    extern _Float64 atanhf64(_Float64 __x) noexcept(true);
    extern _Float64 __atanhf64(_Float64 __x) noexcept(true);
    extern _Float64 expf64(_Float64 __x) noexcept(true);
    extern _Float64 __expf64(_Float64 __x) noexcept(true);
    extern _Float64 frexpf64(_Float64 __x, int *__exponent) noexcept(true);
    extern _Float64 __frexpf64(_Float64 __x, int *__exponent) noexcept(true);
    extern _Float64 ldexpf64(_Float64 __x, int __exponent) noexcept(true);
    extern _Float64 __ldexpf64(_Float64 __x, int __exponent) noexcept(true);
    extern _Float64 logf64(_Float64 __x) noexcept(true);
    extern _Float64 __logf64(_Float64 __x) noexcept(true);
    extern _Float64 log10f64(_Float64 __x) noexcept(true);
    extern _Float64 __log10f64(_Float64 __x) noexcept(true);
    extern _Float64 modff64(_Float64 __x, _Float64 *__iptr) noexcept(true);
    extern _Float64 __modff64(_Float64 __x, _Float64 *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float64 exp10f64(_Float64 __x) noexcept(true);
    extern _Float64 __exp10f64(_Float64 __x) noexcept(true);
    extern _Float64 expm1f64(_Float64 __x) noexcept(true);
    extern _Float64 __expm1f64(_Float64 __x) noexcept(true);
    extern _Float64 log1pf64(_Float64 __x) noexcept(true);
    extern _Float64 __log1pf64(_Float64 __x) noexcept(true);
    extern _Float64 logbf64(_Float64 __x) noexcept(true);
    extern _Float64 __logbf64(_Float64 __x) noexcept(true);
    extern _Float64 exp2f64(_Float64 __x) noexcept(true);
    extern _Float64 __exp2f64(_Float64 __x) noexcept(true);
    extern _Float64 log2f64(_Float64 __x) noexcept(true);
    extern _Float64 __log2f64(_Float64 __x) noexcept(true);
    extern _Float64 powf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __powf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 sqrtf64(_Float64 __x) noexcept(true);
    extern _Float64 __sqrtf64(_Float64 __x) noexcept(true);
    extern _Float64 hypotf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __hypotf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 cbrtf64(_Float64 __x) noexcept(true);
    extern _Float64 __cbrtf64(_Float64 __x) noexcept(true);
    extern _Float64 ceilf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __ceilf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 fabsf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __fabsf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 floorf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __floorf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 copysignf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __copysignf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 nanf64(const char *__tagb) noexcept(true);
    extern _Float64 __nanf64(const char *__tagb) noexcept(true);
    extern _Float64 j0f64(_Float64) noexcept(true);
    extern _Float64 __j0f64(_Float64) noexcept(true);
    extern _Float64 j1f64(_Float64) noexcept(true);
    extern _Float64 __j1f64(_Float64) noexcept(true);
    extern _Float64 jnf64(int, _Float64) noexcept(true);
    extern _Float64 __jnf64(int, _Float64) noexcept(true);
    extern _Float64 y0f64(_Float64) noexcept(true);
    extern _Float64 __y0f64(_Float64) noexcept(true);
    extern _Float64 y1f64(_Float64) noexcept(true);
    extern _Float64 __y1f64(_Float64) noexcept(true);
    extern _Float64 ynf64(int, _Float64) noexcept(true);
    extern _Float64 __ynf64(int, _Float64) noexcept(true);
    extern _Float64 erff64(_Float64) noexcept(true);
    extern _Float64 __erff64(_Float64) noexcept(true);
    extern _Float64 erfcf64(_Float64) noexcept(true);
    extern _Float64 __erfcf64(_Float64) noexcept(true);
    extern _Float64 lgammaf64(_Float64) noexcept(true);
    extern _Float64 __lgammaf64(_Float64) noexcept(true);
    extern _Float64 tgammaf64(_Float64) noexcept(true);
    extern _Float64 __tgammaf64(_Float64) noexcept(true);
    extern _Float64 lgammaf64_r(_Float64, int *__signgamp) noexcept(true);
    extern _Float64 __lgammaf64_r(_Float64, int *__signgamp) noexcept(true);
    extern _Float64 rintf64(_Float64 __x) noexcept(true);
    extern _Float64 __rintf64(_Float64 __x) noexcept(true);
    extern _Float64 nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 nextdownf64(_Float64 __x) noexcept(true);
    extern _Float64 __nextdownf64(_Float64 __x) noexcept(true);
    extern _Float64 nextupf64(_Float64 __x) noexcept(true);
    extern _Float64 __nextupf64(_Float64 __x) noexcept(true);
    extern _Float64 remainderf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __remainderf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 scalbnf64(_Float64 __x, int __n) noexcept(true);
    extern _Float64 __scalbnf64(_Float64 __x, int __n) noexcept(true);
    extern int ilogbf64(_Float64 __x) noexcept(true);
    extern int __ilogbf64(_Float64 __x) noexcept(true);
    extern long llogbf64(_Float64 __x) noexcept(true);
    extern long __llogbf64(_Float64 __x) noexcept(true);
    extern _Float64 scalblnf64(_Float64 __x, long __n) noexcept(true);
    extern _Float64 __scalblnf64(_Float64 __x, long __n) noexcept(true);
    extern _Float64 nearbyintf64(_Float64 __x) noexcept(true);
    extern _Float64 __nearbyintf64(_Float64 __x) noexcept(true);
    extern _Float64 roundf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __roundf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 truncf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __truncf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 remquof64(_Float64 __x, _Float64 __y, int *__quo) noexcept(true);
    extern _Float64 __remquof64(_Float64 __x, _Float64 __y, int *__quo) noexcept(true);
    extern long lrintf64(_Float64 __x) noexcept(true);
    extern long __lrintf64(_Float64 __x) noexcept(true);
    extern long long llrintf64(_Float64 __x) noexcept(true);
    extern long long __llrintf64(_Float64 __x) noexcept(true);
    extern long lroundf64(_Float64 __x) noexcept(true);
    extern long __lroundf64(_Float64 __x) noexcept(true);
    extern long long llroundf64(_Float64 __x) noexcept(true);
    extern long long __llroundf64(_Float64 __x) noexcept(true);
    extern _Float64 fdimf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __fdimf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 fmaxf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaxf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float64 __fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float64 roundevenf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __roundevenf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef64(_Float64 *__cx, const _Float64 *__x) noexcept(true);
    extern _Float64 fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern int totalorderf64(const _Float64 *__x, const _Float64 *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf64(const _Float64 *__x, const _Float64 *__y) noexcept(true) __attribute__((pure));
    extern _Float64 getpayloadf64(const _Float64 *__x) noexcept(true);
    extern _Float64 __getpayloadf64(const _Float64 *__x) noexcept(true);
    extern int setpayloadf64(_Float64 *__x, _Float64 __payload) noexcept(true);
    extern int setpayloadsigf64(_Float64 *__x, _Float64 __payload) noexcept(true);
    extern _Float32x acosf32x(_Float32x __x) noexcept(true);
    extern _Float32x __acosf32x(_Float32x __x) noexcept(true);
    extern _Float32x asinf32x(_Float32x __x) noexcept(true);
    extern _Float32x __asinf32x(_Float32x __x) noexcept(true);
    extern _Float32x atanf32x(_Float32x __x) noexcept(true);
    extern _Float32x __atanf32x(_Float32x __x) noexcept(true);
    extern _Float32x atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
    extern _Float32x __atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
    extern _Float32x cosf32x(_Float32x __x) noexcept(true);
    extern _Float32x __cosf32x(_Float32x __x) noexcept(true);
    extern _Float32x sinf32x(_Float32x __x) noexcept(true);
    extern _Float32x __sinf32x(_Float32x __x) noexcept(true);
    extern _Float32x tanf32x(_Float32x __x) noexcept(true);
    extern _Float32x __tanf32x(_Float32x __x) noexcept(true);
    extern _Float32x coshf32x(_Float32x __x) noexcept(true);
    extern _Float32x __coshf32x(_Float32x __x) noexcept(true);
    extern _Float32x sinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __sinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x tanhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __tanhf32x(_Float32x __x) noexcept(true);
    extern void sincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept(true);
    extern void __sincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept(true);
    extern _Float32x acoshf32x(_Float32x __x) noexcept(true);
    extern _Float32x __acoshf32x(_Float32x __x) noexcept(true);
    extern _Float32x asinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __asinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x atanhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __atanhf32x(_Float32x __x) noexcept(true);
    extern _Float32x expf32x(_Float32x __x) noexcept(true);
    extern _Float32x __expf32x(_Float32x __x) noexcept(true);
    extern _Float32x frexpf32x(_Float32x __x, int *__exponent) noexcept(true);
    extern _Float32x __frexpf32x(_Float32x __x, int *__exponent) noexcept(true);
    extern _Float32x ldexpf32x(_Float32x __x, int __exponent) noexcept(true);
    extern _Float32x __ldexpf32x(_Float32x __x, int __exponent) noexcept(true);
    extern _Float32x logf32x(_Float32x __x) noexcept(true);
    extern _Float32x __logf32x(_Float32x __x) noexcept(true);
    extern _Float32x log10f32x(_Float32x __x) noexcept(true);
    extern _Float32x __log10f32x(_Float32x __x) noexcept(true);
    extern _Float32x modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true);
    extern _Float32x __modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float32x exp10f32x(_Float32x __x) noexcept(true);
    extern _Float32x __exp10f32x(_Float32x __x) noexcept(true);
    extern _Float32x expm1f32x(_Float32x __x) noexcept(true);
    extern _Float32x __expm1f32x(_Float32x __x) noexcept(true);
    extern _Float32x log1pf32x(_Float32x __x) noexcept(true);
    extern _Float32x __log1pf32x(_Float32x __x) noexcept(true);
    extern _Float32x logbf32x(_Float32x __x) noexcept(true);
    extern _Float32x __logbf32x(_Float32x __x) noexcept(true);
    extern _Float32x exp2f32x(_Float32x __x) noexcept(true);
    extern _Float32x __exp2f32x(_Float32x __x) noexcept(true);
    extern _Float32x log2f32x(_Float32x __x) noexcept(true);
    extern _Float32x __log2f32x(_Float32x __x) noexcept(true);
    extern _Float32x powf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __powf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x sqrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x __sqrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x cbrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x __cbrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x ceilf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __ceilf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x fabsf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __fabsf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x floorf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __floorf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x copysignf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __copysignf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x nanf32x(const char *__tagb) noexcept(true);
    extern _Float32x __nanf32x(const char *__tagb) noexcept(true);
    extern _Float32x j0f32x(_Float32x) noexcept(true);
    extern _Float32x __j0f32x(_Float32x) noexcept(true);
    extern _Float32x j1f32x(_Float32x) noexcept(true);
    extern _Float32x __j1f32x(_Float32x) noexcept(true);
    extern _Float32x jnf32x(int, _Float32x) noexcept(true);
    extern _Float32x __jnf32x(int, _Float32x) noexcept(true);
    extern _Float32x y0f32x(_Float32x) noexcept(true);
    extern _Float32x __y0f32x(_Float32x) noexcept(true);
    extern _Float32x y1f32x(_Float32x) noexcept(true);
    extern _Float32x __y1f32x(_Float32x) noexcept(true);
    extern _Float32x ynf32x(int, _Float32x) noexcept(true);
    extern _Float32x __ynf32x(int, _Float32x) noexcept(true);
    extern _Float32x erff32x(_Float32x) noexcept(true);
    extern _Float32x __erff32x(_Float32x) noexcept(true);
    extern _Float32x erfcf32x(_Float32x) noexcept(true);
    extern _Float32x __erfcf32x(_Float32x) noexcept(true);
    extern _Float32x lgammaf32x(_Float32x) noexcept(true);
    extern _Float32x __lgammaf32x(_Float32x) noexcept(true);
    extern _Float32x tgammaf32x(_Float32x) noexcept(true);
    extern _Float32x __tgammaf32x(_Float32x) noexcept(true);
    extern _Float32x lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
    extern _Float32x __lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
    extern _Float32x rintf32x(_Float32x __x) noexcept(true);
    extern _Float32x __rintf32x(_Float32x __x) noexcept(true);
    extern _Float32x nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x nextdownf32x(_Float32x __x) noexcept(true);
    extern _Float32x __nextdownf32x(_Float32x __x) noexcept(true);
    extern _Float32x nextupf32x(_Float32x __x) noexcept(true);
    extern _Float32x __nextupf32x(_Float32x __x) noexcept(true);
    extern _Float32x remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x scalbnf32x(_Float32x __x, int __n) noexcept(true);
    extern _Float32x __scalbnf32x(_Float32x __x, int __n) noexcept(true);
    extern int ilogbf32x(_Float32x __x) noexcept(true);
    extern int __ilogbf32x(_Float32x __x) noexcept(true);
    extern long llogbf32x(_Float32x __x) noexcept(true);
    extern long __llogbf32x(_Float32x __x) noexcept(true);
    extern _Float32x scalblnf32x(_Float32x __x, long __n) noexcept(true);
    extern _Float32x __scalblnf32x(_Float32x __x, long __n) noexcept(true);
    extern _Float32x nearbyintf32x(_Float32x __x) noexcept(true);
    extern _Float32x __nearbyintf32x(_Float32x __x) noexcept(true);
    extern _Float32x roundf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __roundf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x truncf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __truncf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x remquof32x(_Float32x __x, _Float32x __y, int *__quo) noexcept(true);
    extern _Float32x __remquof32x(_Float32x __x, _Float32x __y, int *__quo) noexcept(true);
    extern long lrintf32x(_Float32x __x) noexcept(true);
    extern long __lrintf32x(_Float32x __x) noexcept(true);
    extern long long llrintf32x(_Float32x __x) noexcept(true);
    extern long long __llrintf32x(_Float32x __x) noexcept(true);
    extern long lroundf32x(_Float32x __x) noexcept(true);
    extern long __lroundf32x(_Float32x __x) noexcept(true);
    extern long long llroundf32x(_Float32x __x) noexcept(true);
    extern long long __llroundf32x(_Float32x __x) noexcept(true);
    extern _Float32x fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(true);
    extern _Float32x __fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(true);
    extern _Float32x roundevenf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __roundevenf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef32x(_Float32x *__cx, const _Float32x *__x) noexcept(true);
    extern _Float32x fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern int totalorderf32x(const _Float32x *__x, const _Float32x *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf32x(const _Float32x *__x, const _Float32x *__y) noexcept(true) __attribute__((pure));
    extern _Float32x getpayloadf32x(const _Float32x *__x) noexcept(true);
    extern _Float32x __getpayloadf32x(const _Float32x *__x) noexcept(true);
    extern int setpayloadf32x(_Float32x *__x, _Float32x __payload) noexcept(true);
    extern int setpayloadsigf32x(_Float32x *__x, _Float32x __payload) noexcept(true);
    extern _Float64x acosf64x(_Float64x __x) noexcept(true);
    extern _Float64x __acosf64x(_Float64x __x) noexcept(true);
    extern _Float64x asinf64x(_Float64x __x) noexcept(true);
    extern _Float64x __asinf64x(_Float64x __x) noexcept(true);
    extern _Float64x atanf64x(_Float64x __x) noexcept(true);
    extern _Float64x __atanf64x(_Float64x __x) noexcept(true);
    extern _Float64x atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
    extern _Float64x __atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
    extern _Float64x cosf64x(_Float64x __x) noexcept(true);
    extern _Float64x __cosf64x(_Float64x __x) noexcept(true);
    extern _Float64x sinf64x(_Float64x __x) noexcept(true);
    extern _Float64x __sinf64x(_Float64x __x) noexcept(true);
    extern _Float64x tanf64x(_Float64x __x) noexcept(true);
    extern _Float64x __tanf64x(_Float64x __x) noexcept(true);
    extern _Float64x coshf64x(_Float64x __x) noexcept(true);
    extern _Float64x __coshf64x(_Float64x __x) noexcept(true);
    extern _Float64x sinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __sinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x tanhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __tanhf64x(_Float64x __x) noexcept(true);
    extern void sincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept(true);
    extern void __sincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept(true);
    extern _Float64x acoshf64x(_Float64x __x) noexcept(true);
    extern _Float64x __acoshf64x(_Float64x __x) noexcept(true);
    extern _Float64x asinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __asinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x atanhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __atanhf64x(_Float64x __x) noexcept(true);
    extern _Float64x expf64x(_Float64x __x) noexcept(true);
    extern _Float64x __expf64x(_Float64x __x) noexcept(true);
    extern _Float64x frexpf64x(_Float64x __x, int *__exponent) noexcept(true);
    extern _Float64x __frexpf64x(_Float64x __x, int *__exponent) noexcept(true);
    extern _Float64x ldexpf64x(_Float64x __x, int __exponent) noexcept(true);
    extern _Float64x __ldexpf64x(_Float64x __x, int __exponent) noexcept(true);
    extern _Float64x logf64x(_Float64x __x) noexcept(true);
    extern _Float64x __logf64x(_Float64x __x) noexcept(true);
    extern _Float64x log10f64x(_Float64x __x) noexcept(true);
    extern _Float64x __log10f64x(_Float64x __x) noexcept(true);
    extern _Float64x modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true);
    extern _Float64x __modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float64x exp10f64x(_Float64x __x) noexcept(true);
    extern _Float64x __exp10f64x(_Float64x __x) noexcept(true);
    extern _Float64x expm1f64x(_Float64x __x) noexcept(true);
    extern _Float64x __expm1f64x(_Float64x __x) noexcept(true);
    extern _Float64x log1pf64x(_Float64x __x) noexcept(true);
    extern _Float64x __log1pf64x(_Float64x __x) noexcept(true);
    extern _Float64x logbf64x(_Float64x __x) noexcept(true);
    extern _Float64x __logbf64x(_Float64x __x) noexcept(true);
    extern _Float64x exp2f64x(_Float64x __x) noexcept(true);
    extern _Float64x __exp2f64x(_Float64x __x) noexcept(true);
    extern _Float64x log2f64x(_Float64x __x) noexcept(true);
    extern _Float64x __log2f64x(_Float64x __x) noexcept(true);
    extern _Float64x powf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __powf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x sqrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x __sqrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x cbrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x __cbrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x ceilf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __ceilf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x fabsf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __fabsf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x floorf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __floorf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x copysignf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __copysignf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x nanf64x(const char *__tagb) noexcept(true);
    extern _Float64x __nanf64x(const char *__tagb) noexcept(true);
    extern _Float64x j0f64x(_Float64x) noexcept(true);
    extern _Float64x __j0f64x(_Float64x) noexcept(true);
    extern _Float64x j1f64x(_Float64x) noexcept(true);
    extern _Float64x __j1f64x(_Float64x) noexcept(true);
    extern _Float64x jnf64x(int, _Float64x) noexcept(true);
    extern _Float64x __jnf64x(int, _Float64x) noexcept(true);
    extern _Float64x y0f64x(_Float64x) noexcept(true);
    extern _Float64x __y0f64x(_Float64x) noexcept(true);
    extern _Float64x y1f64x(_Float64x) noexcept(true);
    extern _Float64x __y1f64x(_Float64x) noexcept(true);
    extern _Float64x ynf64x(int, _Float64x) noexcept(true);
    extern _Float64x __ynf64x(int, _Float64x) noexcept(true);
    extern _Float64x erff64x(_Float64x) noexcept(true);
    extern _Float64x __erff64x(_Float64x) noexcept(true);
    extern _Float64x erfcf64x(_Float64x) noexcept(true);
    extern _Float64x __erfcf64x(_Float64x) noexcept(true);
    extern _Float64x lgammaf64x(_Float64x) noexcept(true);
    extern _Float64x __lgammaf64x(_Float64x) noexcept(true);
    extern _Float64x tgammaf64x(_Float64x) noexcept(true);
    extern _Float64x __tgammaf64x(_Float64x) noexcept(true);
    extern _Float64x lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
    extern _Float64x __lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
    extern _Float64x rintf64x(_Float64x __x) noexcept(true);
    extern _Float64x __rintf64x(_Float64x __x) noexcept(true);
    extern _Float64x nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x nextdownf64x(_Float64x __x) noexcept(true);
    extern _Float64x __nextdownf64x(_Float64x __x) noexcept(true);
    extern _Float64x nextupf64x(_Float64x __x) noexcept(true);
    extern _Float64x __nextupf64x(_Float64x __x) noexcept(true);
    extern _Float64x remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x scalbnf64x(_Float64x __x, int __n) noexcept(true);
    extern _Float64x __scalbnf64x(_Float64x __x, int __n) noexcept(true);
    extern int ilogbf64x(_Float64x __x) noexcept(true);
    extern int __ilogbf64x(_Float64x __x) noexcept(true);
    extern long llogbf64x(_Float64x __x) noexcept(true);
    extern long __llogbf64x(_Float64x __x) noexcept(true);
    extern _Float64x scalblnf64x(_Float64x __x, long __n) noexcept(true);
    extern _Float64x __scalblnf64x(_Float64x __x, long __n) noexcept(true);
    extern _Float64x nearbyintf64x(_Float64x __x) noexcept(true);
    extern _Float64x __nearbyintf64x(_Float64x __x) noexcept(true);
    extern _Float64x roundf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __roundf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x truncf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __truncf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x remquof64x(_Float64x __x, _Float64x __y, int *__quo) noexcept(true);
    extern _Float64x __remquof64x(_Float64x __x, _Float64x __y, int *__quo) noexcept(true);
    extern long lrintf64x(_Float64x __x) noexcept(true);
    extern long __lrintf64x(_Float64x __x) noexcept(true);
    extern long long llrintf64x(_Float64x __x) noexcept(true);
    extern long long __llrintf64x(_Float64x __x) noexcept(true);
    extern long lroundf64x(_Float64x __x) noexcept(true);
    extern long __lroundf64x(_Float64x __x) noexcept(true);
    extern long long llroundf64x(_Float64x __x) noexcept(true);
    extern long long __llroundf64x(_Float64x __x) noexcept(true);
    extern _Float64x fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float64x __fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float64x roundevenf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __roundevenf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef64x(_Float64x *__cx, const _Float64x *__x) noexcept(true);
    extern _Float64x fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern int totalorderf64x(const _Float64x *__x, const _Float64x *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf64x(const _Float64x *__x, const _Float64x *__y) noexcept(true) __attribute__((pure));
    extern _Float64x getpayloadf64x(const _Float64x *__x) noexcept(true);
    extern _Float64x __getpayloadf64x(const _Float64x *__x) noexcept(true);
    extern int setpayloadf64x(_Float64x *__x, _Float64x __payload) noexcept(true);
    extern int setpayloadsigf64x(_Float64x *__x, _Float64x __payload) noexcept(true);
    extern float fadd(double __x, double __y) noexcept(true);
    extern float fdiv(double __x, double __y) noexcept(true);
    extern float ffma(double __x, double __y, double __z) noexcept(true);
    extern float fmul(double __x, double __y) noexcept(true);
    extern float fsqrt(double __x) noexcept(true);
    extern float fsub(double __x, double __y) noexcept(true);
    extern float faddl(long double __x, long double __y) noexcept(true);
    extern float fdivl(long double __x, long double __y) noexcept(true);
    extern float ffmal(long double __x, long double __y, long double __z) noexcept(true);
    extern float fmull(long double __x, long double __y) noexcept(true);
    extern float fsqrtl(long double __x) noexcept(true);
    extern float fsubl(long double __x, long double __y) noexcept(true);
    extern double daddl(long double __x, long double __y) noexcept(true);
    extern double ddivl(long double __x, long double __y) noexcept(true);
    extern double dfmal(long double __x, long double __y, long double __z) noexcept(true);
    extern double dmull(long double __x, long double __y) noexcept(true);
    extern double dsqrtl(long double __x) noexcept(true);
    extern double dsubl(long double __x, long double __y) noexcept(true);
    extern _Float32 f32addf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32divf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(true);
    extern _Float32 f32mulf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32sqrtf32x(_Float32x __x) noexcept(true);
    extern _Float32 f32subf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32addf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32divf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float32 f32mulf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32sqrtf64(_Float64 __x) noexcept(true);
    extern _Float32 f32subf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32addf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32 f32divf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32 f32fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float32 f32mulf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32 f32sqrtf64x(_Float64x __x) noexcept(true);
    extern _Float32 f32subf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xaddf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xdivf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xfmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float32x f32xmulf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xsqrtf64(_Float64 __x) noexcept(true);
    extern _Float32x f32xsubf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xaddf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xdivf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xfmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float32x f32xmulf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xsqrtf64x(_Float64x __x) noexcept(true);
    extern _Float32x f32xsubf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64addf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64divf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float64 f64mulf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64sqrtf64x(_Float64x __x) noexcept(true);
    extern _Float64 f64subf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern int signgam;
    enum {
        FP_NAN = 0,
        FP_INFINITE = 1,
        FP_ZERO = 2,
        FP_SUBNORMAL = 3,
        FP_NORMAL = 4
    };
    extern int __iscanonicall(long double __x) noexcept(true) __attribute__((const));
    extern "C++" {
        inline int iscanonical(float __val) {
            return ((void)(typeof (__val))(__val) , 1);
        }
        inline int iscanonical(double __val) {
            return ((void)(typeof (__val))(__val) , 1);
        }
        inline int iscanonical(long double __val) {
            return __iscanonicall(__val);
        }
    }
    extern "C++" {
        inline int issignaling(float __val) {
            return __issignalingf(__val);
        }
        inline int issignaling(double __val) {
            return __issignaling(__val);
        }
        inline int issignaling(long double __val) {
            return __issignalingl(__val);
        }
    }
    extern "C++" {
        template <class __T> inline bool iszero(__T __val) {
            return __val == 0;
        }
    }
    extern "C++" {
        template <typename> struct __iseqsig_type;
        template<> struct __iseqsig_type<float> {
            static int __call(float __x, float __y) throw() {
                return __iseqsigf(__x, __y);
            }
        };
        template<> struct __iseqsig_type<double> {
            static int __call(double __x, double __y) throw() {
                return __iseqsig(__x, __y);
            }
        };
        template<> struct __iseqsig_type<long double> {
            static int __call(long double __x, long double __y) throw() {
                return __iseqsigl(__x, __y);
            }
        };
        template <typename _T1, typename _T2> inline int iseqsig(_T1 __x, _T2 __y) throw() {
            typedef decltype(((__x) + (__y) + 0.F)) _T3;
            return __iseqsig_type<_T3>::__call(__x, __y);
        }
    }
}
extern "C++" {
    namespace std {
        using ::acos;
        inline constexpr float acos(float __x) {
            return __builtin_acosf(__x);
        }
        inline constexpr long double acos(long double __x) {
            return __builtin_acosl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x) {
            return __builtin_acos(__x);
        }
        using ::asin;
        inline constexpr float asin(float __x) {
            return __builtin_asinf(__x);
        }
        inline constexpr long double asin(long double __x) {
            return __builtin_asinl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x) {
            return __builtin_asin(__x);
        }
        using ::atan;
        inline constexpr float atan(float __x) {
            return __builtin_atanf(__x);
        }
        inline constexpr long double atan(long double __x) {
            return __builtin_atanl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x) {
            return __builtin_atan(__x);
        }
        using ::atan2;
        inline constexpr float atan2(float __y, float __x) {
            return __builtin_atan2f(__y, __x);
        }
        inline constexpr long double atan2(long double __y, long double __x) {
            return __builtin_atan2l(__y, __x);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return atan2(__type(__y), __type(__x));
        }
        using ::ceil;
        inline constexpr float ceil(float __x) {
            return __builtin_ceilf(__x);
        }
        inline constexpr long double ceil(long double __x) {
            return __builtin_ceill(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x) {
            return __builtin_ceil(__x);
        }
        using ::cos;
        inline constexpr float cos(float __x) {
            return __builtin_cosf(__x);
        }
        inline constexpr long double cos(long double __x) {
            return __builtin_cosl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x) {
            return __builtin_cos(__x);
        }
        using ::cosh;
        inline constexpr float cosh(float __x) {
            return __builtin_coshf(__x);
        }
        inline constexpr long double cosh(long double __x) {
            return __builtin_coshl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x) {
            return __builtin_cosh(__x);
        }
        using ::exp;
        inline constexpr float exp(float __x) {
            return __builtin_expf(__x);
        }
        inline constexpr long double exp(long double __x) {
            return __builtin_expl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x) {
            return __builtin_exp(__x);
        }
        using ::fabs;
        inline constexpr float fabs(float __x) {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double fabs(long double __x) {
            return __builtin_fabsl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x) {
            return __builtin_fabs(__x);
        }
        using ::floor;
        inline constexpr float floor(float __x) {
            return __builtin_floorf(__x);
        }
        inline constexpr long double floor(long double __x) {
            return __builtin_floorl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x) {
            return __builtin_floor(__x);
        }
        using ::fmod;
        inline constexpr float fmod(float __x, float __y) {
            return __builtin_fmodf(__x, __y);
        }
        inline constexpr long double fmod(long double __x, long double __y) {
            return __builtin_fmodl(__x, __y);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmod(__type(__x), __type(__y));
        }
        using ::frexp;
        inline float frexp(float __x, int *__exp) {
            return __builtin_frexpf(__x, __exp);
        }
        inline long double frexp(long double __x, int *__exp) {
            return __builtin_frexpl(__x, __exp);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp) {
            return __builtin_frexp(__x, __exp);
        }
        using ::ldexp;
        inline constexpr float ldexp(float __x, int __exp) {
            return __builtin_ldexpf(__x, __exp);
        }
        inline constexpr long double ldexp(long double __x, int __exp) {
            return __builtin_ldexpl(__x, __exp);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp) {
            return __builtin_ldexp(__x, __exp);
        }
        using ::log;
        inline constexpr float log(float __x) {
            return __builtin_logf(__x);
        }
        inline constexpr long double log(long double __x) {
            return __builtin_logl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x) {
            return __builtin_log(__x);
        }
        using ::log10;
        inline constexpr float log10(float __x) {
            return __builtin_log10f(__x);
        }
        inline constexpr long double log10(long double __x) {
            return __builtin_log10l(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x) {
            return __builtin_log10(__x);
        }
        using ::modf;
        inline float modf(float __x, float *__iptr) {
            return __builtin_modff(__x, __iptr);
        }
        inline long double modf(long double __x, long double *__iptr) {
            return __builtin_modfl(__x, __iptr);
        }
        using ::pow;
        inline constexpr float pow(float __x, float __y) {
            return __builtin_powf(__x, __y);
        }
        inline constexpr long double pow(long double __x, long double __y) {
            return __builtin_powl(__x, __y);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return pow(__type(__x), __type(__y));
        }
        using ::sin;
        inline constexpr float sin(float __x) {
            return __builtin_sinf(__x);
        }
        inline constexpr long double sin(long double __x) {
            return __builtin_sinl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x) {
            return __builtin_sin(__x);
        }
        using ::sinh;
        inline constexpr float sinh(float __x) {
            return __builtin_sinhf(__x);
        }
        inline constexpr long double sinh(long double __x) {
            return __builtin_sinhl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x) {
            return __builtin_sinh(__x);
        }
        using ::sqrt;
        inline constexpr float sqrt(float __x) {
            return __builtin_sqrtf(__x);
        }
        inline constexpr long double sqrt(long double __x) {
            return __builtin_sqrtl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x) {
            return __builtin_sqrt(__x);
        }
        using ::tan;
        inline constexpr float tan(float __x) {
            return __builtin_tanf(__x);
        }
        inline constexpr long double tan(long double __x) {
            return __builtin_tanl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x) {
            return __builtin_tan(__x);
        }
        using ::tanh;
        inline constexpr float tanh(float __x) {
            return __builtin_tanhf(__x);
        }
        inline constexpr long double tanh(long double __x) {
            return __builtin_tanhl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x) {
            return __builtin_tanh(__x);
        }
        constexpr int fpclassify(float __x) {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        constexpr int fpclassify(double __x) {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        constexpr int fpclassify(long double __x) {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type fpclassify(_Tp __x) {
            return __x != 0 ? 4 : 2;
        }
        constexpr bool isfinite(float __x) {
            return __builtin_isfinite(__x);
        }
        constexpr bool isfinite(double __x) {
            return __builtin_isfinite(__x);
        }
        constexpr bool isfinite(long double __x) {
            return __builtin_isfinite(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isfinite(_Tp __x) {
            return true;
        }
        constexpr bool isinf(float __x) {
            return __builtin_isinf(__x);
        }
        constexpr bool isinf(double __x) {
            return __builtin_isinf(__x);
        }
        constexpr bool isinf(long double __x) {
            return __builtin_isinf(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isinf(_Tp __x) {
            return false;
        }
        constexpr bool isnan(float __x) {
            return __builtin_isnan(__x);
        }
        constexpr bool isnan(double __x) {
            return __builtin_isnan(__x);
        }
        constexpr bool isnan(long double __x) {
            return __builtin_isnan(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnan(_Tp __x) {
            return false;
        }
        constexpr bool isnormal(float __x) {
            return __builtin_isnormal(__x);
        }
        constexpr bool isnormal(double __x) {
            return __builtin_isnormal(__x);
        }
        constexpr bool isnormal(long double __x) {
            return __builtin_isnormal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnormal(_Tp __x) {
            return __x != 0 ? true : false;
        }
        constexpr bool signbit(float __x) {
            return __builtin_signbit(__x);
        }
        constexpr bool signbit(double __x) {
            return __builtin_signbit(__x);
        }
        constexpr bool signbit(long double __x) {
            return __builtin_signbit(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type signbit(_Tp __x) {
            return __x < 0 ? true : false;
        }
        constexpr bool isgreater(float __x, float __y) {
            return __builtin_isgreater(__x, __y);
        }
        constexpr bool isgreater(double __x, double __y) {
            return __builtin_isgreater(__x, __y);
        }
        constexpr bool isgreater(long double __x, long double __y) {
            return __builtin_isgreater(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isgreater(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isgreater(__type(__x), __type(__y));
        }
        constexpr bool isgreaterequal(float __x, float __y) {
            return __builtin_isgreaterequal(__x, __y);
        }
        constexpr bool isgreaterequal(double __x, double __y) {
            return __builtin_isgreaterequal(__x, __y);
        }
        constexpr bool isgreaterequal(long double __x, long double __y) {
            return __builtin_isgreaterequal(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isgreaterequal(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isgreaterequal(__type(__x), __type(__y));
        }
        constexpr bool isless(float __x, float __y) {
            return __builtin_isless(__x, __y);
        }
        constexpr bool isless(double __x, double __y) {
            return __builtin_isless(__x, __y);
        }
        constexpr bool isless(long double __x, long double __y) {
            return __builtin_isless(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isless(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isless(__type(__x), __type(__y));
        }
        constexpr bool islessequal(float __x, float __y) {
            return __builtin_islessequal(__x, __y);
        }
        constexpr bool islessequal(double __x, double __y) {
            return __builtin_islessequal(__x, __y);
        }
        constexpr bool islessequal(long double __x, long double __y) {
            return __builtin_islessequal(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type islessequal(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_islessequal(__type(__x), __type(__y));
        }
        constexpr bool islessgreater(float __x, float __y) {
            return __builtin_islessgreater(__x, __y);
        }
        constexpr bool islessgreater(double __x, double __y) {
            return __builtin_islessgreater(__x, __y);
        }
        constexpr bool islessgreater(long double __x, long double __y) {
            return __builtin_islessgreater(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type islessgreater(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_islessgreater(__type(__x), __type(__y));
        }
        constexpr bool isunordered(float __x, float __y) {
            return __builtin_isunordered(__x, __y);
        }
        constexpr bool isunordered(double __x, double __y) {
            return __builtin_isunordered(__x, __y);
        }
        constexpr bool isunordered(long double __x, long double __y) {
            return __builtin_isunordered(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isunordered(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isunordered(__type(__x), __type(__y));
        }
        using ::double_t;
        using ::float_t;
        using ::acosh;
        using ::acoshf;
        using ::acoshl;
        using ::asinh;
        using ::asinhf;
        using ::asinhl;
        using ::atanh;
        using ::atanhf;
        using ::atanhl;
        using ::cbrt;
        using ::cbrtf;
        using ::cbrtl;
        using ::copysign;
        using ::copysignf;
        using ::copysignl;
        using ::erf;
        using ::erff;
        using ::erfl;
        using ::erfc;
        using ::erfcf;
        using ::erfcl;
        using ::exp2;
        using ::exp2f;
        using ::exp2l;
        using ::expm1;
        using ::expm1f;
        using ::expm1l;
        using ::fdim;
        using ::fdimf;
        using ::fdiml;
        using ::fma;
        using ::fmaf;
        using ::fmal;
        using ::fmax;
        using ::fmaxf;
        using ::fmaxl;
        using ::fmin;
        using ::fminf;
        using ::fminl;
        using ::hypot;
        using ::hypotf;
        using ::hypotl;
        using ::ilogb;
        using ::ilogbf;
        using ::ilogbl;
        using ::lgamma;
        using ::lgammaf;
        using ::lgammal;
        using ::llrint;
        using ::llrintf;
        using ::llrintl;
        using ::llround;
        using ::llroundf;
        using ::llroundl;
        using ::log1p;
        using ::log1pf;
        using ::log1pl;
        using ::log2;
        using ::log2f;
        using ::log2l;
        using ::logb;
        using ::logbf;
        using ::logbl;
        using ::lrint;
        using ::lrintf;
        using ::lrintl;
        using ::lround;
        using ::lroundf;
        using ::lroundl;
        using ::nan;
        using ::nanf;
        using ::nanl;
        using ::nearbyint;
        using ::nearbyintf;
        using ::nearbyintl;
        using ::nextafter;
        using ::nextafterf;
        using ::nextafterl;
        using ::nexttoward;
        using ::nexttowardf;
        using ::nexttowardl;
        using ::remainder;
        using ::remainderf;
        using ::remainderl;
        using ::remquo;
        using ::remquof;
        using ::remquol;
        using ::rint;
        using ::rintf;
        using ::rintl;
        using ::round;
        using ::roundf;
        using ::roundl;
        using ::scalbln;
        using ::scalblnf;
        using ::scalblnl;
        using ::scalbn;
        using ::scalbnf;
        using ::scalbnl;
        using ::tgamma;
        using ::tgammaf;
        using ::tgammal;
        using ::trunc;
        using ::truncf;
        using ::truncl;
        constexpr float acosh(float __x) {
            return __builtin_acoshf(__x);
        }
        constexpr long double acosh(long double __x) {
            return __builtin_acoshl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acosh(_Tp __x) {
            return __builtin_acosh(__x);
        }
        constexpr float asinh(float __x) {
            return __builtin_asinhf(__x);
        }
        constexpr long double asinh(long double __x) {
            return __builtin_asinhl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asinh(_Tp __x) {
            return __builtin_asinh(__x);
        }
        constexpr float atanh(float __x) {
            return __builtin_atanhf(__x);
        }
        constexpr long double atanh(long double __x) {
            return __builtin_atanhl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atanh(_Tp __x) {
            return __builtin_atanh(__x);
        }
        constexpr float cbrt(float __x) {
            return __builtin_cbrtf(__x);
        }
        constexpr long double cbrt(long double __x) {
            return __builtin_cbrtl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cbrt(_Tp __x) {
            return __builtin_cbrt(__x);
        }
        constexpr float copysign(float __x, float __y) {
            return __builtin_copysignf(__x, __y);
        }
        constexpr long double copysign(long double __x, long double __y) {
            return __builtin_copysignl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return copysign(__type(__x), __type(__y));
        }
        constexpr float erf(float __x) {
            return __builtin_erff(__x);
        }
        constexpr long double erf(long double __x) {
            return __builtin_erfl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erf(_Tp __x) {
            return __builtin_erf(__x);
        }
        constexpr float erfc(float __x) {
            return __builtin_erfcf(__x);
        }
        constexpr long double erfc(long double __x) {
            return __builtin_erfcl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erfc(_Tp __x) {
            return __builtin_erfc(__x);
        }
        constexpr float exp2(float __x) {
            return __builtin_exp2f(__x);
        }
        constexpr long double exp2(long double __x) {
            return __builtin_exp2l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp2(_Tp __x) {
            return __builtin_exp2(__x);
        }
        constexpr float expm1(float __x) {
            return __builtin_expm1f(__x);
        }
        constexpr long double expm1(long double __x) {
            return __builtin_expm1l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type expm1(_Tp __x) {
            return __builtin_expm1(__x);
        }
        constexpr float fdim(float __x, float __y) {
            return __builtin_fdimf(__x, __y);
        }
        constexpr long double fdim(long double __x, long double __y) {
            return __builtin_fdiml(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fdim(__type(__x), __type(__y));
        }
        constexpr float fma(float __x, float __y, float __z) {
            return __builtin_fmaf(__x, __y, __z);
        }
        constexpr long double fma(long double __x, long double __y, long double __z) {
            return __builtin_fmal(__x, __y, __z);
        }
        template <typename _Tp, typename _Up, typename _Vp> constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(_Tp __x, _Up __y, _Vp __z) {
            typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
            return fma(__type(__x), __type(__y), __type(__z));
        }
        constexpr float fmax(float __x, float __y) {
            return __builtin_fmaxf(__x, __y);
        }
        constexpr long double fmax(long double __x, long double __y) {
            return __builtin_fmaxl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmax(__type(__x), __type(__y));
        }
        constexpr float fmin(float __x, float __y) {
            return __builtin_fminf(__x, __y);
        }
        constexpr long double fmin(long double __x, long double __y) {
            return __builtin_fminl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmin(__type(__x), __type(__y));
        }
        constexpr float hypot(float __x, float __y) {
            return __builtin_hypotf(__x, __y);
        }
        constexpr long double hypot(long double __x, long double __y) {
            return __builtin_hypotl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return hypot(__type(__x), __type(__y));
        }
        constexpr int ilogb(float __x) {
            return __builtin_ilogbf(__x);
        }
        constexpr int ilogb(long double __x) {
            return __builtin_ilogbl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type ilogb(_Tp __x) {
            return __builtin_ilogb(__x);
        }
        constexpr float lgamma(float __x) {
            return __builtin_lgammaf(__x);
        }
        constexpr long double lgamma(long double __x) {
            return __builtin_lgammal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type lgamma(_Tp __x) {
            return __builtin_lgamma(__x);
        }
        constexpr long long llrint(float __x) {
            return __builtin_llrintf(__x);
        }
        constexpr long long llrint(long double __x) {
            return __builtin_llrintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long>::__type llrint(_Tp __x) {
            return __builtin_llrint(__x);
        }
        constexpr long long llround(float __x) {
            return __builtin_llroundf(__x);
        }
        constexpr long long llround(long double __x) {
            return __builtin_llroundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long>::__type llround(_Tp __x) {
            return __builtin_llround(__x);
        }
        constexpr float log1p(float __x) {
            return __builtin_log1pf(__x);
        }
        constexpr long double log1p(long double __x) {
            return __builtin_log1pl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log1p(_Tp __x) {
            return __builtin_log1p(__x);
        }
        constexpr float log2(float __x) {
            return __builtin_log2f(__x);
        }
        constexpr long double log2(long double __x) {
            return __builtin_log2l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log2(_Tp __x) {
            return __builtin_log2(__x);
        }
        constexpr float logb(float __x) {
            return __builtin_logbf(__x);
        }
        constexpr long double logb(long double __x) {
            return __builtin_logbl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type logb(_Tp __x) {
            return __builtin_logb(__x);
        }
        constexpr long lrint(float __x) {
            return __builtin_lrintf(__x);
        }
        constexpr long lrint(long double __x) {
            return __builtin_lrintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type lrint(_Tp __x) {
            return __builtin_lrint(__x);
        }
        constexpr long lround(float __x) {
            return __builtin_lroundf(__x);
        }
        constexpr long lround(long double __x) {
            return __builtin_lroundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type lround(_Tp __x) {
            return __builtin_lround(__x);
        }
        constexpr float nearbyint(float __x) {
            return __builtin_nearbyintf(__x);
        }
        constexpr long double nearbyint(long double __x) {
            return __builtin_nearbyintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nearbyint(_Tp __x) {
            return __builtin_nearbyint(__x);
        }
        constexpr float nextafter(float __x, float __y) {
            return __builtin_nextafterf(__x, __y);
        }
        constexpr long double nextafter(long double __x, long double __y) {
            return __builtin_nextafterl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return nextafter(__type(__x), __type(__y));
        }
        constexpr float nexttoward(float __x, long double __y) {
            return __builtin_nexttowardf(__x, __y);
        }
        constexpr long double nexttoward(long double __x, long double __y) {
            return __builtin_nexttowardl(__x, __y);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nexttoward(_Tp __x, long double __y) {
            return __builtin_nexttoward(__x, __y);
        }
        constexpr float remainder(float __x, float __y) {
            return __builtin_remainderf(__x, __y);
        }
        constexpr long double remainder(long double __x, long double __y) {
            return __builtin_remainderl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(_Tp __x, _Up __y) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return remainder(__type(__x), __type(__y));
        }
        inline float remquo(float __x, float __y, int *__pquo) {
            return __builtin_remquof(__x, __y, __pquo);
        }
        inline long double remquo(long double __x, long double __y, int *__pquo) {
            return __builtin_remquol(__x, __y, __pquo);
        }
        template <typename _Tp, typename _Up> inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(_Tp __x, _Up __y, int *__pquo) {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return remquo(__type(__x), __type(__y), __pquo);
        }
        constexpr float rint(float __x) {
            return __builtin_rintf(__x);
        }
        constexpr long double rint(long double __x) {
            return __builtin_rintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type rint(_Tp __x) {
            return __builtin_rint(__x);
        }
        constexpr float round(float __x) {
            return __builtin_roundf(__x);
        }
        constexpr long double round(long double __x) {
            return __builtin_roundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type round(_Tp __x) {
            return __builtin_round(__x);
        }
        constexpr float scalbln(float __x, long __ex) {
            return __builtin_scalblnf(__x, __ex);
        }
        constexpr long double scalbln(long double __x, long __ex) {
            return __builtin_scalblnl(__x, __ex);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbln(_Tp __x, long __ex) {
            return __builtin_scalbln(__x, __ex);
        }
        constexpr float scalbn(float __x, int __ex) {
            return __builtin_scalbnf(__x, __ex);
        }
        constexpr long double scalbn(long double __x, int __ex) {
            return __builtin_scalbnl(__x, __ex);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbn(_Tp __x, int __ex) {
            return __builtin_scalbn(__x, __ex);
        }
        constexpr float tgamma(float __x) {
            return __builtin_tgammaf(__x);
        }
        constexpr long double tgamma(long double __x) {
            return __builtin_tgammal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tgamma(_Tp __x) {
            return __builtin_tgamma(__x);
        }
        constexpr float trunc(float __x) {
            return __builtin_truncf(__x);
        }
        constexpr long double trunc(long double __x) {
            return __builtin_truncl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type trunc(_Tp __x) {
            return __builtin_trunc(__x);
        }
    }
}
namespace std {
    extern std::istream cin;
    extern std::ostream cout;
    extern std::ostream cerr;
    extern std::ostream clog;
    extern std::wistream wcin;
    extern std::wostream wcout;
    extern std::wostream wcerr;
    extern std::wostream wclog;
    static ios_base::Init __ioinit;
}
namespace std {
    template <typename _ValueType, typename _Tp> constexpr bool __check_constructible() {
        static_assert(is_constructible<_ValueType, _Tp>::value, "result type must be constructible from input type");
        return true;
    }
    template <typename _InputIterator, typename _ForwardIterator> _ForwardIterator __do_uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
        _ForwardIterator __cur = __result;
        try {
            for (; __first != __last; ++__first , (void)++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template <bool _TrivialValueTypes> struct __uninitialized_copy {
        template <typename _InputIterator, typename _ForwardIterator> static _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
            return std::__do_uninit_copy(__first, __last, __result);
        }
    };
    template<> struct __uninitialized_copy<true> {
        template <typename _InputIterator, typename _ForwardIterator> static _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
            return std::copy(__first, __last, __result);
        }
    };
    template <typename _InputIterator, typename _ForwardIterator> inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
        typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
        const bool __can_memmove = __is_trivial(_ValueType1);
        using _From = decltype(*__first);
        const bool __assignable = __is_trivial(_ValueType2) && __is_assignable(_ValueType2 &, _From) && std::__check_constructible<_ValueType2, _From>();
        return std::__uninitialized_copy<__can_memmove && __assignable>::__uninit_copy(__first, __last, __result);
    }
    template <typename _ForwardIterator, typename _Tp> void __do_uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
        _ForwardIterator __cur = __first;
        try {
            for (; __cur != __last; ++__cur)
                std::_Construct(std::__addressof(*__cur), __x);
        } catch (...) {
            std::_Destroy(__first, __cur);
            throw;
        }
    }
    template <bool _TrivialValueType> struct __uninitialized_fill {
        template <typename _ForwardIterator, typename _Tp> static void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
            std::__do_uninit_fill(__first, __last, __x);
        }
    };
    template<> struct __uninitialized_fill<true> {
        template <typename _ForwardIterator, typename _Tp> static void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
            std::fill(__first, __last, __x);
        }
    };
    template <typename _ForwardIterator, typename _Tp> inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        const bool __can_fill = __is_trivial(_ValueType) && __is_assignable(_ValueType &, const _Tp &) && std::__check_constructible<_ValueType, const _Tp &>();
        std::__uninitialized_fill<__can_fill>::__uninit_fill(__first, __last, __x);
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp> _ForwardIterator __do_uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
        _ForwardIterator __cur = __first;
        try {
            for (; __n > 0; --__n , (void)++__cur)
                std::_Construct(std::__addressof(*__cur), __x);
            return __cur;
        } catch (...) {
            std::_Destroy(__first, __cur);
            throw;
        }
    }
    template <bool _TrivialValueType> struct __uninitialized_fill_n {
        template <typename _ForwardIterator, typename _Size, typename _Tp> static _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
            return std::__do_uninit_fill_n(__first, __n, __x);
        }
    };
    template<> struct __uninitialized_fill_n<true> {
        template <typename _ForwardIterator, typename _Size, typename _Tp> static _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
            return std::fill_n(__first, __n, __x);
        }
    };
    template <typename _ForwardIterator, typename _Size, typename _Tp> inline _ForwardIterator uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        const bool __can_fill = __is_trivial(_ValueType) && __is_assignable(_ValueType &, const _Tp &) && std::__check_constructible<_ValueType, const _Tp &>() && __is_integer<_Size>::__value;
        return __uninitialized_fill_n<__can_fill>::__uninit_fill_n(__first, __n, __x);
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) {
        _ForwardIterator __cur = __result;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __first != __last; ++__first , (void)++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur, __alloc);
            throw;
        }
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Tp> inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, allocator<_Tp> &) {
        return std::uninitialized_copy(__first, __last, __result);
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) {
        return std::__uninitialized_copy_a(std::make_move_iterator(__first), std::make_move_iterator(__last), __result, __alloc);
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) {
        return std::__uninitialized_copy_a(std::__make_move_if_noexcept_iterator(__first), std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }
    template <typename _ForwardIterator, typename _Tp, typename _Allocator> void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __cur != __last; ++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur), __x);
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Tp, typename _Tp2> inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, allocator<_Tp2> &) {
        std::uninitialized_fill(__first, __last, __x);
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator> _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __n > 0; --__n , (void)++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur), __x);
            return __cur;
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2> inline _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, allocator<_Tp2> &) {
        return std::uninitialized_fill_n(__first, __n, __x);
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc) {
        _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc);
        try {
            return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
        } catch (...) {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc) {
        _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc);
        try {
            return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
        } catch (...) {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator> inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc) {
        std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
        try {
            return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
        } catch (...) {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator> inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc) {
        _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc);
        try {
            std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
        } catch (...) {
            std::_Destroy(__first2, __mid2, __alloc);
            throw;
        }
    }
    template <bool _TrivialValueType> struct __uninitialized_default_1 {
        template <typename _ForwardIterator> static void __uninit_default(_ForwardIterator __first, _ForwardIterator __last) {
            _ForwardIterator __cur = __first;
            try {
                for (; __cur != __last; ++__cur)
                    std::_Construct(std::__addressof(*__cur));
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_1<true> {
        template <typename _ForwardIterator> static void __uninit_default(_ForwardIterator __first, _ForwardIterator __last) {
            if (__first == __last)
                return;
            typename iterator_traits<_ForwardIterator>::value_type *__val = std::__addressof(*__first);
            std::_Construct(__val);
            if (++__first != __last)
                std::fill(__first, __last, *__val);
        }
    };
    template <bool _TrivialValueType> struct __uninitialized_default_n_1 {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __uninit_default_n(_ForwardIterator __first, _Size __n) {
            _ForwardIterator __cur = __first;
            try {
                for (; __n > 0; --__n , (void)++__cur)
                    std::_Construct(std::__addressof(*__cur));
                return __cur;
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_n_1<true> {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __uninit_default_n(_ForwardIterator __first, _Size __n) {
            if (__n > 0) {
                typename iterator_traits<_ForwardIterator>::value_type *__val = std::__addressof(*__first);
                std::_Construct(__val);
                ++__first;
                __first = std::fill_n(__first, __n - 1, *__val);
            }
            return __first;
        }
    };
    template <typename _ForwardIterator> inline void __uninitialized_default(_ForwardIterator __first, _ForwardIterator __last) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        const bool __assignable = is_copy_assignable<_ValueType>::value;
        std::__uninitialized_default_1<__is_trivial(_ValueType) && __assignable>::__uninit_default(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator __uninitialized_default_n(_ForwardIterator __first, _Size __n) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        constexpr bool __can_fill = __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
        return __uninitialized_default_n_1<__is_trivial(_ValueType) && __can_fill>::__uninit_default_n(__first, __n);
    }
    template <typename _ForwardIterator, typename _Allocator> void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __cur != __last; ++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur));
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Tp> inline void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &) {
        std::__uninitialized_default(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size, typename _Allocator> _ForwardIterator __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __n > 0; --__n , (void)++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur));
            return __cur;
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp> inline _ForwardIterator __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, allocator<_Tp> &) {
        return std::__uninitialized_default_n(__first, __n);
    }
    template <bool _TrivialValueType> struct __uninitialized_default_novalue_1 {
        template <typename _ForwardIterator> static void __uninit_default_novalue(_ForwardIterator __first, _ForwardIterator __last) {
            _ForwardIterator __cur = __first;
            try {
                for (; __cur != __last; ++__cur)
                    std::_Construct_novalue(std::__addressof(*__cur));
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_novalue_1<true> {
        template <typename _ForwardIterator> static void __uninit_default_novalue(_ForwardIterator __first, _ForwardIterator __last) {
        }
    };
    template <bool _TrivialValueType> struct __uninitialized_default_novalue_n_1 {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __uninit_default_novalue_n(_ForwardIterator __first, _Size __n) {
            _ForwardIterator __cur = __first;
            try {
                for (; __n > 0; --__n , (void)++__cur)
                    std::_Construct_novalue(std::__addressof(*__cur));
                return __cur;
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_novalue_n_1<true> {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __uninit_default_novalue_n(_ForwardIterator __first, _Size __n) {
            return std::next(__first, __n);
        }
    };
    template <typename _ForwardIterator> inline void __uninitialized_default_novalue(_ForwardIterator __first, _ForwardIterator __last) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        std::__uninitialized_default_novalue_1<is_trivially_default_constructible<_ValueType>::value>::__uninit_default_novalue(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        return __uninitialized_default_novalue_n_1<is_trivially_default_constructible<_ValueType>::value>::__uninit_default_novalue_n(__first, __n);
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> _ForwardIterator __uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result, std::input_iterator_tag) {
        _ForwardIterator __cur = __result;
        try {
            for (; __n > 0; --__n , (void)++__first , ++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template <typename _RandomAccessIterator, typename _Size, typename _ForwardIterator> inline _ForwardIterator __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, std::random_access_iterator_tag) {
        return std::uninitialized_copy(__first, __first + __n, __result);
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> pair<_InputIterator, _ForwardIterator> __uninitialized_copy_n_pair(_InputIterator __first, _Size __n, _ForwardIterator __result, std::input_iterator_tag) {
        _ForwardIterator __cur = __result;
        try {
            for (; __n > 0; --__n , (void)++__first , ++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return {__first, __cur};
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template <typename _RandomAccessIterator, typename _Size, typename _ForwardIterator> inline pair<_RandomAccessIterator, _ForwardIterator> __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, std::random_access_iterator_tag) {
        auto __second_res = uninitialized_copy(__first, __first + __n, __result);
        auto __first_res = std::next(__first, __n);
        return {__first_res, __second_res};
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> inline _ForwardIterator uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result) {
        return std::__uninitialized_copy_n(__first, __n, __result, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> inline pair<_InputIterator, _ForwardIterator> __uninitialized_copy_n_pair(_InputIterator __first, _Size __n, _ForwardIterator __result) {
        return std::__uninitialized_copy_n_pair(__first, __n, __result, std::__iterator_category(__first));
    }
    template <typename _Tp, typename _Up, typename _Allocator> inline void __relocate_object_a(_Tp *__restrict __dest, _Up *__restrict __orig, _Allocator &__alloc) noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc, __dest, std::move(*__orig))) && noexcept(std::allocator_traits<_Allocator>::destroy(__alloc, std::__addressof(*__orig)))) {
        typedef std::allocator_traits<_Allocator> __traits;
        __traits::construct(__alloc, __dest, std::move(*__orig));
        __traits::destroy(__alloc, std::__addressof(*__orig));
    }
    template <typename _Tp, typename = void> struct __is_bitwise_relocatable : is_trivial<_Tp> {
    };
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __relocate_a_1(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result), std::addressof(*__first), __alloc))) {
        typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
        static_assert(std::is_same<_ValueType, _ValueType2>::value, "relocation is only possible for values of the same type");
        _ForwardIterator __cur = __result;
        for (; __first != __last; ++__first , (void)++__cur)
            std::__relocate_object_a(std::__addressof(*__cur), std::__addressof(*__first), __alloc);
        return __cur;
    }
    template <typename _Tp, typename _Up> inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp *> __relocate_a_1(_Tp *__first, _Tp *__last, _Tp *__result, allocator<_Up> &__alloc [[maybe_unused]]) noexcept {
        std::ptrdiff_t __count = __last - __first;
        if (__count > 0) {
            __builtin_memmove(__result, __first, __count * sizeof(_Tp));
        }
        return __result + __count;
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __relocate_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) noexcept(noexcept(__relocate_a_1(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result), __alloc))) {
        return std::__relocate_a_1(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result), __alloc);
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp> inline void __return_temporary_buffer(_Tp *__p, std::size_t __len __attribute__((unused))) {
            ::operator delete(__p);
        }
    }
    template <typename _Tp> pair<_Tp *, std::ptrdiff_t> get_temporary_buffer(std::ptrdiff_t __len) noexcept {
        const std::ptrdiff_t __max = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
        if (__len > __max)
            __len = __max;
        while (__len > 0)
            {
                _Tp *__tmp = static_cast<_Tp *>(::operator new(__len * sizeof(_Tp), std::nothrow));
                if (__tmp != 0)
                    return std::pair<_Tp *, ptrdiff_t>(__tmp, __len);
                __len = __len == 1 ? 0 : ((__len + 1) / 2);
            }
        return std::pair<_Tp *, ptrdiff_t>(static_cast<_Tp *>(0), 0);
    }
    template <typename _Tp> inline void return_temporary_buffer(_Tp *__p) {
        ::operator delete(__p);
    }
    template <typename _ForwardIterator, typename _Tp> class _Temporary_buffer {
    public:
        typedef _Tp value_type;
        typedef std::_Temporary_buffer::value_type *pointer;
        typedef std::_Temporary_buffer::pointer iterator;
        typedef std::ptrdiff_t size_type;
    protected:
        std::_Temporary_buffer::size_type _M_original_len;
        std::_Temporary_buffer::size_type _M_len;
        std::_Temporary_buffer::pointer _M_buffer;
    public:
        std::_Temporary_buffer::size_type size() const {
            return this->_M_len;
        }
        std::_Temporary_buffer::size_type requested_size() const {
            return this->_M_original_len;
        }
        std::_Temporary_buffer::iterator begin() {
            return this->_M_buffer;
        }
        std::_Temporary_buffer::iterator end() {
            return this->_M_buffer + this->_M_len;
        }
        _Temporary_buffer<_ForwardIterator, _Tp>(_ForwardIterator __seed, std::_Temporary_buffer::size_type __original_len);
        ~_Temporary_buffer<_ForwardIterator, _Tp>() {
            std::_Destroy(this->_M_buffer, this->_M_buffer + this->_M_len);
            std::__detail::__return_temporary_buffer(this->_M_buffer, this->_M_len);
        }
    private:
        _Temporary_buffer<_ForwardIterator, _Tp>(const _Temporary_buffer<_ForwardIterator, _Tp> &);
        void operator=(const _Temporary_buffer<_ForwardIterator, _Tp> &);
    };
    template <bool> struct __uninitialized_construct_buf_dispatch {
        template <typename _Pointer, typename _ForwardIterator> static void __ucr(_Pointer __first, _Pointer __last, _ForwardIterator __seed) {
            if (__first == __last)
                return;
            _Pointer __cur = __first;
            try {
                std::_Construct(std::__addressof(*__first), std::move(*__seed));
                _Pointer __prev = __cur;
                ++__cur;
                for (; __cur != __last; ++__cur , ++__prev)
                    std::_Construct(std::__addressof(*__cur), std::move(*__prev));
                *__seed = std::move(*__prev);
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_construct_buf_dispatch<true> {
        template <typename _Pointer, typename _ForwardIterator> static void __ucr(_Pointer, _Pointer, _ForwardIterator) {
        }
    };
    template <typename _Pointer, typename _ForwardIterator> inline void __uninitialized_construct_buf(_Pointer __first, _Pointer __last, _ForwardIterator __seed) {
        typedef typename std::iterator_traits<_Pointer>::value_type _ValueType;
        std::__uninitialized_construct_buf_dispatch<__has_trivial_constructor(_ValueType)>::__ucr(__first, __last, __seed);
    }
    template <typename _ForwardIterator, typename _Tp> _Temporary_buffer<_ForwardIterator, _Tp>::_Temporary_buffer<_ForwardIterator, _Tp>(_ForwardIterator __seed, std::_Temporary_buffer::size_type __original_len) : _M_original_len(__original_len), _M_len(0), _M_buffer(0) {
        std::pair<pointer, size_type> __p(std::get_temporary_buffer<std::_Temporary_buffer::value_type>(this->_M_original_len));
        if (__p.first) {
            try {
                std::__uninitialized_construct_buf(__p.first, __p.first + __p.second, __seed);
                this->_M_buffer = __p.first;
                this->_M_len = __p.second;
            } catch (...) {
                std::__detail::__return_temporary_buffer(__p.first, __p.second);
                throw;
            }
        }
    }
}
namespace std {
    template <class _OutputIterator, class _Tp> class raw_storage_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _OutputIterator _M_iter;
    public:
        explicit raw_storage_iterator<_OutputIterator, _Tp>(_OutputIterator __x) : _M_iter(__x) {
        }
        raw_storage_iterator<_OutputIterator, _Tp> &operator*() {
            return *this;
        }
        raw_storage_iterator<_OutputIterator, _Tp> &operator=(const _Tp &__element) {
            std::_Construct(std::__addressof(*this->_M_iter), __element);
            return *this;
        }
        raw_storage_iterator<_OutputIterator, _Tp> &operator=(_Tp &&__element) {
            std::_Construct(std::__addressof(*this->_M_iter), std::move(__element));
            return *this;
        }
        raw_storage_iterator<_OutputIterator, _Tp> &operator++() {
            ++this->_M_iter;
            return *this;
        }
        raw_storage_iterator<_OutputIterator, _Tp> operator++(int) {
            raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
            ++this->_M_iter;
            return __tmp;
        }
        _OutputIterator base() const {
            return this->_M_iter;
        }
    };
}
namespace std {
    template <typename _Tp> constexpr _Tp __rotl(_Tp __x, int __s) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        if ((_Nd & (_Nd - 1)) == 0) {
            constexpr unsigned int __uNd = _Nd;
            const unsigned int __r = __s;
            return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
        }
        const int __r = __s % _Nd;
        if (__r == 0)
            return __x;
        else if (__r > 0)
            return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
        else
            return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }
    template <typename _Tp> constexpr _Tp __rotr(_Tp __x, int __s) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        if ((_Nd & (_Nd - 1)) == 0) {
            constexpr unsigned int __uNd = _Nd;
            const unsigned int __r = __s;
            return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
        }
        const int __r = __s % _Nd;
        if (__r == 0)
            return __x;
        else if (__r > 0)
            return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
        else
            return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }
    template <typename _Tp> constexpr int __countl_zero(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        if (__x == 0)
            return _Nd;
        constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
        constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
        constexpr auto _Nd_u = __int_traits<unsigned int>::__digits;
        if (_Nd <= _Nd_u) {
            constexpr int __diff = _Nd_u - _Nd;
            return __builtin_clz(__x) - __diff;
        } else if (_Nd <= _Nd_ul) {
            constexpr int __diff = _Nd_ul - _Nd;
            return __builtin_clzl(__x) - __diff;
        } else if (_Nd <= _Nd_ull) {
            constexpr int __diff = _Nd_ull - _Nd;
            return __builtin_clzll(__x) - __diff;
        } else {
            static_assert(_Nd <= (2 * _Nd_ull), "Maximum supported integer size is 128-bit");
            unsigned long long __high = __x >> _Nd_ull;
            if (__high != 0) {
                constexpr int __diff = (2 * _Nd_ull) - _Nd;
                return __builtin_clzll(__high) - __diff;
            }
            constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
            unsigned long long __low = __x & __max_ull;
            return (_Nd - _Nd_ull) + __builtin_clzll(__low);
        }
    }
    template <typename _Tp> constexpr int __countl_one(_Tp __x) noexcept {
        return std::__countl_zero<_Tp>((_Tp)~ __x);
    }
    template <typename _Tp> constexpr int __countr_zero(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        if (__x == 0)
            return _Nd;
        constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
        constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
        constexpr auto _Nd_u = __int_traits<unsigned int>::__digits;
        if (_Nd <= _Nd_u)
            return __builtin_ctz(__x);
        else if (_Nd <= _Nd_ul)
            return __builtin_ctzl(__x);
        else if (_Nd <= _Nd_ull)
            return __builtin_ctzll(__x);
        else {
            static_assert(_Nd <= (2 * _Nd_ull), "Maximum supported integer size is 128-bit");
            constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
            unsigned long long __low = __x & __max_ull;
            if (__low != 0)
                return __builtin_ctzll(__low);
            unsigned long long __high = __x >> _Nd_ull;
            return __builtin_ctzll(__high) + _Nd_ull;
        }
    }
    template <typename _Tp> constexpr int __countr_one(_Tp __x) noexcept {
        return std::__countr_zero((_Tp)~ __x);
    }
    template <typename _Tp> constexpr int __popcount(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
        constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
        constexpr auto _Nd_u = __int_traits<unsigned int>::__digits;
        if (_Nd <= _Nd_u)
            return __builtin_popcount(__x);
        else if (_Nd <= _Nd_ul)
            return __builtin_popcountl(__x);
        else if (_Nd <= _Nd_ull)
            return __builtin_popcountll(__x);
        else {
            static_assert(_Nd <= (2 * _Nd_ull), "Maximum supported integer size is 128-bit");
            constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
            unsigned long long __low = __x & __max_ull;
            unsigned long long __high = __x >> _Nd_ull;
            return __builtin_popcountll(__low) + __builtin_popcountll(__high);
        }
    }
    template <typename _Tp> constexpr bool __has_single_bit(_Tp __x) noexcept {
        return std::__popcount(__x) == 1;
    }
    template <typename _Tp> constexpr _Tp __bit_ceil(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        if (__x == 0 || __x == 1)
            return 1;
        auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1U));
        if (!std::__is_constant_evaluated()) {
            do {
                if (std::__is_constant_evaluated() && !bool(__shift_exponent != __int_traits<_Tp>::__digits))
                    __builtin_unreachable();
            } while (false);
        }
        using __promoted_type = decltype(__x << 1);
        if (!is_same<__promoted_type, _Tp>::value) {
            const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
            __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
        }
        return (_Tp)1U << __shift_exponent;
    }
    template <typename _Tp> constexpr _Tp __bit_floor(_Tp __x) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        if (__x == 0)
            return 0;
        return (_Tp)1U << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }
    template <typename _Tp> constexpr _Tp __bit_width(_Tp __x) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        return _Nd - std::__countl_zero(__x);
    }
}
namespace std {
    inline void *align(std::size_t __align, std::size_t __size, void *&__ptr, std::size_t &__space) noexcept {
        if (__space < __size)
            return nullptr;
        const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
        const auto __aligned = (__intptr - 1U + __align) & -__align;
        const auto __diff = __aligned - __intptr;
        if (__diff > (__space - __size))
            return nullptr;
        else {
            __space -= __diff;
            return __ptr = reinterpret_cast<void *>(__aligned);
        }
    }
}
namespace std {
    struct __erased_type {
    };
    template <typename _Alloc, typename _Tp> using __is_erased_or_convertible = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, std::__erased_type>>;
    struct allocator_arg_t {
        explicit allocator_arg_t() noexcept = default
    };
    constexpr std::allocator_arg_t allocator_arg = std::allocator_arg_t();
    template <typename _Tp, typename _Alloc, typename = __void_t<>> struct __uses_allocator_helper : std::false_type {
    };
    template <typename _Tp, typename _Alloc> struct __uses_allocator_helper<_Tp, _Alloc, __void_t<typename _Tp::allocator_type>> : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type {
    };
    template <typename _Tp, typename _Alloc> struct uses_allocator : __uses_allocator_helper<_Tp, _Alloc>::type {
    };
    struct __uses_alloc_base {
    };
    struct __uses_alloc0 : std::__uses_alloc_base {
        struct _Sink {
            void operator=(const void *) {
            }
        } _M_a;
    };
    template <typename _Alloc> struct __uses_alloc1 : std::__uses_alloc_base {
        const _Alloc *_M_a;
    };
    template <typename _Alloc> struct __uses_alloc2 : std::__uses_alloc_base {
        const _Alloc *_M_a;
    };
    template <bool, typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc;
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc<true, _Tp, _Alloc, _Args...> : __conditional_t<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>::value, __uses_alloc1<_Alloc>, __uses_alloc2<_Alloc>> {
        static_assert(__or_<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>, is_constructible<_Tp, _Args..., const _Alloc &>>::value, "construction with an allocator must be possible if uses_allocator is true");
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc<false, _Tp, _Alloc, _Args...> : std::__uses_alloc0 {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> using __uses_alloc_t = __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;
    template <typename _Tp, typename _Alloc, typename ..._Args> inline __uses_alloc_t<_Tp, _Alloc, _Args...> __use_alloc(const _Alloc &__a) {
        __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
        __ret._M_a = std::__addressof(__a);
        return __ret;
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __use_alloc(const _Alloc &&) = delete
    template <template <typename ...> class _Predicate, typename _Tp, typename _Alloc, typename ..._Args> struct __is_uses_allocator_predicate : __conditional_t<uses_allocator<_Tp, _Alloc>::value, __or_<_Predicate<_Tp, std::allocator_arg_t, _Alloc, _Args...>, _Predicate<_Tp, _Args..., _Alloc>>, _Predicate<_Tp, _Args...>> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __is_uses_allocator_constructible : __is_uses_allocator_predicate<std::is_constructible, _Tp, _Alloc, _Args...> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr bool __is_uses_allocator_constructible_v = __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __is_nothrow_uses_allocator_constructible : __is_uses_allocator_predicate<std::is_nothrow_constructible, _Tp, _Alloc, _Args...> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr bool __is_nothrow_uses_allocator_constructible_v = __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;
    template <typename _Tp, typename ..._Args> void __uses_allocator_construct_impl(std::__uses_alloc0 __a, _Tp *__ptr, _Args &&...__args) {
        ::new ((void *)__ptr) _Tp((std::forward<_Args>(__args)...));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp *__ptr, _Args &&...__args) {
        ::new ((void *)__ptr) _Tp((allocator_arg, *__a._M_a, std::forward<_Args>(__args)...));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp *__ptr, _Args &&...__args) {
        ::new ((void *)__ptr) _Tp((std::forward<_Args>(__args)..., *__a._M_a));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct(const _Alloc &__a, _Tp *__ptr, _Args &&...__args) {
        std::__uses_allocator_construct_impl(std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr, std::forward<_Args>(__args)...);
    }
}
namespace std {
    template <typename ..._Elements> class tuple;
    template <typename _Tp> struct __is_empty_non_tuple : is_empty<_Tp> {
    };
    template <typename _El0, typename ..._El> struct __is_empty_non_tuple<tuple<_El0, _El...>> : std::false_type {
    };
    template <typename _Tp> using __empty_not_final = __conditional_t<__is_final(_Tp), std::false_type, __is_empty_non_tuple<_Tp>>;
    template <std::size_t _Idx, typename _Head, bool = __empty_not_final<_Head>::value> struct _Head_base;
    template <std::size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, true> {
        constexpr _Head_base<_Idx, type-parameter-0-1, true>() : _M_head_impl() {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, true>(const _Head &__h) : _M_head_impl(__h) {
        }
        _Head_base<_Idx, type-parameter-0-1, true>(const _Head_base<_Idx, type-parameter-0-1, true> &) = default
        _Head_base<_Idx, type-parameter-0-1, true>(_Head_base<_Idx, type-parameter-0-1, true> &&) = default
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, true>(_UHead &&__h) : _M_head_impl(std::forward<_UHead>(__h)) {
        }
        _Head_base<_Idx, type-parameter-0-1, true>(std::allocator_arg_t, std::__uses_alloc0) : _M_head_impl() {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, true>(std::allocator_arg_t, __uses_alloc1<_Alloc> __a) : _M_head_impl(allocator_arg, *__a._M_a) {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, true>(std::allocator_arg_t, __uses_alloc2<_Alloc> __a) : _M_head_impl(*__a._M_a) {
        }
        template <typename _UHead> _Head_base<_Idx, type-parameter-0-1, true>(std::__uses_alloc0, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, true>(__uses_alloc1<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, true>(__uses_alloc2<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) {
        }
        static constexpr _Head &_M_head(_Head_base<_Idx, type-parameter-0-1, true> &__b) noexcept {
            return __b._M_head_impl;
        }
        static constexpr const _Head &_M_head(const _Head_base<_Idx, type-parameter-0-1, true> &__b) noexcept {
            return __b._M_head_impl;
        }
        _Head _M_head_impl [[no_unique_address]];
    };
    template <std::size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, false> {
        constexpr _Head_base<_Idx, type-parameter-0-1, false>() : _M_head_impl() {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, false>(const _Head &__h) : _M_head_impl(__h) {
        }
        _Head_base<_Idx, type-parameter-0-1, false>(const _Head_base<_Idx, type-parameter-0-1, false> &) = default
        _Head_base<_Idx, type-parameter-0-1, false>(_Head_base<_Idx, type-parameter-0-1, false> &&) = default
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, false>(_UHead &&__h) : _M_head_impl(std::forward<_UHead>(__h)) {
        }
        _Head_base<_Idx, type-parameter-0-1, false>(std::allocator_arg_t, std::__uses_alloc0) : _M_head_impl() {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, false>(std::allocator_arg_t, __uses_alloc1<_Alloc> __a) : _M_head_impl(allocator_arg, *__a._M_a) {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, false>(std::allocator_arg_t, __uses_alloc2<_Alloc> __a) : _M_head_impl(*__a._M_a) {
        }
        template <typename _UHead> _Head_base<_Idx, type-parameter-0-1, false>(std::__uses_alloc0, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, false>(__uses_alloc1<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, false>(__uses_alloc2<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) {
        }
        static constexpr _Head &_M_head(_Head_base<_Idx, type-parameter-0-1, false> &__b) noexcept {
            return __b._M_head_impl;
        }
        static constexpr const _Head &_M_head(const _Head_base<_Idx, type-parameter-0-1, false> &__b) noexcept {
            return __b._M_head_impl;
        }
        _Head _M_head_impl;
    };
    template <std::size_t _Idx, typename ..._Elements> struct _Tuple_impl;
    template <std::size_t _Idx, typename _Head, typename ..._Tail> struct _Tuple_impl<_Idx, _Head, _Tail...> : public _Tuple_impl<_Idx + 1, _Tail...>, private _Head_base<_Idx, _Head> {
        friend template <std::size_t, typename ...> struct _Tuple_impl;
        typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
        typedef _Head_base<_Idx, _Head> _Base;
        static constexpr _Head &_M_head(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        static constexpr const _Head &_M_head(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        static constexpr std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited &_M_tail(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return __t;
        }
        static constexpr const std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited &_M_tail(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return __t;
        }
        constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>() : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base() {
        }
        constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Head &__head, const _Tail &...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tail...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__head) {
        }
        template <typename _UHead, typename ..._UTail, typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>> constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_UHead &&__head, _UTail &&...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(std::forward<_UTail>(__tail)...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(std::forward<_UHead>(__head)) {
        }
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &) = default
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &operator=(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &) = delete
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &&) = default
        template <typename ..._UElements> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Tuple_impl<_Idx, _UElements...> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) {
        }
        template <typename _UHead, typename ..._UTails> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__tag, __use_alloc<_Head>(__a)) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Head &__head, const _Tail &...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, __tail...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTail, typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&__head, _UTail &&...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, std::forward<_UTail>(__tail)...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(__head)) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, _M_tail(__in)), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, std::move(_M_tail(__in))), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), std::forward<_Head>(_M_head(__in))) {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTails> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, _UHead, _UTails...> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, const _UHead &>(__a), _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)) {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTails> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, _UHead, _UTails...> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) {
        }
        template <typename ..._UElements> void _M_assign(const _Tuple_impl<_Idx, _UElements...> &__in) {
            _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
            _M_tail(*this)._M_assign(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
        }
        template <typename _UHead, typename ..._UTails> void _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in) {
            _M_head(*this) = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
            _M_tail(*this)._M_assign(std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
        }
    protected:
        void _M_swap(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__in) {
            using std::swap;
            swap(_M_head(*this), _M_head(__in));
            _Inherited::_M_swap(_M_tail(__in));
        }
    };
    template <std::size_t _Idx, typename _Head> struct _Tuple_impl<_Idx, _Head> : private _Head_base<_Idx, _Head> {
        friend template <std::size_t, typename ...> struct _Tuple_impl;
        typedef _Head_base<_Idx, _Head> _Base;
        static constexpr _Head &_M_head(_Tuple_impl<_Idx, type-parameter-0-1> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        static constexpr const _Head &_M_head(const _Tuple_impl<_Idx, type-parameter-0-1> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        constexpr _Tuple_impl<_Idx, type-parameter-0-1>() : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base() {
        }
        constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1>(const _Head &__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__head) {
        }
        template <typename _UHead> constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1>(_UHead &&__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(std::forward<_UHead>(__head)) {
        }
        _Tuple_impl<_Idx, type-parameter-0-1>(const _Tuple_impl<_Idx, type-parameter-0-1> &) = default
        _Tuple_impl<_Idx, type-parameter-0-1> &operator=(const _Tuple_impl<_Idx, type-parameter-0-1> &) = delete
        constexpr _Tuple_impl<_Idx, type-parameter-0-1>(_Tuple_impl<_Idx, type-parameter-0-1> &&__in) noexcept(is_nothrow_move_constructible<_Head>::value) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(static_cast<std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base &&>(__in)) {
        }
        template <typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(const _Tuple_impl<_Idx, _UHead> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) {
        }
        template <typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(_Tuple_impl<_Idx, _UHead> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in))) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__tag, __use_alloc<_Head>(__a)) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _Head &__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, const _Head &>(__a), __head) {
        }
        template <typename _Alloc, typename _UHead> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(__head)) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, type-parameter-0-1> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, const _Head &>(__a), _M_head(__in)) {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, type-parameter-0-1> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), std::forward<_Head>(_M_head(__in))) {
        }
        template <typename _Alloc, typename _UHead> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, _UHead> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, const _UHead &>(__a), _Tuple_impl<_Idx, _UHead>::_M_head(__in)) {
        }
        template <typename _Alloc, typename _UHead> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, _UHead> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in))) {
        }
        template <typename _UHead> void _M_assign(const _Tuple_impl<_Idx, _UHead> &__in) {
            _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
        }
        template <typename _UHead> void _M_assign(_Tuple_impl<_Idx, _UHead> &&__in) {
            _M_head(*this) = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
        }
    protected:
        void _M_swap(_Tuple_impl<_Idx, type-parameter-0-1> &__in) {
            using std::swap;
            swap(_M_head(*this), _M_head(__in));
        }
    };
    template <bool, typename ..._Types> struct _TupleConstraints {
        template <typename ..._UTypes> static constexpr bool __is_implicitly_constructible() {
            return __and_<is_constructible<_Types, _UTypes>..., is_convertible<_UTypes, _Types>...>::value;
        }
        template <typename ..._UTypes> static constexpr bool __is_explicitly_constructible() {
            return __and_<is_constructible<_Types, _UTypes>..., __not_<__and_<is_convertible<_UTypes, _Types>...>>>::value;
        }
        static constexpr bool __is_implicitly_default_constructible() {
            return __and_<std::__is_implicitly_default_constructible<_Types>...>::value;
        }
        static constexpr bool __is_explicitly_default_constructible() {
            return __and_<is_default_constructible<_Types>..., __not_<__and_<std::__is_implicitly_default_constructible<_Types>...>>>::value;
        }
    };
    template <typename ..._Types> struct _TupleConstraints<false, _Types...> {
        template <typename ..._UTypes> static constexpr bool __is_implicitly_constructible() {
            return false;
        }
        template <typename ..._UTypes> static constexpr bool __is_explicitly_constructible() {
            return false;
        }
    };
    template <typename ..._Elements> class tuple : public _Tuple_impl<0, _Elements...> {
        typedef _Tuple_impl<0, _Elements...> _Inherited;
        template <bool _Cond> using _TCC = _TupleConstraints<_Cond, _Elements...>;
        template <bool _Dummy> using _ImplicitDefaultCtor = __enable_if_t<_TCC<_Dummy>::__is_implicitly_default_constructible(), bool>;
        template <bool _Dummy> using _ExplicitDefaultCtor = __enable_if_t<_TCC<_Dummy>::__is_explicitly_default_constructible(), bool>;
        template <bool _Cond, typename ..._Args> using _ImplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_implicitly_constructible<_Args...>(), bool>;
        template <bool _Cond, typename ..._Args> using _ExplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_explicitly_constructible<_Args...>(), bool>;
        template <typename ..._UElements> static constexpr __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool> __assignable() {
            return __and_<is_assignable<_Elements &, _UElements>...>::value;
        }
        template <typename ..._UElements> static constexpr bool __nothrow_assignable() {
            return __and_<is_nothrow_assignable<_Elements &, _UElements>...>::value;
        }
        template <typename ..._UElements> static constexpr bool __nothrow_constructible() {
            return __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
        }
        template <typename _Up> static constexpr bool __valid_args() {
            return sizeof...(_Elements) == 1 && !is_same<tuple<type-parameter-0-0...>, __remove_cvref_t<_Up>>::value;
        }
        template <typename, typename, typename ..._Tail> static constexpr bool __valid_args() {
            return (sizeof...(_Tail) + 2) == sizeof...(_Elements);
        }
        template <typename _Tuple, typename = tuple<type-parameter-0-0...>, typename = __remove_cvref_t<_Tuple>> struct _UseOtherCtor : std::false_type {
        };
        template <typename _Tuple, typename _Tp, typename _Up> struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>> : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>> {
        };
        template <typename _Tuple, typename _Tp> struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>> : std::true_type {
        };
        template <typename _Tuple> static constexpr bool __use_other_ctor() {
            return _UseOtherCtor<_Tuple>::value;
        }
    public:
        template <typename _Dummy = void, _ImplicitDefaultCtor<is_void<_Dummy>::value> = true> constexpr tuple<type-parameter-0-0...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value) : std::tuple::_Inherited() {
        }
        template <typename _Dummy = void, _ExplicitDefaultCtor<is_void<_Dummy>::value> = false> constexpr explicit tuple<type-parameter-0-0...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value) : std::tuple::_Inherited() {
        }
        template <bool _NotEmpty = (sizeof...(_Elements) >= 1), _ImplicitCtor<_NotEmpty, const _Elements &...> = true> constexpr tuple<type-parameter-0-0...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()) : std::tuple::_Inherited(__elements...) {
        }
        template <bool _NotEmpty = (sizeof...(_Elements) >= 1), _ExplicitCtor<_NotEmpty, const _Elements &...> = false> constexpr explicit tuple<type-parameter-0-0...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()) : std::tuple::_Inherited(__elements...) {
        }
        template <typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<type-parameter-0-0...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(std::forward<_UElements>(__elements)...) {
        }
        template <typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<type-parameter-0-0...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(std::forward<_UElements>(__elements)...) {
        }
        tuple<type-parameter-0-0...>(const tuple<type-parameter-0-0...> &) = default
        tuple<type-parameter-0-0...>(tuple<type-parameter-0-0...> &&) = default
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ImplicitCtor<_Valid, const _UElements &...> = true> constexpr tuple<type-parameter-0-0...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()) : std::tuple::_Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ExplicitCtor<_Valid, const _UElements &...> = false> constexpr explicit tuple<type-parameter-0-0...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()) : std::tuple::_Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<type-parameter-0-0...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<type-parameter-0-0...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        template <typename _Alloc, _ImplicitDefaultCtor<is_object<_Alloc>::value> = true> tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a) : std::tuple::_Inherited(__tag, __a) {
        }
        template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1), _ImplicitCtor<_NotEmpty, const _Elements &...> = true> tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...__elements) : std::tuple::_Inherited(__tag, __a, __elements...) {
        }
        template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1), _ExplicitCtor<_NotEmpty, const _Elements &...> = false> explicit tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...__elements) : std::tuple::_Inherited(__tag, __a, __elements...) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ImplicitCtor<_Valid, _UElements...> = true> tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...__elements) : std::tuple::_Inherited(__tag, __a, std::forward<_UElements>(__elements)...) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ExplicitCtor<_Valid, _UElements...> = false> explicit tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...__elements) : std::tuple::_Inherited(__tag, __a, std::forward<_UElements>(__elements)...) {
        }
        template <typename _Alloc> tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<type-parameter-0-0...> &__in) : std::tuple::_Inherited(__tag, __a, static_cast<const std::tuple::_Inherited &>(__in)) {
        }
        template <typename _Alloc> tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<type-parameter-0-0...> &&__in) : std::tuple::_Inherited(__tag, __a, static_cast<std::tuple::_Inherited &&>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ImplicitCtor<_Valid, const _UElements &...> = true> tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_UElements...> &__in) : std::tuple::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ExplicitCtor<_Valid, const _UElements &...> = false> explicit tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_UElements...> &__in) : std::tuple::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ImplicitCtor<_Valid, _UElements...> = true> tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_UElements...> &&__in) : std::tuple::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ExplicitCtor<_Valid, _UElements...> = false> explicit tuple<type-parameter-0-0...>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_UElements...> &&__in) : std::tuple::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        tuple<type-parameter-0-0...> &operator=(__conditional_t<__assignable<const _Elements &...>(), const tuple<type-parameter-0-0...> &, const std::__nonesuch &> __in) noexcept(__nothrow_assignable<const _Elements &...>()) {
            this->_M_assign(__in);
            return *this;
        }
        tuple<type-parameter-0-0...> &operator=(__conditional_t<__assignable<_Elements...>(), tuple<type-parameter-0-0...> &&, std::__nonesuch &&> __in) noexcept(__nothrow_assignable<_Elements...>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename ..._UElements> __enable_if_t<__assignable<const _UElements &...>(), tuple<type-parameter-0-0...> &> operator=(const tuple<_UElements...> &__in) noexcept(__nothrow_assignable<const _UElements &...>()) {
            this->_M_assign(__in);
            return *this;
        }
        template <typename ..._UElements> __enable_if_t<__assignable<_UElements...>(), tuple<type-parameter-0-0...> &> operator=(tuple<_UElements...> &&__in) noexcept(__nothrow_assignable<_UElements...>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        void swap(tuple<type-parameter-0-0...> &__in) noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value) {
            _Inherited::_M_swap(__in);
        }
    };
    template<> class tuple<> {
    public:
        void swap(std::tuple<> &) noexcept {
        }
        tuple() = default
        template <typename _Alloc> tuple(std::allocator_arg_t, const _Alloc &) noexcept {
        }
        template <typename _Alloc> tuple(std::allocator_arg_t, const _Alloc &, const std::tuple<> &) noexcept {
        }
    };
    template <typename _T1, typename _T2> class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2> {
        typedef _Tuple_impl<0, _T1, _T2> _Inherited;
        template <bool _Dummy, typename _U1, typename _U2> using _ImplicitDefaultCtor = __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::__is_implicitly_default_constructible(), bool>;
        template <bool _Dummy, typename _U1, typename _U2> using _ExplicitDefaultCtor = __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::__is_explicitly_default_constructible(), bool>;
        template <bool _Dummy> using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;
        template <bool _Cond, typename _U1, typename _U2> using _ImplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(), bool>;
        template <bool _Cond, typename _U1, typename _U2> using _ExplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(), bool>;
        template <typename _U1, typename _U2> static constexpr bool __assignable() {
            return __and_<is_assignable<_T1 &, _U1>, is_assignable<_T2 &, _U2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool __nothrow_assignable() {
            return __and_<is_nothrow_assignable<_T1 &, _U1>, is_nothrow_assignable<_T2 &, _U2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool __nothrow_constructible() {
            return __and_<is_nothrow_constructible<_T1, _U1>, is_nothrow_constructible<_T2, _U2>>::value;
        }
        static constexpr bool __nothrow_default_constructible() {
            return __and_<is_nothrow_default_constructible<_T1>, is_nothrow_default_constructible<_T2>>::value;
        }
        template <typename _U1> static constexpr bool __is_alloc_arg() {
            return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value;
        }
    public:
        template <bool _Dummy = true, _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited() {
        }
        template <bool _Dummy = true, _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited() {
        }
        template <bool _Dummy = true, _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__a1, __a2) {
        }
        template <bool _Dummy = true, _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__a1, __a2) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<type-parameter-0-0, type-parameter-0-1> &) = default
        tuple<type-parameter-0-0, type-parameter-0-1>(tuple<type-parameter-0-0, type-parameter-0-1> &&) = default
        template <typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__in.first, __in.second) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__in.first, __in.second) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        template <typename _Alloc, _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a) {
        }
        template <typename _Alloc, bool _Dummy = true, _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1, const _T2 &__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __a1, __a2) {
        }
        template <typename _Alloc, bool _Dummy = true, _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1, const _T2 &__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __a1, __a2) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        template <typename _Alloc> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<type-parameter-0-0, type-parameter-0-1> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<const std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited &>(__in)) {
        }
        template <typename _Alloc> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<type-parameter-0-0, type-parameter-0-1> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited &&>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const pair<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __in.first, __in.second) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const pair<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __in.first, __in.second) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, pair<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, pair<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        tuple<type-parameter-0-0, type-parameter-0-1> &operator=(__conditional_t<__assignable<const _T1 &, const _T2 &>(), const tuple<type-parameter-0-0, type-parameter-0-1> &, const std::__nonesuch &> __in) noexcept(__nothrow_assignable<const _T1 &, const _T2 &>()) {
            this->_M_assign(__in);
            return *this;
        }
        tuple<type-parameter-0-0, type-parameter-0-1> &operator=(__conditional_t<__assignable<_T1, _T2>(), tuple<type-parameter-0-0, type-parameter-0-1> &&, std::__nonesuch &&> __in) noexcept(__nothrow_assignable<_T1, _T2>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(const tuple<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>()) {
            this->_M_assign(__in);
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<_U1, _U2>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(tuple<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(const pair<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>()) {
            this->_M_head(*this) = __in.first;
            this->_M_tail(*this)._M_head(*this) = __in.second;
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<_U1, _U2>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(pair<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()) {
            this->_M_head(*this) = std::forward<_U1>(__in.first);
            this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
            return *this;
        }
        void swap(tuple<type-parameter-0-0, type-parameter-0-1> &__in) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value) {
            _Inherited::_M_swap(__in);
        }
    };
    template <typename ..._Elements> struct tuple_size<tuple<_Elements...>> : public integral_constant<std::size_t, sizeof...(_Elements)> {
    };
    template <std::size_t __i, typename ..._Types> struct tuple_element<__i, tuple<_Types...>> {
        static_assert(__i < sizeof...(_Types), "tuple index must be in range");
        using type = typename _Nth_type<__i, _Types...>::type;
    };
    template <std::size_t __i, typename _Head, typename ..._Tail> constexpr _Head &__get_helper(_Tuple_impl<__i, _Head, _Tail...> &__t) noexcept {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <std::size_t __i, typename _Head, typename ..._Tail> constexpr const _Head &__get_helper(const _Tuple_impl<__i, _Head, _Tail...> &__t) noexcept {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <std::size_t __i, typename ..._Types> __enable_if_t<(__i >= sizeof...(_Types))> __get_helper(const tuple<_Types...> &) = delete
    template <std::size_t __i, typename ..._Elements> constexpr __tuple_element_t<__i, tuple<_Elements...>> &get(tuple<_Elements...> &__t) noexcept {
        return std::__get_helper<__i>(__t);
    }
    template <std::size_t __i, typename ..._Elements> constexpr const __tuple_element_t<__i, tuple<_Elements...>> &get(const tuple<_Elements...> &__t) noexcept {
        return std::__get_helper<__i>(__t);
    }
    template <std::size_t __i, typename ..._Elements> constexpr __tuple_element_t<__i, tuple<_Elements...>> &&get(tuple<_Elements...> &&__t) noexcept {
        typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
        return std::forward<__element_type>(std::__get_helper<__i>(__t));
    }
    template <std::size_t __i, typename ..._Elements> constexpr const __tuple_element_t<__i, tuple<_Elements...>> &&get(const tuple<_Elements...> &&__t) noexcept {
        typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
        return std::forward<const __element_type>(std::__get_helper<__i>(__t));
    }
    template <std::size_t __i, typename ..._Elements> constexpr __enable_if_t<(__i >= sizeof...(_Elements))> get(const tuple<_Elements...> &) = delete
    template <typename _Tp, typename ..._Types> constexpr _Tp &get(tuple<_Types...> &__t) noexcept {
        constexpr std::size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::__get_helper<__idx>(__t);
    }
    template <typename _Tp, typename ..._Types> constexpr _Tp &&get(tuple<_Types...> &&__t) noexcept {
        constexpr std::size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::forward<_Tp>(std::__get_helper<__idx>(__t));
    }
    template <typename _Tp, typename ..._Types> constexpr const _Tp &get(const tuple<_Types...> &__t) noexcept {
        constexpr std::size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::__get_helper<__idx>(__t);
    }
    template <typename _Tp, typename ..._Types> constexpr const _Tp &&get(const tuple<_Types...> &&__t) noexcept {
        constexpr std::size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
    }
    template <typename _Tp, typename _Up, std::size_t __i, std::size_t __size> struct __tuple_compare {
        static constexpr bool __eq(const _Tp &__t, const _Up &__u) {
            return bool(std::get<__i>(__t) == std::get<__i>(__u)) && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
        }
        static constexpr bool __less(const _Tp &__t, const _Up &__u) {
            return bool(std::get<__i>(__t) < std::get<__i>(__u)) || (!bool(std::get<__i>(__u) < std::get<__i>(__t)) && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
        }
    };
    template <typename _Tp, typename _Up, std::size_t __size> struct __tuple_compare<_Tp, _Up, __size, __size> {
        static constexpr bool __eq(const _Tp &, const _Up &) {
            return true;
        }
        static constexpr bool __less(const _Tp &, const _Up &) {
            return false;
        }
    };
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator==(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u) {
        static_assert(sizeof...(_TElements) == sizeof...(_UElements), "tuple objects can only be compared if they have equal sizes.");
        using __compare = __tuple_compare<tuple<_TElements...>, tuple<_UElements...>, 0, sizeof...(_TElements)>;
        return __compare::__eq(__t, __u);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator<(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u) {
        static_assert(sizeof...(_TElements) == sizeof...(_UElements), "tuple objects can only be compared if they have equal sizes.");
        using __compare = __tuple_compare<tuple<_TElements...>, tuple<_UElements...>, 0, sizeof...(_TElements)>;
        return __compare::__less(__t, __u);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator!=(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u) {
        return !(__t == __u);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator>(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u) {
        return __u < __t;
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator<=(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u) {
        return !(__u < __t);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator>=(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u) {
        return !(__t < __u);
    }
    template <typename ..._Elements> constexpr tuple<typename __decay_and_strip<_Elements>::__type...> make_tuple(_Elements &&...__args) {
        typedef tuple<typename __decay_and_strip<_Elements>::__type...> __result_type;
        return __result_type(std::forward<_Elements>(__args)...);
    }
    template <typename ..._Elements> constexpr tuple<_Elements &&...> forward_as_tuple(_Elements &&...__args) noexcept {
        return tuple<_Elements &&...>(std::forward<_Elements>(__args)...);
    }
    template <typename _Tp, std::size_t _Nm> struct array;
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr _Tp &get(array<_Tp, _Nm> &) noexcept;
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr _Tp &&get(array<_Tp, _Nm> &&) noexcept;
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr const _Tp &get(const array<_Tp, _Nm> &) noexcept;
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr const _Tp &&get(const array<_Tp, _Nm> &&) noexcept;
    template <std::size_t, typename, typename, std::size_t> struct __make_tuple_impl;
    template <std::size_t _Idx, typename _Tuple, typename ..._Tp, std::size_t _Nm> struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm> : __make_tuple_impl<_Idx + 1, tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>, _Tuple, _Nm> {
    };
    template <std::size_t _Nm, typename _Tuple, typename ..._Tp> struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm> {
        typedef tuple<_Tp...> __type;
    };
    template <typename _Tuple> struct __do_make_tuple : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value> {
    };
    template <typename _Tuple> struct __make_tuple : public __do_make_tuple<__remove_cvref_t<_Tuple>> {
    };
    template <typename ...> struct __combine_tuples;
    template<> struct __combine_tuples<> {
        typedef tuple<> __type;
    };
    template <typename ..._Ts> struct __combine_tuples<tuple<_Ts...>> {
        typedef tuple<_Ts...> __type;
    };
    template <typename ..._T1s, typename ..._T2s, typename ..._Rem> struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...> {
        typedef typename __combine_tuples<tuple<_T1s..., _T2s...>, _Rem...>::__type __type;
    };
    template <typename ..._Tpls> struct __tuple_cat_result {
        typedef typename __combine_tuples<typename __make_tuple<_Tpls>::__type...>::__type __type;
    };
    template <typename ...> struct __make_1st_indices;
    template<> struct __make_1st_indices<> {
        typedef _Index_tuple<> __type;
    };
    template <typename _Tp, typename ..._Tpls> struct __make_1st_indices<_Tp, _Tpls...> {
        typedef typename _Build_index_tuple<tuple_size<typename remove_reference<_Tp>::type>::value>::__type __type;
    };
    template <typename _Ret, typename _Indices, typename ..._Tpls> struct __tuple_concater;
    template <typename _Ret, std::size_t ..._Is, typename _Tp, typename ..._Tpls> struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...> {
        template <typename ..._Us> static constexpr _Ret _S_do(_Tp &&__tp, _Tpls &&...__tps, _Us &&...__us) {
            typedef typename __make_1st_indices<_Tpls...>::__type __idx;
            typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
            return __next::_S_do(std::forward<_Tpls>(__tps)..., std::forward<_Us>(__us)..., std::get<_Is>(std::forward<_Tp>(__tp))...);
        }
    };
    template <typename _Ret> struct __tuple_concater<_Ret, _Index_tuple<>> {
        template <typename ..._Us> static constexpr _Ret _S_do(_Us &&...__us) {
            return _Ret(std::forward<_Us>(__us)...);
        }
    };
    template <typename ..._Tps> struct __is_tuple_like_impl<tuple<_Tps...>> : std::true_type {
    };
    template <typename ..._Tpls, typename = typename enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type> constexpr auto tuple_cat(_Tpls &&...__tpls) -> typename __tuple_cat_result<_Tpls...>::__type {
        typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
        typedef typename __make_1st_indices<_Tpls...>::__type __idx;
        typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
        return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }
    template <typename ..._Elements> constexpr tuple<_Elements &...> tie(_Elements &...__args) noexcept {
        return tuple<_Elements &...>(__args...);
    }
    template <typename ..._Elements> inline typename enable_if<__and_<__is_swappable<_Elements>...>::value>::type swap(tuple<_Elements...> &__x, tuple<_Elements...> &__y) noexcept(noexcept(__x.swap(__y))) {
        __x.swap(__y);
    }
    template <typename ..._Elements> typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type swap(tuple<_Elements...> &, tuple<_Elements...> &) = delete
    struct _Swallow_assign {
        template <class _Tp> constexpr const std::_Swallow_assign &operator=(const _Tp &) const {
            return *this;
        }
    };
    constexpr std::_Swallow_assign ignore{};
    template <typename ..._Types, typename _Alloc> struct uses_allocator<tuple<_Types...>, _Alloc> : std::true_type {
    };
    template <class _T1, class _T2> template <typename ..._Args1, typename ..._Args2> inline pair<_T1, _T2>::pair<_T1, _T2>(std::piecewise_construct_t, tuple<_Args1...> __first, tuple<_Args2...> __second) : pair<_T1, _T2>(__first, __second, typename _Build_index_tuple<sizeof...(_Args1)>::__type(), typename _Build_index_tuple<sizeof...(_Args2)>::__type()) {
    }
    template <class _T1, class _T2> template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> inline pair<_T1, _T2>::pair<_T1, _T2>(tuple<_Args1...> &__tuple1, tuple<_Args2...> &__tuple2, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>) : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...), second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...) {
    }
}
namespace std {
    template <typename> class auto_ptr;
    template <typename _Tp> struct default_delete {
        default_delete<_Tp>() noexcept = default
        template <typename _Up, typename = _Require<is_convertible<_Up *, _Tp *>>> default_delete<_Tp>(const default_delete<_Up> &) noexcept {
        }
        void operator()(_Tp *__ptr) const {
            static_assert(!is_void<_Tp>::value, "can't delete pointer to incomplete type");
            static_assert(sizeof(_Tp) > 0, "can't delete pointer to incomplete type");
            delete __ptr;
        }
    };
    template <typename _Tp> struct default_delete<_Tp[]> {
    public:
        default_delete<type-parameter-0-0[]>() noexcept = default
        template <typename _Up, typename = _Require<is_convertible<_Up (*)[], _Tp (*)[]>>> default_delete<type-parameter-0-0[]>(const default_delete<_Up[]> &) noexcept {
        }
        template <typename _Up> typename enable_if<is_convertible<_Up (*)[], _Tp (*)[]>::value>::type operator()(_Up *__ptr) const {
            static_assert(sizeof(_Tp) > 0, "can't delete pointer to incomplete type");
            delete [] __ptr;
        }
    };
    template <typename _Tp, typename _Dp> class __uniq_ptr_impl {
        template <typename _Up, typename _Ep, typename = void> struct _Ptr {
            using type = _Up *;
        };
        template <typename _Up, typename _Ep> struct _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>> {
            using type = typename remove_reference<_Ep>::type::pointer;
        };
    public:
        using _DeleterConstraint = enable_if<__and_<__not_<is_pointer<_Dp>>, is_default_constructible<_Dp>>::value>;
        using pointer = typename _Ptr<_Tp, _Dp>::type;
        static_assert(!is_rvalue_reference<_Dp>::value, "unique_ptr's deleter type must be a function object type or an lvalue reference type");
        __uniq_ptr_impl<_Tp, _Dp>() = default
        __uniq_ptr_impl<_Tp, _Dp>(std::__uniq_ptr_impl::pointer __p) : _M_t() {
            _M_ptr() = __p;
        }
        template <typename _Del> __uniq_ptr_impl<_Tp, _Dp>(std::__uniq_ptr_impl::pointer __p, _Del &&__d) : _M_t(__p, std::forward<_Del>(__d)) {
        }
        __uniq_ptr_impl<_Tp, _Dp>(__uniq_ptr_impl<_Tp, _Dp> &&__u) noexcept : _M_t(std::move(__u._M_t)) {
            __u._M_ptr() = nullptr;
        }
        __uniq_ptr_impl<_Tp, _Dp> &operator=(__uniq_ptr_impl<_Tp, _Dp> &&__u) noexcept {
            this->reset(__u.release());
            _M_deleter() = std::forward<_Dp>(__u._M_deleter());
            return *this;
        }
        std::__uniq_ptr_impl::pointer &_M_ptr() noexcept {
            return std::get<0>(this->_M_t);
        }
        std::__uniq_ptr_impl::pointer _M_ptr() const noexcept {
            return std::get<0>(this->_M_t);
        }
        _Dp &_M_deleter() noexcept {
            return std::get<1>(this->_M_t);
        }
        const _Dp &_M_deleter() const noexcept {
            return std::get<1>(this->_M_t);
        }
        void reset(std::__uniq_ptr_impl::pointer __p) noexcept {
            const std::__uniq_ptr_impl::pointer __old_p = _M_ptr();
            _M_ptr() = __p;
            if (__old_p)
                _M_deleter()(__old_p);
        }
        std::__uniq_ptr_impl::pointer release() noexcept {
            std::__uniq_ptr_impl::pointer __p = _M_ptr();
            _M_ptr() = nullptr;
            return __p;
        }
        void swap(__uniq_ptr_impl<_Tp, _Dp> &__rhs) noexcept {
            using std::swap;
            swap(this->_M_ptr(), __rhs._M_ptr());
            swap(this->_M_deleter(), __rhs._M_deleter());
        }
    private:
        tuple<std::__uniq_ptr_impl::pointer, _Dp> _M_t;
    };
    template <typename _Tp, typename _Dp, bool = is_move_constructible<_Dp>::value, bool = is_move_assignable<_Dp>::value> struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp> {
        using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl<type-parameter-0-0, type-parameter-0-1>;
        __uniq_ptr_data<_Tp, _Dp, , >(__uniq_ptr_data<_Tp, _Dp, , > &&) = default
        __uniq_ptr_data<_Tp, _Dp, , > &operator=(__uniq_ptr_data<_Tp, _Dp, , > &&) = default
    };
    template <typename _Tp, typename _Dp> struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp> {
        using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl<type-parameter-0-0, type-parameter-0-1>;
        __uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, true, false>(__uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, true, false> &&) = default
        __uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, true, false> &operator=(__uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, true, false> &&) = delete
    };
    template <typename _Tp, typename _Dp> struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp> {
        using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl<type-parameter-0-0, type-parameter-0-1>;
        __uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, true>(__uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, true> &&) = delete
        __uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, true> &operator=(__uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, true> &&) = default
    };
    template <typename _Tp, typename _Dp> struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp> {
        using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl<type-parameter-0-0, type-parameter-0-1>;
        __uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, false>(__uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, false> &&) = delete
        __uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, false> &operator=(__uniq_ptr_data<type-parameter-0-0, type-parameter-0-1, false, false> &&) = delete
    };
    template <typename _Tp, typename _Dp = default_delete<_Tp>> class unique_ptr {
        template <typename _Up> using _DeleterConstraint = typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;
        __uniq_ptr_data<_Tp, _Dp> _M_t;
    public:
        using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
        using element_type = _Tp;
        using deleter_type = _Dp;
    private:
        template <typename _Up, typename _Ep> using __safe_conversion_up = __and_<is_convertible<typename unique_ptr<_Up, _Ep>::pointer, std::unique_ptr::pointer>, __not_<is_array<_Up>>>;
    public:
        template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>> constexpr unique_ptr<_Tp, _Dp>() noexcept : _M_t() {
        }
        template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>> explicit unique_ptr<_Tp, _Dp>(std::unique_ptr::pointer __p) noexcept : _M_t(__p) {
        }
        template <typename _Del = std::unique_ptr::deleter_type, typename = _Require<is_copy_constructible<_Del>>> unique_ptr<_Tp, _Dp>(std::unique_ptr::pointer __p, const std::unique_ptr::deleter_type &__d) noexcept : _M_t(__p, __d) {
        }
        template <typename _Del = std::unique_ptr::deleter_type, typename = _Require<is_move_constructible<_Del>>> unique_ptr<_Tp, _Dp>(std::unique_ptr::pointer __p, __enable_if_t<!is_lvalue_reference<_Del>::value, _Del &&> __d) noexcept : _M_t(__p, std::move(__d)) {
        }
        template <typename _Del = std::unique_ptr::deleter_type, typename _DelUnref = typename remove_reference<_Del>::type> unique_ptr<_Tp, _Dp>(std::unique_ptr::pointer, __enable_if_t<is_lvalue_reference<_Del>::value, _DelUnref &&>) = delete
        template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>> constexpr unique_ptr<_Tp, _Dp>(std::nullptr_t) noexcept : _M_t() {
        }
        unique_ptr<_Tp, _Dp>(unique_ptr<_Tp, _Dp> &&) = default
        template <typename _Up, typename _Ep, typename = _Require<__safe_conversion_up<_Up, _Ep>, __conditional_t<is_reference<_Dp>::value, is_same<_Ep, _Dp>, is_convertible<_Ep, _Dp>>>> unique_ptr<_Tp, _Dp>(unique_ptr<_Up, _Ep> &&__u) noexcept : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter())) {
        }
        template <typename _Up, typename = _Require<is_convertible<_Up *, _Tp *>, is_same<_Dp, default_delete<_Tp>>>> unique_ptr<_Tp, _Dp>(auto_ptr<_Up> &&__u) noexcept;
        ~unique_ptr<_Tp, _Dp>() noexcept {
            static_assert(__is_invocable<deleter_type &, pointer>::value, "unique_ptr's deleter must be invocable with a pointer");
            auto &__ptr = this->_M_t._M_ptr();
            if (__ptr != nullptr)
                get_deleter()(std::move(__ptr));
            __ptr = std::unique_ptr::pointer();
        }
        unique_ptr<_Tp, _Dp> &operator=(unique_ptr<_Tp, _Dp> &&) = default
        template <typename _Up, typename _Ep> typename enable_if<__and_<__safe_conversion_up<_Up, _Ep>, is_assignable<deleter_type &, _Ep &&>>::value, unique_ptr<_Tp, _Dp> &>::type operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
            this->reset(__u.release());
            get_deleter() = std::forward<_Ep>(__u.get_deleter());
            return *this;
        }
        unique_ptr<_Tp, _Dp> &operator=(std::nullptr_t) noexcept {
            this->reset();
            return *this;
        }
        typename add_lvalue_reference<element_type>::type operator*() const noexcept(noexcept(*std::declval<std::unique_ptr::pointer>())) {
            do {
                if (std::__is_constant_evaluated() && !bool(this->get() != std::unique_ptr::pointer()))
                    __builtin_unreachable();
            } while (false);
            return *this->get();
        }
        std::unique_ptr::pointer operator->() const noexcept {
            ;
            return this->get();
        }
        std::unique_ptr::pointer get() const noexcept {
            return this->_M_t._M_ptr();
        }
        std::unique_ptr::deleter_type &get_deleter() noexcept {
            return this->_M_t._M_deleter();
        }
        const std::unique_ptr::deleter_type &get_deleter() const noexcept {
            return this->_M_t._M_deleter();
        }
        explicit operator bool() const noexcept {
            return this->get() == std::unique_ptr::pointer() ? false : true;
        }
        std::unique_ptr::pointer release() noexcept {
            return this->_M_t.release();
        }
        void reset(std::unique_ptr::pointer __p = std::unique_ptr::pointer()) noexcept {
            static_assert(__is_invocable<deleter_type &, pointer>::value, "unique_ptr's deleter must be invocable with a pointer");
            this->_M_t.reset(std::move(__p));
        }
        void swap(unique_ptr<_Tp, _Dp> &__u) noexcept {
            static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
            this->_M_t.swap(__u._M_t);
        }
        unique_ptr<_Tp, _Dp>(const unique_ptr<_Tp, _Dp> &) = delete
        unique_ptr<_Tp, _Dp> &operator=(const unique_ptr<_Tp, _Dp> &) = delete
    };
    template <typename _Tp, typename _Dp> class unique_ptr<_Tp[], _Dp> {
        template <typename _Up> using _DeleterConstraint = typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;
        __uniq_ptr_data<_Tp, _Dp> _M_t;
        template <typename _Up> using __remove_cv = typename remove_cv<_Up>::type;
        template <typename _Up> using __is_derived_Tp = __and_<is_base_of<_Tp, _Up>, __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>>>;
    public:
        using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
        using element_type = _Tp;
        using deleter_type = _Dp;
        template <typename _Up, typename _Ep, typename _UPtr = unique_ptr<_Up, _Ep>, typename _UP_pointer = typename _UPtr::pointer, typename _UP_element_type = typename _UPtr::element_type> using __safe_conversion_up = __and_<is_array<_Up>, is_same<std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer, std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::element_type *>, is_same<_UP_pointer, _UP_element_type *>, is_convertible<_UP_element_type (*)[], std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::element_type (*)[]>>;
        template <typename _Up> using __safe_conversion_raw = __and_<__or_<__or_<is_same<_Up, std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer>, is_same<_Up, std::nullptr_t>>, __and_<is_pointer<_Up>, is_same<std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer, std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::element_type *>, is_convertible<typename remove_pointer<_Up>::type (*)[], std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::element_type (*)[]>>>>;
        template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>> constexpr unique_ptr<type-parameter-0-0[], type-parameter-0-1>() noexcept : _M_t() {
        }
        template <typename _Up, typename _Vp = _Dp, typename = _DeleterConstraint<_Vp>, typename = typename enable_if<__safe_conversion_raw<_Up>::value, bool>::type> explicit unique_ptr<type-parameter-0-0[], type-parameter-0-1>(_Up __p) noexcept : _M_t(__p) {
        }
        template <typename _Up, typename _Del = std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::deleter_type, typename = _Require<__safe_conversion_raw<_Up>, is_copy_constructible<_Del>>> unique_ptr<type-parameter-0-0[], type-parameter-0-1>(_Up __p, const std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::deleter_type &__d) noexcept : _M_t(__p, __d) {
        }
        template <typename _Up, typename _Del = std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::deleter_type, typename = _Require<__safe_conversion_raw<_Up>, is_move_constructible<_Del>>> unique_ptr<type-parameter-0-0[], type-parameter-0-1>(_Up __p, __enable_if_t<!is_lvalue_reference<_Del>::value, _Del &&> __d) noexcept : _M_t(std::move(__p), std::move(__d)) {
        }
        template <typename _Up, typename _Del = std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::deleter_type, typename _DelUnref = typename remove_reference<_Del>::type, typename = _Require<__safe_conversion_raw<_Up>>> unique_ptr<type-parameter-0-0[], type-parameter-0-1>(_Up, __enable_if_t<is_lvalue_reference<_Del>::value, _DelUnref &&>) = delete
        unique_ptr<type-parameter-0-0[], type-parameter-0-1>(unique_ptr<type-parameter-0-0[], type-parameter-0-1> &&) = default
        template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>> constexpr unique_ptr<type-parameter-0-0[], type-parameter-0-1>(std::nullptr_t) noexcept : _M_t() {
        }
        template <typename _Up, typename _Ep, typename = _Require<__safe_conversion_up<_Up, _Ep>, __conditional_t<is_reference<_Dp>::value, is_same<_Ep, _Dp>, is_convertible<_Ep, _Dp>>>> unique_ptr<type-parameter-0-0[], type-parameter-0-1>(unique_ptr<_Up, _Ep> &&__u) noexcept : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter())) {
        }
        ~unique_ptr<type-parameter-0-0[], type-parameter-0-1>() {
            auto &__ptr = this->_M_t._M_ptr();
            if (__ptr != nullptr)
                get_deleter()(__ptr);
            __ptr = std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer();
        }
        unique_ptr<type-parameter-0-0[], type-parameter-0-1> &operator=(unique_ptr<type-parameter-0-0[], type-parameter-0-1> &&) = default
        template <typename _Up, typename _Ep> typename enable_if<__and_<__safe_conversion_up<_Up, _Ep>, is_assignable<deleter_type &, _Ep &&>>::value, unique_ptr<type-parameter-0-0[], type-parameter-0-1> &>::type operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
            reset(__u.release());
            get_deleter() = std::forward<_Ep>(__u.get_deleter());
            return *this;
        }
        unique_ptr<type-parameter-0-0[], type-parameter-0-1> &operator=(std::nullptr_t) noexcept {
            reset();
            return *this;
        }
        typename std::add_lvalue_reference<element_type>::type operator[](std::size_t __i) const {
            do {
                if (std::__is_constant_evaluated() && !bool(this->get() != std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer()))
                    __builtin_unreachable();
            } while (false);
            return this->get()[__i];
        }
        std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer get() const noexcept {
            return this->_M_t._M_ptr();
        }
        std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::deleter_type &get_deleter() noexcept {
            return this->_M_t._M_deleter();
        }
        const std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::deleter_type &get_deleter() const noexcept {
            return this->_M_t._M_deleter();
        }
        explicit operator bool() const noexcept {
            return this->get() == std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer() ? false : true;
        }
        std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer release() noexcept {
            return this->_M_t.release();
        }
        template <typename _Up, typename = _Require<__or_<is_same<_Up, std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer>, __and_<is_same<std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer, std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::element_type *>, is_pointer<_Up>, is_convertible<typename remove_pointer<_Up>::type (*)[], std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::element_type (*)[]>>>>> void reset(_Up __p) noexcept {
            this->_M_t.reset(std::move(__p));
        }
        void reset(std::nullptr_t = nullptr) noexcept {
            reset(std::unique_ptr<type-parameter-0-0[], type-parameter-0-1>::pointer());
        }
        void swap(unique_ptr<type-parameter-0-0[], type-parameter-0-1> &__u) noexcept {
            static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
            this->_M_t.swap(__u._M_t);
        }
        unique_ptr<type-parameter-0-0[], type-parameter-0-1>(const unique_ptr<type-parameter-0-0[], type-parameter-0-1> &) = delete
        unique_ptr<type-parameter-0-0[], type-parameter-0-1> &operator=(const unique_ptr<type-parameter-0-0[], type-parameter-0-1> &) = delete
    };
    template <typename _Tp, typename _Dp> inline typename enable_if<__is_swappable<_Dp>::value>::type swap(unique_ptr<_Tp, _Dp> &__x, unique_ptr<_Tp, _Dp> &__y) noexcept {
        __x.swap(__y);
    }
    template <typename _Tp, typename _Dp> typename enable_if<!__is_swappable<_Dp>::value>::type swap(unique_ptr<_Tp, _Dp> &, unique_ptr<_Tp, _Dp> &) = delete
    template <typename _Tp, typename _Dp, typename _Up, typename _Ep> inline bool operator==(const unique_ptr<_Tp, _Dp> &__x, const unique_ptr<_Up, _Ep> &__y) {
        return __x.get() == __y.get();
    }
    template <typename _Tp, typename _Dp> inline bool operator==(const unique_ptr<_Tp, _Dp> &__x, std::nullptr_t) noexcept {
        return !__x;
    }
    template <typename _Tp, typename _Dp> inline bool operator==(std::nullptr_t, const unique_ptr<_Tp, _Dp> &__x) noexcept {
        return !__x;
    }
    template <typename _Tp, typename _Dp, typename _Up, typename _Ep> inline bool operator!=(const unique_ptr<_Tp, _Dp> &__x, const unique_ptr<_Up, _Ep> &__y) {
        return __x.get() != __y.get();
    }
    template <typename _Tp, typename _Dp> inline bool operator!=(const unique_ptr<_Tp, _Dp> &__x, std::nullptr_t) noexcept {
        return (bool)__x;
    }
    template <typename _Tp, typename _Dp> inline bool operator!=(std::nullptr_t, const unique_ptr<_Tp, _Dp> &__x) noexcept {
        return (bool)__x;
    }
    template <typename _Tp, typename _Dp, typename _Up, typename _Ep> inline bool operator<(const unique_ptr<_Tp, _Dp> &__x, const unique_ptr<_Up, _Ep> &__y) {
        typedef typename std::common_type<typename unique_ptr<_Tp, _Dp>::pointer, typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
        return std::less<_CT>()(__x.get(), __y.get());
    }
    template <typename _Tp, typename _Dp> inline bool operator<(const unique_ptr<_Tp, _Dp> &__x, std::nullptr_t) {
        return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(), nullptr);
    }
    template <typename _Tp, typename _Dp> inline bool operator<(std::nullptr_t, const unique_ptr<_Tp, _Dp> &__x) {
        return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr, __x.get());
    }
    template <typename _Tp, typename _Dp, typename _Up, typename _Ep> inline bool operator<=(const unique_ptr<_Tp, _Dp> &__x, const unique_ptr<_Up, _Ep> &__y) {
        return !(__y < __x);
    }
    template <typename _Tp, typename _Dp> inline bool operator<=(const unique_ptr<_Tp, _Dp> &__x, std::nullptr_t) {
        return !(nullptr < __x);
    }
    template <typename _Tp, typename _Dp> inline bool operator<=(std::nullptr_t, const unique_ptr<_Tp, _Dp> &__x) {
        return !(__x < nullptr);
    }
    template <typename _Tp, typename _Dp, typename _Up, typename _Ep> inline bool operator>(const unique_ptr<_Tp, _Dp> &__x, const unique_ptr<_Up, _Ep> &__y) {
        return (__y < __x);
    }
    template <typename _Tp, typename _Dp> inline bool operator>(const unique_ptr<_Tp, _Dp> &__x, std::nullptr_t) {
        return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr, __x.get());
    }
    template <typename _Tp, typename _Dp> inline bool operator>(std::nullptr_t, const unique_ptr<_Tp, _Dp> &__x) {
        return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(), nullptr);
    }
    template <typename _Tp, typename _Dp, typename _Up, typename _Ep> inline bool operator>=(const unique_ptr<_Tp, _Dp> &__x, const unique_ptr<_Up, _Ep> &__y) {
        return !(__x < __y);
    }
    template <typename _Tp, typename _Dp> inline bool operator>=(const unique_ptr<_Tp, _Dp> &__x, std::nullptr_t) {
        return !(__x < nullptr);
    }
    template <typename _Tp, typename _Dp> inline bool operator>=(std::nullptr_t, const unique_ptr<_Tp, _Dp> &__x) {
        return !(nullptr < __x);
    }
    template <typename _Up, typename _Ptr = typename _Up::pointer, bool = __poison_hash<_Ptr>::__enable_hash_call> struct __uniq_ptr_hash : private __poison_hash<_Ptr> {
        std::size_t operator()(const _Up &__u) const noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>()))) {
            return hash<_Ptr>()(__u.get());
        }
    };
    template <typename _Up, typename _Ptr> struct __uniq_ptr_hash<_Up, _Ptr, false> : private __poison_hash<_Ptr> {
    };
    template <typename _Tp, typename _Dp> struct hash<unique_ptr<_Tp, _Dp>> : public __hash_base<std::size_t, unique_ptr<_Tp, _Dp>>, public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>> {
    };
    namespace __detail {
        template <typename _Tp> struct _MakeUniq {
            typedef unique_ptr<_Tp> __single_object;
        };
        template <typename _Tp> struct _MakeUniq<_Tp[]> {
            typedef unique_ptr<_Tp[]> __array;
        };
        template <typename _Tp, std::size_t _Bound> struct _MakeUniq<_Tp[_Bound]> {
            struct __invalid_type {
            };
        };
        template <typename _Tp> using __unique_ptr_t = typename _MakeUniq<_Tp>::__single_object;
        template <typename _Tp> using __unique_ptr_array_t = typename _MakeUniq<_Tp>::__array;
        template <typename _Tp> using __invalid_make_unique_t = typename _MakeUniq<_Tp>::__invalid_type;
    }
    template <typename _Tp, typename ..._Args> inline __detail::__unique_ptr_t<_Tp> make_unique(_Args &&...__args) {
        return unique_ptr<_Tp>(new _Tp((std::forward<_Args>(__args)...)));
    }
    template <typename _Tp> inline __detail::__unique_ptr_array_t<_Tp> make_unique(std::size_t __num) {
        return unique_ptr<_Tp>(new remove_extent_t<_Tp> [__num](()));
    }
    template <typename _Tp, typename ..._Args> __detail::__invalid_make_unique_t<_Tp> make_unique(_Args &&...) = delete
}
namespace std {
    template <typename _Alloc> struct __allocated_ptr {
        using pointer = typename allocator_traits<_Alloc>::pointer;
        using value_type = typename allocator_traits<_Alloc>::value_type;
        __allocated_ptr<_Alloc>(_Alloc &__a, std::__allocated_ptr::pointer __ptr) noexcept : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr) {
        }
        template <typename _Ptr, typename _Req = _Require<is_same<_Ptr, std::__allocated_ptr::value_type *>>> __allocated_ptr<_Alloc>(_Alloc &__a, _Ptr __ptr) : _M_alloc(std::__addressof(__a)), _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr)) {
        }
        __allocated_ptr<_Alloc>(__allocated_ptr<_Alloc> &&__gd) noexcept : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr) {
            __gd._M_ptr = nullptr;
        }
        ~__allocated_ptr<_Alloc>() {
            if (this->_M_ptr != nullptr)
                std::allocator_traits<_Alloc>::deallocate(*this->_M_alloc, this->_M_ptr, 1);
        }
        __allocated_ptr<_Alloc> &operator=(std::nullptr_t) noexcept {
            this->_M_ptr = nullptr;
            return *this;
        }
        std::__allocated_ptr::value_type *get() {
            return std::__to_address(this->_M_ptr);
        }
    private:
        _Alloc *_M_alloc;
        std::__allocated_ptr::pointer _M_ptr;
    };
    template <typename _Alloc> __allocated_ptr<_Alloc> __allocate_guarded(_Alloc &__a) {
        return {__a, std::allocator_traits<_Alloc>::allocate(__a, 1)};
    }
}
namespace __gnu_cxx {
    template <typename _Tp> struct __aligned_membuf {
        struct _Tp2 {
            _Tp _M_t;
        };
        unsigned char _M_storage[sizeof(_Tp)] alignas(__alignof (_Tp2::_M_t));
        __aligned_membuf<_Tp>() = default
        __aligned_membuf<_Tp>(std::nullptr_t) {
        }
        void *_M_addr() noexcept {
            return static_cast<void *>(&this->_M_storage);
        }
        const void *_M_addr() const noexcept {
            return static_cast<const void *>(&this->_M_storage);
        }
        _Tp *_M_ptr() noexcept {
            return static_cast<_Tp *>(_M_addr());
        }
        const _Tp *_M_ptr() const noexcept {
            return static_cast<const _Tp *>(_M_addr());
        }
    };
    template <typename _Tp> struct __aligned_buffer : std::aligned_storage<sizeof(_Tp), __alignof(_Tp)> {
        typename std::aligned_storage<sizeof(_Tp), __alignof(_Tp)>::type _M_storage;
        __aligned_buffer<_Tp>() = default
        __aligned_buffer<_Tp>(std::nullptr_t) {
        }
        void *_M_addr() noexcept {
            return static_cast<void *>(&this->_M_storage);
        }
        const void *_M_addr() const noexcept {
            return static_cast<const void *>(&this->_M_storage);
        }
        _Tp *_M_ptr() noexcept {
            return static_cast<_Tp *>(_M_addr());
        }
        const _Tp *_M_ptr() const noexcept {
            return static_cast<const _Tp *>(_M_addr());
        }
    };
}
namespace __gnu_cxx {
    enum _Lock_policy {
        _S_single,
        _S_mutex,
        _S_atomic
    };
    static const __gnu_cxx::_Lock_policy __default_lock_policy = _S_atomic;
    class __concurrence_lock_error : public std::exception {
    public:
        virtual const char *what() const throw() {
            return "__gnu_cxx::__concurrence_lock_error";
        }
    };
    class __concurrence_unlock_error : public std::exception {
    public:
        virtual const char *what() const throw() {
            return "__gnu_cxx::__concurrence_unlock_error";
        }
    };
    class __concurrence_broadcast_error : public std::exception {
    public:
        virtual const char *what() const throw() {
            return "__gnu_cxx::__concurrence_broadcast_error";
        }
    };
    class __concurrence_wait_error : public std::exception {
    public:
        virtual const char *what() const throw() {
            return "__gnu_cxx::__concurrence_wait_error";
        }
    };
    inline void __throw_concurrence_lock_error() {
        (throw (__gnu_cxx::__concurrence_lock_error()));
    }
    inline void __throw_concurrence_unlock_error() {
        (throw (__gnu_cxx::__concurrence_unlock_error()));
    }
    inline void __throw_concurrence_broadcast_error() {
        (throw (__gnu_cxx::__concurrence_broadcast_error()));
    }
    inline void __throw_concurrence_wait_error() {
        (throw (__gnu_cxx::__concurrence_wait_error()));
    }
    class __mutex {
    private:
        __gthread_mutex_t _M_mutex = {{0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, {0, 0}}};
        __mutex(const __gnu_cxx::__mutex &);
        __gnu_cxx::__mutex &operator=(const __gnu_cxx::__mutex &);
    public:
        __mutex() {
        }
        void lock() {
            if (__gthread_active_p()) {
                if (__gthread_mutex_lock(&this->_M_mutex) != 0)
                    __throw_concurrence_lock_error();
            }
        }
        void unlock() {
            if (__gthread_active_p()) {
                if (__gthread_mutex_unlock(&this->_M_mutex) != 0)
                    __throw_concurrence_unlock_error();
            }
        }
        __gthread_mutex_t *gthread_mutex() {
            return &this->_M_mutex;
        }
    };
    class __recursive_mutex {
    private:
        __gthread_recursive_mutex_t _M_mutex = {{0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, {0, 0}}};
        __recursive_mutex(const __gnu_cxx::__recursive_mutex &);
        __gnu_cxx::__recursive_mutex &operator=(const __gnu_cxx::__recursive_mutex &);
    public:
        __recursive_mutex() {
        }
        void lock() {
            if (__gthread_active_p()) {
                if (__gthread_recursive_mutex_lock(&this->_M_mutex) != 0)
                    __throw_concurrence_lock_error();
            }
        }
        void unlock() {
            if (__gthread_active_p()) {
                if (__gthread_recursive_mutex_unlock(&this->_M_mutex) != 0)
                    __throw_concurrence_unlock_error();
            }
        }
        __gthread_recursive_mutex_t *gthread_recursive_mutex() {
            return &this->_M_mutex;
        }
    };
    class __scoped_lock {
    public:
        typedef __gnu_cxx::__mutex __mutex_type;
    private:
        __gnu_cxx::__scoped_lock::__mutex_type &_M_device;
        __scoped_lock(const __gnu_cxx::__scoped_lock &);
        __gnu_cxx::__scoped_lock &operator=(const __gnu_cxx::__scoped_lock &);
    public:
        explicit __scoped_lock(__gnu_cxx::__scoped_lock::__mutex_type &__name) : _M_device(__name) {
            this->_M_device.lock();
        }
        ~__scoped_lock() throw() {
            this->_M_device.unlock();
        }
    };
    class __cond {
    private:
        __gthread_cond_t _M_cond = {{{0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0}}};
        __cond(const __gnu_cxx::__cond &);
        __gnu_cxx::__cond &operator=(const __gnu_cxx::__cond &);
    public:
        __cond() {
        }
        void broadcast() {
            if (__gthread_active_p()) {
                if (__gthread_cond_broadcast(&this->_M_cond) != 0)
                    __throw_concurrence_broadcast_error();
            }
        }
        void wait(__gnu_cxx::__mutex *mutex) {
            {
                if (__gthread_cond_wait(&this->_M_cond, mutex->gthread_mutex()) != 0)
                    __throw_concurrence_wait_error();
            }
        }
        void wait_recursive(__gnu_cxx::__recursive_mutex *mutex) {
            {
                if (__gthread_cond_wait_recursive(&this->_M_cond, mutex->gthread_recursive_mutex()) != 0)
                    __throw_concurrence_wait_error();
            }
        }
    };
}
namespace std {
    template <typename> class auto_ptr;
    class bad_weak_ptr : public std::exception {
    public:
        virtual const char *what() const noexcept;
        virtual ~bad_weak_ptr() noexcept;
    };
    inline void __throw_bad_weak_ptr() {
        (throw (std::bad_weak_ptr()));
    }
    using __gnu_cxx::_Lock_policy;
    using __gnu_cxx::__default_lock_policy;
    using __gnu_cxx::_S_single;
    using __gnu_cxx::_S_mutex;
    using __gnu_cxx::_S_atomic;
    template <__gnu_cxx::_Lock_policy _Lp> class _Mutex_base {
    protected:
        enum {
            _S_need_barriers = 0
        };
    };
    template<> class _Mutex_base<__gnu_cxx::_S_single> {
    protected:
        enum {
            _S_need_barriers = 0
        };
    };
    template<> class _Mutex_base<__gnu_cxx::_S_atomic> {
    protected:
        enum {
            _S_need_barriers = 0
        };
    };
    template<> class _Mutex_base<_S_mutex> : public __gnu_cxx::__mutex {
    protected:
        enum {
            _S_need_barriers = 1
        };
    };
    template <__gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class _Sp_counted_base : public _Mutex_base<_Lp> {
    public:
        _Sp_counted_base<_Lp>() noexcept : _M_use_count(1), _M_weak_count(1) {
        }
        virtual ~_Sp_counted_base<_Lp>() noexcept {
        }
        virtual void _M_dispose() noexcept = 0;
        virtual void _M_destroy() noexcept {
            delete this;
        }
        virtual void *_M_get_deleter(const std::type_info &) noexcept = 0;
        void _M_add_ref_copy() {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_use_count, 1);
        }
        void _M_add_ref_lock() {
            if (!this->_M_add_ref_lock_nothrow())
                __throw_bad_weak_ptr();
        }
        bool _M_add_ref_lock_nothrow() noexcept;
        void _M_release() noexcept;
        void _M_release_last_use() noexcept {
            ;
            this->_M_dispose();
            if (_Mutex_base<_Lp>::_S_need_barriers) {
                __atomic_thread_fence(4);
            }
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_weak_count, -1) == 1) {
                ;
                this->_M_destroy();
            }
        }
        void _M_release_last_use_cold() noexcept __attribute__((noinline)) {
            this->_M_release_last_use();
        }
        void _M_weak_add_ref() noexcept {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_weak_count, 1);
        }
        void _M_weak_release() noexcept {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_weak_count, -1) == 1) {
                ;
                if (_Mutex_base<_Lp>::_S_need_barriers) {
                    __atomic_thread_fence(4);
                }
                this->_M_destroy();
            }
        }
        long _M_get_use_count() const noexcept {
            return __atomic_load_n(&this->_M_use_count, 0);
        }
    private:
        _Sp_counted_base<_Lp>(const _Sp_counted_base<_Lp> &) = delete
        _Sp_counted_base<_Lp> &operator=(const _Sp_counted_base<_Lp> &) = delete
        _Atomic_word _M_use_count;
        _Atomic_word _M_weak_count;
    };
    template<> class _Sp_counted_base<__gnu_cxx::_S_single> : public _Mutex_base<(__gnu_cxx::_Lock_policy)0U> {
    public:
        _Sp_counted_base() noexcept;
        virtual ~_Sp_counted_base<__gnu_cxx::_S_single>() noexcept {
        }
        virtual void _M_dispose() noexcept = 0;
        virtual void _M_destroy() noexcept {
            delete this;
        }
        virtual void *_M_get_deleter(const std::type_info &) noexcept = 0;
        void _M_add_ref_copy();
        void _M_add_ref_lock();
        bool _M_add_ref_lock_nothrow() noexcept;
        void _M_release() noexcept;
        void _M_release_last_use() noexcept;
        void _M_release_last_use_cold() noexcept __attribute__((noinline));
        void _M_weak_add_ref() noexcept;
        void _M_weak_release() noexcept;
        long _M_get_use_count() const noexcept;
    private:
        _Sp_counted_base(const std::_Sp_counted_base<__gnu_cxx::_S_single> &) = delete
        std::_Sp_counted_base<__gnu_cxx::_S_single> &operator=(const std::_Sp_counted_base<__gnu_cxx::_S_single> &) = delete
        _Atomic_word _M_use_count;
        _Atomic_word _M_weak_count;
    };
    template<> class _Sp_counted_base<__gnu_cxx::_S_mutex> : public _Mutex_base<(__gnu_cxx::_Lock_policy)1U> {
    public:
        _Sp_counted_base() noexcept;
        virtual ~_Sp_counted_base<__gnu_cxx::_S_mutex>() noexcept {
        }
        virtual void _M_dispose() noexcept = 0;
        virtual void _M_destroy() noexcept {
            delete this;
        }
        virtual void *_M_get_deleter(const std::type_info &) noexcept = 0;
        void _M_add_ref_copy();
        void _M_add_ref_lock();
        bool _M_add_ref_lock_nothrow() noexcept;
        void _M_release() noexcept;
        void _M_release_last_use() noexcept {
            ;
            this->_M_dispose();
            if (_Mutex_base<(_Lock_policy)1U>::_S_need_barriers) {
                __atomic_thread_fence(4);
            }
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_weak_count, -1) == 1) {
                ;
                this->_M_destroy();
            }
        }
        void _M_release_last_use_cold() noexcept __attribute__((noinline));
        void _M_weak_add_ref() noexcept;
        void _M_weak_release() noexcept;
        long _M_get_use_count() const noexcept;
    private:
        _Sp_counted_base(const std::_Sp_counted_base<__gnu_cxx::_S_mutex> &) = delete
        std::_Sp_counted_base<__gnu_cxx::_S_mutex> &operator=(const std::_Sp_counted_base<__gnu_cxx::_S_mutex> &) = delete
        _Atomic_word _M_use_count;
        _Atomic_word _M_weak_count;
    };
    template<> class _Sp_counted_base<__gnu_cxx::_S_atomic> : public _Mutex_base<(__gnu_cxx::_Lock_policy)2U> {
    public:
        _Sp_counted_base() noexcept;
        virtual ~_Sp_counted_base<__gnu_cxx::_S_atomic>() noexcept {
        }
        virtual void _M_dispose() noexcept = 0;
        virtual void _M_destroy() noexcept {
            delete this;
        }
        virtual void *_M_get_deleter(const std::type_info &) noexcept = 0;
        void _M_add_ref_copy();
        void _M_add_ref_lock();
        bool _M_add_ref_lock_nothrow() noexcept;
        void _M_release() noexcept;
        void _M_release_last_use() noexcept {
            ;
            this->_M_dispose();
            if (_Mutex_base<(_Lock_policy)2U>::_S_need_barriers) {
                __atomic_thread_fence(4);
            }
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_weak_count, -1) == 1) {
                ;
                this->_M_destroy();
            }
        }
        void _M_release_last_use_cold() noexcept __attribute__((noinline)) {
            this->_M_release_last_use();
        }
        void _M_weak_add_ref() noexcept;
        void _M_weak_release() noexcept;
        long _M_get_use_count() const noexcept {
            return __atomic_load_n(&this->_M_use_count, 0);
        }
    private:
        _Sp_counted_base(const std::_Sp_counted_base<__gnu_cxx::_S_atomic> &) = delete
        std::_Sp_counted_base<__gnu_cxx::_S_atomic> &operator=(const std::_Sp_counted_base<__gnu_cxx::_S_atomic> &) = delete
        _Atomic_word _M_use_count;
        _Atomic_word _M_weak_count;
    };
    template <> inline bool _Sp_counted_base<_S_single>::_M_add_ref_lock_nothrow() noexcept {
        if (this->_M_use_count == 0)
            return false;
        ++this->_M_use_count;
        return true;
    }
    template <> inline bool _Sp_counted_base<_S_mutex>::_M_add_ref_lock_nothrow() noexcept {
        __gnu_cxx::__scoped_lock sentry(*this);
        if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_use_count, 1) == 0) {
            this->_M_use_count = 0;
            return false;
        }
        return true;
    }
    template <> inline bool _Sp_counted_base<_S_atomic>::_M_add_ref_lock_nothrow() noexcept {
        _Atomic_word __count = this->_M_get_use_count();
        do {
            if (__count == 0)
                return false;
        } while (!__atomic_compare_exchange_n(&this->_M_use_count, &__count, __count + 1, true, 4, 0));
        return true;
    }
    template <> inline void _Sp_counted_base<_S_single>::_M_add_ref_copy() {
        ++this->_M_use_count;
    }
    template <> inline void _Sp_counted_base<_S_single>::_M_release() noexcept {
        if (--this->_M_use_count == 0) {
            this->_M_dispose();
            if (--this->_M_weak_count == 0)
                this->_M_destroy();
        }
    }
    template <> inline void _Sp_counted_base<_S_mutex>::_M_release() noexcept {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_use_count, -1) == 1) {
            this->_M_release_last_use();
        }
    }
    template <> inline void _Sp_counted_base<_S_atomic>::_M_release() noexcept {
        ;
        constexpr bool __lock_free = __atomic_always_lock_free(sizeof(long long), 0) && __atomic_always_lock_free(sizeof(_Atomic_word), 0);
        constexpr bool __double_word = sizeof(long long) == 2 * sizeof(_Atomic_word);
        constexpr bool __aligned = __alignof(long long) <= alignof(void *);
        if (__lock_free && __double_word && __aligned) {
            constexpr int __wordbits = 8 * sizeof(_Atomic_word);
            constexpr int __shiftbits = __double_word ? __wordbits : 0;
            constexpr long long __unique_ref = 1LL + (1LL << __shiftbits);
            auto __both_counts = reinterpret_cast<long long *>(&this->_M_use_count);
            ;
            if (__atomic_load_n(__both_counts, 2) == __unique_ref) {
                this->_M_weak_count = this->_M_use_count = 0;
                ;
                ;
                this->_M_dispose();
                this->_M_destroy();
                return;
            }
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_use_count, -1) == 1)
 [[unlikely]]                {
                    this->_M_release_last_use_cold();
                    return;
                }
        } else if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_use_count, -1) == 1) {
            this->_M_release_last_use();
        }
    }
    template <> inline void _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept {
        ++this->_M_weak_count;
    }
    template <> inline void _Sp_counted_base<_S_single>::_M_weak_release() noexcept {
        if (--this->_M_weak_count == 0)
            this->_M_destroy();
    }
    template <> inline long _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept {
        return this->_M_use_count;
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __shared_ptr;
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __weak_ptr;
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __enable_shared_from_this;
    template <typename _Tp> class shared_ptr;
    template <typename _Tp> class weak_ptr;
    template <typename _Tp> struct owner_less;
    template <typename _Tp> class enable_shared_from_this;
    template <__gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __weak_count;
    template <__gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __shared_count;
    template <typename _Ptr, __gnu_cxx::_Lock_policy _Lp> class final _Sp_counted_ptr : public _Sp_counted_base<_Lp> {
    public:
        explicit _Sp_counted_ptr<_Ptr, _Lp>(_Ptr __p) noexcept : _M_ptr(__p) {
        }
        virtual void _M_dispose() noexcept {
            delete this->_M_ptr;
        }
        virtual void _M_destroy() noexcept {
            delete this;
        }
        virtual void *_M_get_deleter(const std::type_info &) noexcept {
            return nullptr;
        }
        _Sp_counted_ptr<_Ptr, _Lp>(const _Sp_counted_ptr<_Ptr, _Lp> &) = delete
        _Sp_counted_ptr<_Ptr, _Lp> &operator=(const _Sp_counted_ptr<_Ptr, _Lp> &) = delete
    private:
        _Ptr _M_ptr;
    };
    template<> class final _Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_single> : public _Sp_counted_base<(__gnu_cxx::_Lock_policy)0U> {
    public:
        explicit _Sp_counted_ptr(std::nullptr_t __p) noexcept;
        virtual void _M_dispose() noexcept;
        virtual void _M_destroy() noexcept;
        virtual void *_M_get_deleter(const std::type_info &) noexcept;
        _Sp_counted_ptr(const std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_single> &) = delete
        std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_single> &operator=(const std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_single> &) = delete
    private:
        std::nullptr_t _M_ptr;
    };
    template<> class final _Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_mutex> : public _Sp_counted_base<(__gnu_cxx::_Lock_policy)1U> {
    public:
        explicit _Sp_counted_ptr(std::nullptr_t __p) noexcept;
        virtual void _M_dispose() noexcept;
        virtual void _M_destroy() noexcept;
        virtual void *_M_get_deleter(const std::type_info &) noexcept;
        _Sp_counted_ptr(const std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_mutex> &) = delete
        std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_mutex> &operator=(const std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_mutex> &) = delete
    private:
        std::nullptr_t _M_ptr;
    };
    template<> class final _Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_atomic> : public _Sp_counted_base<(__gnu_cxx::_Lock_policy)2U> {
    public:
        explicit _Sp_counted_ptr(std::nullptr_t __p) noexcept;
        virtual void _M_dispose() noexcept;
        virtual void _M_destroy() noexcept;
        virtual void *_M_get_deleter(const std::type_info &) noexcept;
        _Sp_counted_ptr(const std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_atomic> &) = delete
        std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_atomic> &operator=(const std::_Sp_counted_ptr<std::nullptr_t, __gnu_cxx::_S_atomic> &) = delete
    private:
        std::nullptr_t _M_ptr;
    };
    template <> inline void _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept {
    }
    template <> inline void _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept {
    }
    template <> inline void _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept {
    }
    template <int _Nm, typename _Tp, bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)> struct _Sp_ebo_helper;
    template <int _Nm, typename _Tp> struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp {
        explicit _Sp_ebo_helper<_Nm, type-parameter-0-1, true>(const _Tp &__tp) : _Tp(__tp) {
        }
        explicit _Sp_ebo_helper<_Nm, type-parameter-0-1, true>(_Tp &&__tp) : _Tp(std::move(__tp)) {
        }
        static _Tp &_S_get(_Sp_ebo_helper<_Nm, type-parameter-0-1, true> &__eboh) {
            return static_cast<_Tp &>(__eboh);
        }
    };
    template <int _Nm, typename _Tp> struct _Sp_ebo_helper<_Nm, _Tp, false> {
        explicit _Sp_ebo_helper<_Nm, type-parameter-0-1, false>(const _Tp &__tp) : _M_tp(__tp) {
        }
        explicit _Sp_ebo_helper<_Nm, type-parameter-0-1, false>(_Tp &&__tp) : _M_tp(std::move(__tp)) {
        }
        static _Tp &_S_get(_Sp_ebo_helper<_Nm, type-parameter-0-1, false> &__eboh) {
            return __eboh._M_tp;
        }
    private:
        _Tp _M_tp;
    };
    template <typename _Ptr, typename _Deleter, typename _Alloc, __gnu_cxx::_Lock_policy _Lp> class final _Sp_counted_deleter : public _Sp_counted_base<_Lp> {
        class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc> {
            typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
            typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;
        public:
            _Impl(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept : std::_Sp_counted_deleter::_Impl::_Del_base(std::move(__d)), std::_Sp_counted_deleter::_Impl::_Alloc_base(__a), _M_ptr(__p) {
            }
            _Deleter &_M_del() noexcept {
                return _Del_base::_S_get(*this);
            }
            _Alloc &_M_alloc() noexcept {
                return _Alloc_base::_S_get(*this);
            }
            _Ptr _M_ptr;
        };
    public:
        using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>>;
        _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>(_Ptr __p, _Deleter __d) noexcept : _M_impl(__p, std::move(__d), _Alloc()) {
        }
        _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept : _M_impl(__p, std::move(__d), __a) {
        }
        ~_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>() noexcept {
        }
        virtual void _M_dispose() noexcept {
            this->_M_impl._M_del()(this->_M_impl._M_ptr);
        }
        virtual void _M_destroy() noexcept {
            std::_Sp_counted_deleter::__allocator_type __a(this->_M_impl._M_alloc());
            __allocated_ptr<std::_Sp_counted_deleter::__allocator_type> __guard_ptr{__a, this};
            this->~_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>();
        }
        virtual void *_M_get_deleter(const std::type_info &__ti [[gnu::unused]]) noexcept {
            return __ti == typeid(_Deleter) ? std::__addressof(this->_M_impl._M_del()) : nullptr;
        }
    private:
        std::_Sp_counted_deleter::_Impl _M_impl;
    };
    struct _Sp_make_shared_tag {
    private:
        friend template <typename _Tp, typename _Alloc, __gnu_cxx::_Lock_policy _Lp> class _Sp_counted_ptr_inplace;
        static const std::type_info &_S_ti() noexcept __attribute__((visibility("default"))) {
            static constexpr char __tag[16] = {} alignas(alignof(std::type_info));
            return reinterpret_cast<const std::type_info &>(__tag);
        }
        static bool _S_eq(const std::type_info &) noexcept;
    };
    template <typename _Alloc> struct _Sp_alloc_shared_tag {
        const _Alloc &_M_a;
    };
    template<> struct _Sp_alloc_shared_tag<std::allocator<void>> {
        const std::allocator<void> &_M_a;
    };
    template <typename _Tp, typename _Alloc, __gnu_cxx::_Lock_policy _Lp> class final _Sp_counted_ptr_inplace : public _Sp_counted_base<_Lp> {
        class _Impl : _Sp_ebo_helper<0, _Alloc> {
            typedef _Sp_ebo_helper<0, _Alloc> _A_base;
        public:
            explicit _Impl(_Alloc __a) noexcept : std::_Sp_counted_ptr_inplace::_Impl::_A_base(__a) {
            }
            _Alloc &_M_alloc() noexcept {
                return _A_base::_S_get(*this);
            }
            __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
        };
    public:
        using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>>;
        template <typename ..._Args> _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>(_Alloc __a, _Args &&...__args) : _M_impl(__a) {
            allocator_traits<_Alloc>::construct(__a, this->_M_ptr(), std::forward<_Args>(__args)...);
        }
        ~_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>() noexcept {
        }
        virtual void _M_dispose() noexcept {
            allocator_traits<_Alloc>::destroy(this->_M_impl._M_alloc(), this->_M_ptr());
        }
        virtual void _M_destroy() noexcept {
            std::_Sp_counted_ptr_inplace::__allocator_type __a(this->_M_impl._M_alloc());
            __allocated_ptr<std::_Sp_counted_ptr_inplace::__allocator_type> __guard_ptr{__a, this};
            this->~_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>();
        }
    private:
        friend  class __shared_count<_Lp>;
        virtual void *_M_get_deleter(const std::type_info &__ti) noexcept override {
            auto __ptr = const_cast<typename remove_cv<_Tp>::type *>(this->_M_ptr());
            if (&__ti == &_Sp_make_shared_tag::_S_ti() || __ti == typeid(std::_Sp_make_shared_tag))
                return __ptr;
            return nullptr;
        }
        _Tp *_M_ptr() noexcept {
            return this->_M_impl._M_storage._M_ptr();
        }
        std::_Sp_counted_ptr_inplace::_Impl _M_impl;
    };
    struct __sp_array_delete {
        template <typename _Yp> void operator()(_Yp *__p) const {
            delete [] __p;
        }
    };
    template <__gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __shared_count {
        template <typename _Tp> struct __not_alloc_shared_tag {
            using type = void;
        };
        template <typename _Tp> struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> {
        };
    public:
        constexpr __shared_count<_Lp>() noexcept : _M_pi(0) {
        }
        template <typename _Ptr> explicit __shared_count<_Lp>(_Ptr __p) : _M_pi(0) {
            try {
                this->_M_pi = new _Sp_counted_ptr<_Ptr, _Lp>((__p));
            } catch (...) {
                delete __p;
                throw;
            }
        }
        template <typename _Ptr> __shared_count<_Lp>(_Ptr __p, std::false_type) : __shared_count<_Lp>(__p) {
        }
        template <typename _Ptr> __shared_count<_Lp>(_Ptr __p, std::true_type) : __shared_count<_Lp>(__p, std::__sp_array_delete{}, allocator<void>()) {
        }
        template <typename _Ptr, typename _Deleter, typename = typename __not_alloc_shared_tag<_Deleter>::type> __shared_count<_Lp>(_Ptr __p, _Deleter __d) : __shared_count<_Lp>(__p, std::move(__d), allocator<void>()) {
        }
        template <typename _Ptr, typename _Deleter, typename _Alloc, typename = typename __not_alloc_shared_tag<_Deleter>::type> __shared_count<_Lp>(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0) {
            typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
            try {
                typename _Sp_cd_type::__allocator_type __a2(__a);
                auto __guard = std::__allocate_guarded(__a2);
                _Sp_cd_type *__mem = __guard.get();
                ::new (__mem) _Sp_cd_type((__p, std::move(__d), std::move(__a)));
                this->_M_pi = __mem;
                __guard = nullptr;
            } catch (...) {
                __d(__p);
                throw;
            }
        }
        template <typename _Tp, typename _Alloc, typename ..._Args> __shared_count<_Lp>(_Tp *&__p, _Sp_alloc_shared_tag<_Alloc> __a, _Args &&...__args) {
            typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
            typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
            auto __guard = std::__allocate_guarded(__a2);
            _Sp_cp_type *__mem = __guard.get();
            auto __pi = ::new (__mem) _Sp_cp_type((__a._M_a, std::forward<_Args>(__args)...));
            __guard = nullptr;
            this->_M_pi = __pi;
            __p = __pi->_M_ptr();
        }
        template <typename _Tp> explicit __shared_count<_Lp>(std::auto_ptr<_Tp> &&__r);
        template <typename _Tp, typename _Del> explicit __shared_count<_Lp>(std::unique_ptr<_Tp, _Del> &&__r) : _M_pi(0) {
            if (__r.get() == nullptr)
                return;
            using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
            using _Del2 = __conditional_t<is_reference<_Del>::value, reference_wrapper<typename remove_reference<_Del>::type>, _Del>;
            using _Sp_cd_type = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
            using _Alloc = allocator<_Sp_cd_type>;
            using _Alloc_traits = allocator_traits<_Alloc>;
            _Alloc __a;
            _Sp_cd_type *__mem = _Alloc_traits::allocate(__a, 1);
            _Alloc_traits::construct(__a, __mem, __r.release(), std::forward<_Del>(__r.get_deleter()));
            this->_M_pi = __mem;
        }
        explicit __shared_count<_Lp>(const __weak_count<_Lp> &__r);
        explicit __shared_count<_Lp>(const __weak_count<_Lp> &__r, std::nothrow_t) noexcept;
        ~__shared_count<_Lp>() noexcept {
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_release();
        }
        __shared_count<_Lp>(const __shared_count<_Lp> &__r) noexcept : _M_pi(__r._M_pi) {
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_add_ref_copy();
        }
        __shared_count<_Lp> &operator=(const __shared_count<_Lp> &__r) noexcept {
            _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
            if (__tmp != this->_M_pi) {
                if (__tmp != nullptr)
                    __tmp->_M_add_ref_copy();
                if (this->_M_pi != nullptr)
                    this->_M_pi->_M_release();
                this->_M_pi = __tmp;
            }
            return *this;
        }
        void _M_swap(__shared_count<_Lp> &__r) noexcept {
            _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
            __r._M_pi = this->_M_pi;
            this->_M_pi = __tmp;
        }
        long _M_get_use_count() const noexcept {
            return this->_M_pi ? this->_M_pi->_M_get_use_count() : 0;
        }
        bool _M_unique() const noexcept {
            return this->_M_get_use_count() == 1;
        }
        void *_M_get_deleter(const std::type_info &__ti) const noexcept {
            return this->_M_pi ? this->_M_pi->_M_get_deleter(__ti) : nullptr;
        }
        bool _M_less(const __shared_count<_Lp> &__rhs) const noexcept {
            return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
        }
        bool _M_less(const __weak_count<_Lp> &__rhs) const noexcept {
            return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
        }
        friend inline bool operator==(const __shared_count<_Lp> &__a, const __shared_count<_Lp> &__b) noexcept {
            return __a._M_pi == __b._M_pi;
        }
;
    private:
        friend  class __weak_count<_Lp>;
        _Sp_counted_base<_Lp> *_M_pi;
    };
    template <__gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __weak_count {
    public:
        constexpr __weak_count<_Lp>() noexcept : _M_pi(nullptr) {
        }
        __weak_count<_Lp>(const __shared_count<_Lp> &__r) noexcept : _M_pi(__r._M_pi) {
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_weak_add_ref();
        }
        __weak_count<_Lp>(const __weak_count<_Lp> &__r) noexcept : _M_pi(__r._M_pi) {
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_weak_add_ref();
        }
        __weak_count<_Lp>(__weak_count<_Lp> &&__r) noexcept : _M_pi(__r._M_pi) {
            __r._M_pi = nullptr;
        }
        ~__weak_count<_Lp>() noexcept {
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_weak_release();
        }
        __weak_count<_Lp> &operator=(const __shared_count<_Lp> &__r) noexcept {
            _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
            if (__tmp != nullptr)
                __tmp->_M_weak_add_ref();
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_weak_release();
            this->_M_pi = __tmp;
            return *this;
        }
        __weak_count<_Lp> &operator=(const __weak_count<_Lp> &__r) noexcept {
            _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
            if (__tmp != nullptr)
                __tmp->_M_weak_add_ref();
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_weak_release();
            this->_M_pi = __tmp;
            return *this;
        }
        __weak_count<_Lp> &operator=(__weak_count<_Lp> &&__r) noexcept {
            if (this->_M_pi != nullptr)
                this->_M_pi->_M_weak_release();
            this->_M_pi = __r._M_pi;
            __r._M_pi = nullptr;
            return *this;
        }
        void _M_swap(__weak_count<_Lp> &__r) noexcept {
            _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
            __r._M_pi = this->_M_pi;
            this->_M_pi = __tmp;
        }
        long _M_get_use_count() const noexcept {
            return this->_M_pi != nullptr ? this->_M_pi->_M_get_use_count() : 0;
        }
        bool _M_less(const __weak_count<_Lp> &__rhs) const noexcept {
            return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
        }
        bool _M_less(const __shared_count<_Lp> &__rhs) const noexcept {
            return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
        }
        friend inline bool operator==(const __weak_count<_Lp> &__a, const __weak_count<_Lp> &__b) noexcept {
            return __a._M_pi == __b._M_pi;
        }
;
    private:
        friend  class __shared_count<_Lp>;
        _Sp_counted_base<_Lp> *_M_pi;
    };
    template <__gnu_cxx::_Lock_policy _Lp> inline explicit __shared_count<_Lp>::__shared_count<_Lp>(const __weak_count<_Lp> &__r) : _M_pi(__r._M_pi) {
        if (this->_M_pi == nullptr || !this->_M_pi->_M_add_ref_lock_nothrow())
            __throw_bad_weak_ptr();
    }
    template <__gnu_cxx::_Lock_policy _Lp> inline explicit __shared_count<_Lp>::__shared_count<_Lp>(const __weak_count<_Lp> &__r, std::nothrow_t) noexcept : _M_pi(__r._M_pi) {
        if (this->_M_pi && !this->_M_pi->_M_add_ref_lock_nothrow())
            this->_M_pi = nullptr;
    }
    template <typename _Yp_ptr, typename _Tp_ptr> struct __sp_compatible_with : std::false_type {
    };
    template <typename _Yp, typename _Tp> struct __sp_compatible_with<_Yp *, _Tp *> : is_convertible<_Yp *, _Tp *>::type {
    };
    template <typename _Up, std::size_t _Nm> struct __sp_compatible_with<_Up (*)[_Nm], _Up (*)[]> : std::true_type {
    };
    template <typename _Up, std::size_t _Nm> struct __sp_compatible_with<_Up (*)[_Nm], const _Up (*)[]> : std::true_type {
    };
    template <typename _Up, std::size_t _Nm> struct __sp_compatible_with<_Up (*)[_Nm], volatile _Up (*)[]> : std::true_type {
    };
    template <typename _Up, std::size_t _Nm> struct __sp_compatible_with<_Up (*)[_Nm], const volatile _Up (*)[]> : std::true_type {
    };
    template <typename _Up, std::size_t _Nm, typename _Yp, typename = void> struct __sp_is_constructible_arrN : std::false_type {
    };
    template <typename _Up, std::size_t _Nm, typename _Yp> struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>> : is_convertible<_Yp (*)[_Nm], _Up (*)[_Nm]>::type {
    };
    template <typename _Up, typename _Yp, typename = void> struct __sp_is_constructible_arr : std::false_type {
    };
    template <typename _Up, typename _Yp> struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>> : is_convertible<_Yp (*)[], _Up (*)[]>::type {
    };
    template <typename _Tp, typename _Yp> struct __sp_is_constructible;
    template <typename _Up, std::size_t _Nm, typename _Yp> struct __sp_is_constructible<_Up[_Nm], _Yp> : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type {
    };
    template <typename _Up, typename _Yp> struct __sp_is_constructible<_Up[], _Yp> : __sp_is_constructible_arr<_Up, _Yp>::type {
    };
    template <typename _Tp, typename _Yp> struct __sp_is_constructible : is_convertible<_Yp *, _Tp *>::type {
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp, bool = is_array<_Tp>::value, bool = is_void<_Tp>::value> class __shared_ptr_access {
    public:
        using element_type = _Tp;
        std::__shared_ptr_access::element_type &operator*() const noexcept {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_get() != nullptr))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_get();
        }
        std::__shared_ptr_access::element_type *operator->() const noexcept {
            ;
            return this->_M_get();
        }
    private:
        std::__shared_ptr_access::element_type *_M_get() const noexcept {
            return static_cast<const __shared_ptr<_Tp, _Lp> *>(this)->get();
        }
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> class __shared_ptr_access<_Tp, _Lp, false, true> {
    public:
        using element_type = _Tp;
        std::__shared_ptr_access<type-parameter-0-0, _Lp, false, true>::element_type *operator->() const noexcept {
            auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp> *>(this)->get();
            ;
            return __ptr;
        }
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> class __shared_ptr_access<_Tp, _Lp, true, false> {
    public:
        using element_type = typename remove_extent<_Tp>::type;
        std::__shared_ptr_access<type-parameter-0-0, _Lp, true, false>::element_type &operator*() const noexcept [[deprecated("shared_ptr<T[]>::operator* is absent from C++17")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_get() != nullptr))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_get();
        }
        std::__shared_ptr_access<type-parameter-0-0, _Lp, true, false>::element_type *operator->() const noexcept [[deprecated("shared_ptr<T[]>::operator-> is absent from C++17")]] {
            ;
            return this->_M_get();
        }
        std::__shared_ptr_access<type-parameter-0-0, _Lp, true, false>::element_type &operator[](std::ptrdiff_t __i) const noexcept {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_get() != nullptr))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(!extent<_Tp>::value || __i < extent<_Tp>::value))
                    __builtin_unreachable();
            } while (false);
            return this->_M_get()[__i];
        }
    private:
        std::__shared_ptr_access<type-parameter-0-0, _Lp, true, false>::element_type *_M_get() const noexcept {
            return static_cast<const __shared_ptr<_Tp, _Lp> *>(this)->get();
        }
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __shared_ptr : public __shared_ptr_access<_Tp, _Lp> {
    public:
        using element_type = typename remove_extent<_Tp>::type;
    private:
        template <typename _Yp> using _SafeConv = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;
        template <typename _Yp, typename _Res = void> using _Compatible = typename enable_if<__sp_compatible_with<_Yp *, _Tp *>::value, _Res>::type;
        template <typename _Yp> using _Assignable = _Compatible<_Yp, __shared_ptr<_Tp, _Lp> &>;
        template <typename _Yp, typename _Del, typename _Res = void, typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer> using _UniqCompatible = __enable_if_t<__and_<__sp_compatible_with<_Yp *, _Tp *>, is_convertible<_Ptr, element_type *>, is_move_constructible<_Del>>::value, _Res>;
        template <typename _Yp, typename _Del> using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr<_Tp, _Lp> &>;
    public:
        constexpr __shared_ptr<_Tp, _Lp>() noexcept : _M_ptr(0), _M_refcount() {
        }
        template <typename _Yp, typename = _SafeConv<_Yp>> explicit __shared_ptr<_Tp, _Lp>(_Yp *__p) : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type()) {
            static_assert(!is_void<_Yp>::value, "incomplete type");
            static_assert(sizeof(_Yp) > 0, "incomplete type");
            _M_enable_shared_from_this_with(__p);
        }
        template <typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>> __shared_ptr<_Tp, _Lp>(_Yp *__p, _Deleter __d) : _M_ptr(__p), _M_refcount(__p, std::move(__d)) {
            static_assert(__is_invocable<_Deleter &, _Yp *&>::value, "deleter expression d(p) is well-formed");
            _M_enable_shared_from_this_with(__p);
        }
        template <typename _Yp, typename _Deleter, typename _Alloc, typename = _SafeConv<_Yp>> __shared_ptr<_Tp, _Lp>(_Yp *__p, _Deleter __d, _Alloc __a) : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a)) {
            static_assert(__is_invocable<_Deleter &, _Yp *&>::value, "deleter expression d(p) is well-formed");
            _M_enable_shared_from_this_with(__p);
        }
        template <typename _Deleter> __shared_ptr<_Tp, _Lp>(std::nullptr_t __p, _Deleter __d) : _M_ptr(0), _M_refcount(__p, std::move(__d)) {
        }
        template <typename _Deleter, typename _Alloc> __shared_ptr<_Tp, _Lp>(std::nullptr_t __p, _Deleter __d, _Alloc __a) : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a)) {
        }
        template <typename _Yp> __shared_ptr<_Tp, _Lp>(const __shared_ptr<_Yp, _Lp> &__r, std::__shared_ptr::element_type *__p) noexcept : _M_ptr(__p), _M_refcount(__r._M_refcount) {
        }
        template <typename _Yp> __shared_ptr<_Tp, _Lp>(__shared_ptr<_Yp, _Lp> &&__r, std::__shared_ptr::element_type *__p) noexcept : _M_ptr(__p), _M_refcount() {
            this->_M_refcount._M_swap(__r._M_refcount);
            __r._M_ptr = nullptr;
        }
        __shared_ptr<_Tp, _Lp>(const __shared_ptr<_Tp, _Lp> &) noexcept = default
        __shared_ptr<_Tp, _Lp> &operator=(const __shared_ptr<_Tp, _Lp> &) noexcept = default
        ~__shared_ptr<_Tp, _Lp>() = default
        template <typename _Yp, typename = _Compatible<_Yp>> __shared_ptr<_Tp, _Lp>(const __shared_ptr<_Yp, _Lp> &__r) noexcept : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) {
        }
        __shared_ptr<_Tp, _Lp>(__shared_ptr<_Tp, _Lp> &&__r) noexcept : _M_ptr(__r._M_ptr), _M_refcount() {
            this->_M_refcount._M_swap(__r._M_refcount);
            __r._M_ptr = nullptr;
        }
        template <typename _Yp, typename = _Compatible<_Yp>> __shared_ptr<_Tp, _Lp>(__shared_ptr<_Yp, _Lp> &&__r) noexcept : _M_ptr(__r._M_ptr), _M_refcount() {
            this->_M_refcount._M_swap(__r._M_refcount);
            __r._M_ptr = nullptr;
        }
        template <typename _Yp, typename = _Compatible<_Yp>> explicit __shared_ptr<_Tp, _Lp>(const __weak_ptr<_Yp, _Lp> &__r) : _M_refcount(__r._M_refcount) {
            this->_M_ptr = __r._M_ptr;
        }
        template <typename _Yp, typename _Del, typename = _UniqCompatible<_Yp, _Del>> __shared_ptr<_Tp, _Lp>(unique_ptr<_Yp, _Del> &&__r) : _M_ptr(__r.get()), _M_refcount() {
            auto __raw = __to_address(__r.get());
            this->_M_refcount = __shared_count<_Lp>(std::move(__r));
            _M_enable_shared_from_this_with(__raw);
        }
    protected:
        template <typename _Tp1, typename _Del, typename enable_if<__and_<__not_<is_array<_Tp>>, is_array<_Tp1>, is_convertible<typename unique_ptr<_Tp1, _Del>::pointer, _Tp *>>::value, bool>::type = true> __shared_ptr<_Tp, _Lp>(unique_ptr<_Tp1, _Del> &&__r, std::__sp_array_delete) : _M_ptr(__r.get()), _M_refcount() {
            auto __raw = __to_address(__r.get());
            this->_M_refcount = __shared_count<_Lp>(std::move(__r));
            _M_enable_shared_from_this_with(__raw);
        }
    public:
        template <typename _Yp, typename = _Compatible<_Yp>> __shared_ptr<_Tp, _Lp>(auto_ptr<_Yp> &&__r);
        constexpr __shared_ptr<_Tp, _Lp>(std::nullptr_t) noexcept : __shared_ptr<_Tp, _Lp>() {
        }
        template <typename _Yp> _Assignable<_Yp> operator=(const __shared_ptr<_Yp, _Lp> &__r) noexcept {
            this->_M_ptr = __r._M_ptr;
            this->_M_refcount = __r._M_refcount;
            return *this;
        }
        template <typename _Yp> _Assignable<_Yp> operator=(auto_ptr<_Yp> &&__r) {
            __shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
            return *this;
        }
        __shared_ptr<_Tp, _Lp> &operator=(__shared_ptr<_Tp, _Lp> &&__r) noexcept {
            __shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
            return *this;
        }
        template <class _Yp> _Assignable<_Yp> operator=(__shared_ptr<_Yp, _Lp> &&__r) noexcept {
            __shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
            return *this;
        }
        template <typename _Yp, typename _Del> _UniqAssignable<_Yp, _Del> operator=(unique_ptr<_Yp, _Del> &&__r) {
            __shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
            return *this;
        }
        void reset() noexcept {
            __shared_ptr<_Tp, _Lp>().swap(*this);
        }
        template <typename _Yp> _SafeConv<_Yp> reset(_Yp *__p) {
            do {
                if (std::__is_constant_evaluated() && !bool(__p == nullptr || __p != this->_M_ptr))
                    __builtin_unreachable();
            } while (false);
            __shared_ptr<_Tp, _Lp>(__p).swap(*this);
        }
        template <typename _Yp, typename _Deleter> _SafeConv<_Yp> reset(_Yp *__p, _Deleter __d) {
            __shared_ptr<_Tp, _Lp>(__p, std::move(__d)).swap(*this);
        }
        template <typename _Yp, typename _Deleter, typename _Alloc> _SafeConv<_Yp> reset(_Yp *__p, _Deleter __d, _Alloc __a) {
            __shared_ptr<_Tp, _Lp>(__p, std::move(__d), std::move(__a)).swap(*this);
        }
        std::__shared_ptr::element_type *get() const noexcept {
            return this->_M_ptr;
        }
        explicit operator bool() const noexcept {
            return this->_M_ptr != nullptr;
        }
        bool unique() const noexcept {
            return this->_M_refcount._M_unique();
        }
        long use_count() const noexcept {
            return this->_M_refcount._M_get_use_count();
        }
        void swap(__shared_ptr<_Tp, _Lp> &__other) noexcept {
            std::swap(this->_M_ptr, __other._M_ptr);
            this->_M_refcount._M_swap(__other._M_refcount);
        }
        template <typename _Tp1> bool owner_before(const __shared_ptr<_Tp1, _Lp> &__rhs) const noexcept {
            return this->_M_refcount._M_less(__rhs._M_refcount);
        }
        template <typename _Tp1> bool owner_before(const __weak_ptr<_Tp1, _Lp> &__rhs) const noexcept {
            return this->_M_refcount._M_less(__rhs._M_refcount);
        }
    protected:
        template <typename _Alloc, typename ..._Args> __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc> __tag, _Args &&...__args) : _M_ptr(), _M_refcount(this->_M_ptr, __tag, std::forward<_Args>(__args)...) {
            _M_enable_shared_from_this_with(this->_M_ptr);
        }
        friend template <typename _Tp1, __gnu_cxx::_Lock_policy _Lp1, typename _Alloc, typename ..._Args> __shared_ptr<_Tp1, _Lp1> __allocate_shared(const _Alloc &__a, _Args &&...__args);
        __shared_ptr<_Tp, _Lp>(const __weak_ptr<_Tp, _Lp> &__r, std::nothrow_t) noexcept : _M_refcount(__r._M_refcount, std::nothrow) {
            this->_M_ptr = this->_M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
        }
        friend  class __weak_ptr<_Tp, _Lp>;
    private:
        template <typename _Yp> using __esft_base_t = decltype(__enable_shared_from_this_base(std::declval<const __shared_count<_Lp> &>(), std::declval<_Yp *>()));
        template <typename _Yp, typename = void> struct __has_esft_base : std::false_type {
        };
        template <typename _Yp> struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>> : __not_<is_array<_Tp>> {
        };
        template <typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type> typename enable_if<__has_esft_base<_Yp2>::value>::type _M_enable_shared_from_this_with(_Yp *__p) noexcept {
            if (auto __base = __enable_shared_from_this_base(this->_M_refcount, __p))
                __base->_M_weak_assign(const_cast<_Yp2 *>(__p), this->_M_refcount);
        }
        template <typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type> typename enable_if<!__has_esft_base<_Yp2>::value>::type _M_enable_shared_from_this_with(_Yp *) noexcept {
        }
        void *_M_get_deleter(const std::type_info &__ti) const noexcept {
            return this->_M_refcount._M_get_deleter(__ti);
        }
        friend template <typename _Tp1, __gnu_cxx::_Lock_policy _Lp1> class __shared_ptr;
        friend template <typename _Tp1, __gnu_cxx::_Lock_policy _Lp1> class __weak_ptr;
        friend template <typename _Del, typename _Tp1, __gnu_cxx::_Lock_policy _Lp1> _Del *get_deleter(const __shared_ptr<_Tp1, _Lp1> &) noexcept;
        friend template <typename _Del, typename _Tp1> _Del *get_deleter(const shared_ptr<_Tp1> &) noexcept;
        std::__shared_ptr::element_type *_M_ptr;
        __shared_count<_Lp> _M_refcount;
    };
    template <typename _Tp1, typename _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool operator==(const __shared_ptr<_Tp1, _Lp> &__a, const __shared_ptr<_Tp2, _Lp> &__b) noexcept {
        return __a.get() == __b.get();
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator==(const __shared_ptr<_Tp, _Lp> &__a, std::nullptr_t) noexcept {
        return !__a;
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator==(std::nullptr_t, const __shared_ptr<_Tp, _Lp> &__a) noexcept {
        return !__a;
    }
    template <typename _Tp1, typename _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool operator!=(const __shared_ptr<_Tp1, _Lp> &__a, const __shared_ptr<_Tp2, _Lp> &__b) noexcept {
        return __a.get() != __b.get();
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator!=(const __shared_ptr<_Tp, _Lp> &__a, std::nullptr_t) noexcept {
        return (bool)__a;
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator!=(std::nullptr_t, const __shared_ptr<_Tp, _Lp> &__a) noexcept {
        return (bool)__a;
    }
    template <typename _Tp, typename _Up, __gnu_cxx::_Lock_policy _Lp> inline bool operator<(const __shared_ptr<_Tp, _Lp> &__a, const __shared_ptr<_Up, _Lp> &__b) noexcept {
        using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
        using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;
        using _Vp = typename common_type<_Tp_elt *, _Up_elt *>::type;
        return less<_Vp>()(__a.get(), __b.get());
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator<(const __shared_ptr<_Tp, _Lp> &__a, std::nullptr_t) noexcept {
        using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
        return less<_Tp_elt *>()(__a.get(), nullptr);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator<(std::nullptr_t, const __shared_ptr<_Tp, _Lp> &__a) noexcept {
        using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
        return less<_Tp_elt *>()(nullptr, __a.get());
    }
    template <typename _Tp1, typename _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool operator<=(const __shared_ptr<_Tp1, _Lp> &__a, const __shared_ptr<_Tp2, _Lp> &__b) noexcept {
        return !(__b < __a);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator<=(const __shared_ptr<_Tp, _Lp> &__a, std::nullptr_t) noexcept {
        return !(nullptr < __a);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator<=(std::nullptr_t, const __shared_ptr<_Tp, _Lp> &__a) noexcept {
        return !(__a < nullptr);
    }
    template <typename _Tp1, typename _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool operator>(const __shared_ptr<_Tp1, _Lp> &__a, const __shared_ptr<_Tp2, _Lp> &__b) noexcept {
        return (__b < __a);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator>(const __shared_ptr<_Tp, _Lp> &__a, std::nullptr_t) noexcept {
        return nullptr < __a;
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator>(std::nullptr_t, const __shared_ptr<_Tp, _Lp> &__a) noexcept {
        return __a < nullptr;
    }
    template <typename _Tp1, typename _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool operator>=(const __shared_ptr<_Tp1, _Lp> &__a, const __shared_ptr<_Tp2, _Lp> &__b) noexcept {
        return !(__a < __b);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator>=(const __shared_ptr<_Tp, _Lp> &__a, std::nullptr_t) noexcept {
        return !(__a < nullptr);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool operator>=(std::nullptr_t, const __shared_ptr<_Tp, _Lp> &__a) noexcept {
        return !(nullptr < __a);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline void swap(__shared_ptr<_Tp, _Lp> &__a, __shared_ptr<_Tp, _Lp> &__b) noexcept {
        __a.swap(__b);
    }
    template <typename _Tp, typename _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr<_Tp, _Lp> static_pointer_cast(const __shared_ptr<_Tp1, _Lp> &__r) noexcept {
        using _Sp = __shared_ptr<_Tp, _Lp>;
        return _Sp(__r, static_cast<typename _Sp::element_type *>(__r.get()));
    }
    template <typename _Tp, typename _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr<_Tp, _Lp> const_pointer_cast(const __shared_ptr<_Tp1, _Lp> &__r) noexcept {
        using _Sp = __shared_ptr<_Tp, _Lp>;
        return _Sp(__r, const_cast<typename _Sp::element_type *>(__r.get()));
    }
    template <typename _Tp, typename _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr<_Tp, _Lp> dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp> &__r) noexcept {
        using _Sp = __shared_ptr<_Tp, _Lp>;
        if (auto *__p = dynamic_cast<typename _Sp::element_type *>(__r.get()))
            return _Sp(__r, __p);
        return _Sp();
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __weak_ptr {
        template <typename _Yp, typename _Res = void> using _Compatible = typename enable_if<__sp_compatible_with<_Yp *, _Tp *>::value, _Res>::type;
        template <typename _Yp> using _Assignable = _Compatible<_Yp, __weak_ptr<_Tp, _Lp> &>;
    public:
        using element_type = typename remove_extent<_Tp>::type;
        constexpr __weak_ptr<_Tp, _Lp>() noexcept : _M_ptr(nullptr), _M_refcount() {
        }
        __weak_ptr<_Tp, _Lp>(const __weak_ptr<_Tp, _Lp> &) noexcept = default
        ~__weak_ptr<_Tp, _Lp>() = default
        template <typename _Yp, typename = _Compatible<_Yp>> __weak_ptr<_Tp, _Lp>(const __weak_ptr<_Yp, _Lp> &__r) noexcept : _M_refcount(__r._M_refcount) {
            this->_M_ptr = __r.lock().get();
        }
        template <typename _Yp, typename = _Compatible<_Yp>> __weak_ptr<_Tp, _Lp>(const __shared_ptr<_Yp, _Lp> &__r) noexcept : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) {
        }
        __weak_ptr<_Tp, _Lp>(__weak_ptr<_Tp, _Lp> &&__r) noexcept : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount)) {
            __r._M_ptr = nullptr;
        }
        template <typename _Yp, typename = _Compatible<_Yp>> __weak_ptr<_Tp, _Lp>(__weak_ptr<_Yp, _Lp> &&__r) noexcept : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount)) {
            __r._M_ptr = nullptr;
        }
        __weak_ptr<_Tp, _Lp> &operator=(const __weak_ptr<_Tp, _Lp> &__r) noexcept = default
        template <typename _Yp> _Assignable<_Yp> operator=(const __weak_ptr<_Yp, _Lp> &__r) noexcept {
            this->_M_ptr = __r.lock().get();
            this->_M_refcount = __r._M_refcount;
            return *this;
        }
        template <typename _Yp> _Assignable<_Yp> operator=(const __shared_ptr<_Yp, _Lp> &__r) noexcept {
            this->_M_ptr = __r._M_ptr;
            this->_M_refcount = __r._M_refcount;
            return *this;
        }
        __weak_ptr<_Tp, _Lp> &operator=(__weak_ptr<_Tp, _Lp> &&__r) noexcept {
            this->_M_ptr = __r._M_ptr;
            this->_M_refcount = std::move(__r._M_refcount);
            __r._M_ptr = nullptr;
            return *this;
        }
        template <typename _Yp> _Assignable<_Yp> operator=(__weak_ptr<_Yp, _Lp> &&__r) noexcept {
            this->_M_ptr = __r.lock().get();
            this->_M_refcount = std::move(__r._M_refcount);
            __r._M_ptr = nullptr;
            return *this;
        }
        __shared_ptr<_Tp, _Lp> lock() const noexcept {
            return __shared_ptr<std::__weak_ptr::element_type, _Lp>(*this, std::nothrow);
        }
        long use_count() const noexcept {
            return this->_M_refcount._M_get_use_count();
        }
        bool expired() const noexcept {
            return this->_M_refcount._M_get_use_count() == 0;
        }
        template <typename _Tp1> bool owner_before(const __shared_ptr<_Tp1, _Lp> &__rhs) const noexcept {
            return this->_M_refcount._M_less(__rhs._M_refcount);
        }
        template <typename _Tp1> bool owner_before(const __weak_ptr<_Tp1, _Lp> &__rhs) const noexcept {
            return this->_M_refcount._M_less(__rhs._M_refcount);
        }
        void reset() noexcept {
            __weak_ptr<_Tp, _Lp>().swap(*this);
        }
        void swap(__weak_ptr<_Tp, _Lp> &__s) noexcept {
            std::swap(this->_M_ptr, __s._M_ptr);
            this->_M_refcount._M_swap(__s._M_refcount);
        }
    private:
        void _M_assign(_Tp *__ptr, const __shared_count<_Lp> &__refcount) noexcept {
            if (this->use_count() == 0) {
                this->_M_ptr = __ptr;
                this->_M_refcount = __refcount;
            }
        }
        friend template <typename _Tp1, __gnu_cxx::_Lock_policy _Lp1> class __shared_ptr;
        friend template <typename _Tp1, __gnu_cxx::_Lock_policy _Lp1> class __weak_ptr;
        friend  class __enable_shared_from_this<_Tp, _Lp>;
        friend  class enable_shared_from_this<_Tp>;
        std::__weak_ptr::element_type *_M_ptr;
        __weak_count<_Lp> _M_refcount;
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline void swap(__weak_ptr<_Tp, _Lp> &__a, __weak_ptr<_Tp, _Lp> &__b) noexcept {
        __a.swap(__b);
    }
    template <typename _Tp, typename _Tp1> struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool> {
        bool operator()(const _Tp &__lhs, const _Tp &__rhs) const noexcept {
            return __lhs.owner_before(__rhs);
        }
        bool operator()(const _Tp &__lhs, const _Tp1 &__rhs) const noexcept {
            return __lhs.owner_before(__rhs);
        }
        bool operator()(const _Tp1 &__lhs, const _Tp &__rhs) const noexcept {
            return __lhs.owner_before(__rhs);
        }
    };
    template<> struct _Sp_owner_less<void, void> {
        template <typename _Tp, typename _Up> auto operator()(const _Tp &__lhs, const _Up &__rhs) const noexcept -> decltype(__lhs.owner_before(__rhs)) {
            return __lhs.owner_before(__rhs);
        }
        using is_transparent = void;
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> struct owner_less<__shared_ptr<_Tp, _Lp>> : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>> {
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> struct owner_less<__weak_ptr<_Tp, _Lp>> : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>> {
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy> class __enable_shared_from_this {
    protected:
        constexpr __enable_shared_from_this<_Tp, _Lp>() noexcept {
        }
        __enable_shared_from_this<_Tp, _Lp>(const __enable_shared_from_this<_Tp, _Lp> &) noexcept {
        }
        __enable_shared_from_this<_Tp, _Lp> &operator=(const __enable_shared_from_this<_Tp, _Lp> &) noexcept {
            return *this;
        }
        ~__enable_shared_from_this<_Tp, _Lp>() {
        }
    public:
        __shared_ptr<_Tp, _Lp> shared_from_this() {
            return __shared_ptr<_Tp, _Lp>(this->_M_weak_this);
        }
        __shared_ptr<const _Tp, _Lp> shared_from_this() const {
            return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this);
        }
        __weak_ptr<_Tp, _Lp> weak_from_this() noexcept {
            return this->_M_weak_this;
        }
        __weak_ptr<const _Tp, _Lp> weak_from_this() const noexcept {
            return this->_M_weak_this;
        }
    private:
        template <typename _Tp1> void _M_weak_assign(_Tp1 *__p, const __shared_count<_Lp> &__n) const noexcept {
            this->_M_weak_this._M_assign(__p, __n);
        }
        friend const __enable_shared_from_this<_Tp, _Lp> *__enable_shared_from_this_base(const __shared_count<_Lp> &, const __enable_shared_from_this<_Tp, _Lp> *__p) {
            return __p;
        }
;
        friend template <typename, __gnu_cxx::_Lock_policy> class __shared_ptr;
        mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy, typename _Alloc, typename ..._Args> inline __shared_ptr<_Tp, _Lp> __allocate_shared(const _Alloc &__a, _Args &&...__args) {
        static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
        return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>({__a}), std::forward<_Args>(__args)...);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp = __default_lock_policy, typename ..._Args> inline __shared_ptr<_Tp, _Lp> __make_shared(_Args &&...__args) {
        typedef typename std::remove_const<_Tp>::type _Tp_nc;
        return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(), std::forward<_Args>(__args)...);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> struct hash<__shared_ptr<_Tp, _Lp>> : public __hash_base<std::size_t, __shared_ptr<_Tp, _Lp>> {
        std::size_t operator()(const __shared_ptr<_Tp, _Lp> &__s) const noexcept {
            return hash<typename __shared_ptr<_Tp, _Lp>::element_type *>()(__s.get());
        }
    };
}
namespace std {
    template <typename _Ch, typename _Tr, typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline std::basic_ostream<_Ch, _Tr> &operator<<(std::basic_ostream<_Ch, _Tr> &__os, const __shared_ptr<_Tp, _Lp> &__p) {
        __os << __p.get();
        return __os;
    }
    template <typename _Del, typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline _Del *get_deleter(const __shared_ptr<_Tp, _Lp> &__p) noexcept {
        return static_cast<_Del *>(__p._M_get_deleter(typeid(_Del)));
    }
    template <typename _Del, typename _Tp> inline _Del *get_deleter(const shared_ptr<_Tp> &__p) noexcept {
        return static_cast<_Del *>(__p._M_get_deleter(typeid(_Del)));
    }
    template <typename _Tp> using _NonArray = __enable_if_t<!is_array<_Tp>::value, _Tp>;
    template <typename _Tp> class shared_ptr : public __shared_ptr<_Tp> {
        template <typename ..._Args> using _Constructible = typename enable_if<is_constructible<__shared_ptr<_Tp>, _Args...>::value>::type;
        template <typename _Arg> using _Assignable = typename enable_if<is_assignable<__shared_ptr<_Tp> &, _Arg>::value, shared_ptr<_Tp> &>::type;
    public:
        using element_type = typename __shared_ptr<_Tp>::element_type;
        constexpr shared_ptr<_Tp>() noexcept : __shared_ptr<_Tp>() {
        }
        shared_ptr<_Tp>(const shared_ptr<_Tp> &) noexcept = default
        template <typename _Yp, typename = _Constructible<_Yp *>> explicit shared_ptr<_Tp>(_Yp *__p) : __shared_ptr<_Tp>(__p) {
        }
        template <typename _Yp, typename _Deleter, typename = _Constructible<_Yp *, _Deleter>> shared_ptr<_Tp>(_Yp *__p, _Deleter __d) : __shared_ptr<_Tp>(__p, std::move(__d)) {
        }
        template <typename _Deleter> shared_ptr<_Tp>(std::nullptr_t __p, _Deleter __d) : __shared_ptr<_Tp>(__p, std::move(__d)) {
        }
        template <typename _Yp, typename _Deleter, typename _Alloc, typename = _Constructible<_Yp *, _Deleter, _Alloc>> shared_ptr<_Tp>(_Yp *__p, _Deleter __d, _Alloc __a) : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) {
        }
        template <typename _Deleter, typename _Alloc> shared_ptr<_Tp>(std::nullptr_t __p, _Deleter __d, _Alloc __a) : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) {
        }
        template <typename _Yp> shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, std::shared_ptr::element_type *__p) noexcept : __shared_ptr<_Tp>(__r, __p) {
        }
        template <typename _Yp, typename = _Constructible<const shared_ptr<_Yp> &>> shared_ptr<_Tp>(const shared_ptr<_Yp> &__r) noexcept : __shared_ptr<_Tp>(__r) {
        }
        shared_ptr<_Tp>(shared_ptr<_Tp> &&__r) noexcept : __shared_ptr<_Tp>(std::move(__r)) {
        }
        template <typename _Yp, typename = _Constructible<shared_ptr<_Yp>>> shared_ptr<_Tp>(shared_ptr<_Yp> &&__r) noexcept : __shared_ptr<_Tp>(std::move(__r)) {
        }
        template <typename _Yp, typename = _Constructible<const weak_ptr<_Yp> &>> explicit shared_ptr<_Tp>(const weak_ptr<_Yp> &__r) : __shared_ptr<_Tp>(__r) {
        }
        template <typename _Yp, typename = _Constructible<auto_ptr<_Yp>>> shared_ptr<_Tp>(auto_ptr<_Yp> &&__r);
        template <typename _Yp, typename _Del, typename = _Constructible<unique_ptr<_Yp, _Del>>> shared_ptr<_Tp>(unique_ptr<_Yp, _Del> &&__r) : __shared_ptr<_Tp>(std::move(__r)) {
        }
        template <typename _Yp, typename _Del, _Constructible<unique_ptr<_Yp, _Del>, std::__sp_array_delete> * = 0> shared_ptr<_Tp>(unique_ptr<_Yp, _Del> &&__r) : __shared_ptr<_Tp>(std::move(__r), std::__sp_array_delete()) {
        }
        constexpr shared_ptr<_Tp>(std::nullptr_t) noexcept : shared_ptr<_Tp>() {
        }
        shared_ptr<_Tp> &operator=(const shared_ptr<_Tp> &) noexcept = default
        template <typename _Yp> _Assignable<const shared_ptr<_Yp> &> operator=(const shared_ptr<_Yp> &__r) noexcept {
            this->__shared_ptr<_Tp>::operator=(__r);
            return *this;
        }
        template <typename _Yp> _Assignable<auto_ptr<_Yp>> operator=(auto_ptr<_Yp> &&__r) {
            this->__shared_ptr<_Tp>::operator=(std::move(__r));
            return *this;
        }
        shared_ptr<_Tp> &operator=(shared_ptr<_Tp> &&__r) noexcept {
            this->__shared_ptr<_Tp>::operator=(std::move(__r));
            return *this;
        }
        template <class _Yp> _Assignable<shared_ptr<_Yp>> operator=(shared_ptr<_Yp> &&__r) noexcept {
            this->__shared_ptr<_Tp>::operator=(std::move(__r));
            return *this;
        }
        template <typename _Yp, typename _Del> _Assignable<unique_ptr<_Yp, _Del>> operator=(unique_ptr<_Yp, _Del> &&__r) {
            this->__shared_ptr<_Tp>::operator=(std::move(__r));
            return *this;
        }
    private:
        template <typename _Alloc, typename ..._Args> shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc> __tag, _Args &&...__args) : __shared_ptr<_Tp>(__tag, std::forward<_Args>(__args)...) {
        }
        friend template <typename _Yp, typename _Alloc, typename ..._Args> shared_ptr<_NonArray<_Yp>> allocate_shared(const _Alloc &, _Args &&...);
        friend template <typename _Yp, typename ..._Args> shared_ptr<_NonArray<_Yp>> make_shared(_Args &&...);
        shared_ptr<_Tp>(const weak_ptr<_Tp> &__r, std::nothrow_t) noexcept : __shared_ptr<_Tp>(__r, std::nothrow) {
        }
        friend  class weak_ptr<_Tp>;
    };
    template <typename _Tp, typename _Up> inline bool operator==(const shared_ptr<_Tp> &__a, const shared_ptr<_Up> &__b) noexcept {
        return __a.get() == __b.get();
    }
    template <typename _Tp> inline bool operator==(const shared_ptr<_Tp> &__a, std::nullptr_t) noexcept {
        return !__a;
    }
    template <typename _Tp> inline bool operator==(std::nullptr_t, const shared_ptr<_Tp> &__a) noexcept {
        return !__a;
    }
    template <typename _Tp, typename _Up> inline bool operator!=(const shared_ptr<_Tp> &__a, const shared_ptr<_Up> &__b) noexcept {
        return __a.get() != __b.get();
    }
    template <typename _Tp> inline bool operator!=(const shared_ptr<_Tp> &__a, std::nullptr_t) noexcept {
        return (bool)__a;
    }
    template <typename _Tp> inline bool operator!=(std::nullptr_t, const shared_ptr<_Tp> &__a) noexcept {
        return (bool)__a;
    }
    template <typename _Tp, typename _Up> inline bool operator<(const shared_ptr<_Tp> &__a, const shared_ptr<_Up> &__b) noexcept {
        using _Tp_elt = typename shared_ptr<_Tp>::element_type;
        using _Up_elt = typename shared_ptr<_Up>::element_type;
        using _Vp = typename common_type<_Tp_elt *, _Up_elt *>::type;
        return less<_Vp>()(__a.get(), __b.get());
    }
    template <typename _Tp> inline bool operator<(const shared_ptr<_Tp> &__a, std::nullptr_t) noexcept {
        using _Tp_elt = typename shared_ptr<_Tp>::element_type;
        return less<_Tp_elt *>()(__a.get(), nullptr);
    }
    template <typename _Tp> inline bool operator<(std::nullptr_t, const shared_ptr<_Tp> &__a) noexcept {
        using _Tp_elt = typename shared_ptr<_Tp>::element_type;
        return less<_Tp_elt *>()(nullptr, __a.get());
    }
    template <typename _Tp, typename _Up> inline bool operator<=(const shared_ptr<_Tp> &__a, const shared_ptr<_Up> &__b) noexcept {
        return !(__b < __a);
    }
    template <typename _Tp> inline bool operator<=(const shared_ptr<_Tp> &__a, std::nullptr_t) noexcept {
        return !(nullptr < __a);
    }
    template <typename _Tp> inline bool operator<=(std::nullptr_t, const shared_ptr<_Tp> &__a) noexcept {
        return !(__a < nullptr);
    }
    template <typename _Tp, typename _Up> inline bool operator>(const shared_ptr<_Tp> &__a, const shared_ptr<_Up> &__b) noexcept {
        return (__b < __a);
    }
    template <typename _Tp> inline bool operator>(const shared_ptr<_Tp> &__a, std::nullptr_t) noexcept {
        return nullptr < __a;
    }
    template <typename _Tp> inline bool operator>(std::nullptr_t, const shared_ptr<_Tp> &__a) noexcept {
        return __a < nullptr;
    }
    template <typename _Tp, typename _Up> inline bool operator>=(const shared_ptr<_Tp> &__a, const shared_ptr<_Up> &__b) noexcept {
        return !(__a < __b);
    }
    template <typename _Tp> inline bool operator>=(const shared_ptr<_Tp> &__a, std::nullptr_t) noexcept {
        return !(__a < nullptr);
    }
    template <typename _Tp> inline bool operator>=(std::nullptr_t, const shared_ptr<_Tp> &__a) noexcept {
        return !(nullptr < __a);
    }
    template <typename _Tp> inline void swap(shared_ptr<_Tp> &__a, shared_ptr<_Tp> &__b) noexcept {
        __a.swap(__b);
    }
    template <typename _Tp, typename _Up> inline shared_ptr<_Tp> static_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
        using _Sp = shared_ptr<_Tp>;
        return _Sp(__r, static_cast<typename _Sp::element_type *>(__r.get()));
    }
    template <typename _Tp, typename _Up> inline shared_ptr<_Tp> const_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
        using _Sp = shared_ptr<_Tp>;
        return _Sp(__r, const_cast<typename _Sp::element_type *>(__r.get()));
    }
    template <typename _Tp, typename _Up> inline shared_ptr<_Tp> dynamic_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
        using _Sp = shared_ptr<_Tp>;
        if (auto *__p = dynamic_cast<typename _Sp::element_type *>(__r.get()))
            return _Sp(__r, __p);
        return _Sp();
    }
    template <typename _Tp> class weak_ptr : public __weak_ptr<_Tp> {
        template <typename _Arg> using _Constructible = typename enable_if<is_constructible<__weak_ptr<_Tp>, _Arg>::value>::type;
        template <typename _Arg> using _Assignable = typename enable_if<is_assignable<__weak_ptr<_Tp> &, _Arg>::value, weak_ptr<_Tp> &>::type;
    public:
        weak_ptr<_Tp>() noexcept = default
        template <typename _Yp, typename = _Constructible<const shared_ptr<_Yp> &>> weak_ptr<_Tp>(const shared_ptr<_Yp> &__r) noexcept : __weak_ptr<_Tp>(__r) {
        }
        weak_ptr<_Tp>(const weak_ptr<_Tp> &) noexcept = default
        template <typename _Yp, typename = _Constructible<const weak_ptr<_Yp> &>> weak_ptr<_Tp>(const weak_ptr<_Yp> &__r) noexcept : __weak_ptr<_Tp>(__r) {
        }
        weak_ptr<_Tp>(weak_ptr<_Tp> &&) noexcept = default
        template <typename _Yp, typename = _Constructible<weak_ptr<_Yp>>> weak_ptr<_Tp>(weak_ptr<_Yp> &&__r) noexcept : __weak_ptr<_Tp>(std::move(__r)) {
        }
        weak_ptr<_Tp> &operator=(const weak_ptr<_Tp> &__r) noexcept = default
        template <typename _Yp> _Assignable<const weak_ptr<_Yp> &> operator=(const weak_ptr<_Yp> &__r) noexcept {
            this->__weak_ptr<_Tp>::operator=(__r);
            return *this;
        }
        template <typename _Yp> _Assignable<const shared_ptr<_Yp> &> operator=(const shared_ptr<_Yp> &__r) noexcept {
            this->__weak_ptr<_Tp>::operator=(__r);
            return *this;
        }
        weak_ptr<_Tp> &operator=(weak_ptr<_Tp> &&__r) noexcept = default
        template <typename _Yp> _Assignable<weak_ptr<_Yp>> operator=(weak_ptr<_Yp> &&__r) noexcept {
            this->__weak_ptr<_Tp>::operator=(std::move(__r));
            return *this;
        }
        shared_ptr<_Tp> lock() const noexcept {
            return shared_ptr<_Tp>(*this, std::nothrow);
        }
    };
    template <typename _Tp> inline void swap(weak_ptr<_Tp> &__a, weak_ptr<_Tp> &__b) noexcept {
        __a.swap(__b);
    }
    template <typename _Tp = void> struct owner_less;
    template<> struct owner_less<void> : _Sp_owner_less<void, void> {
    };
    template <typename _Tp> struct owner_less<shared_ptr<_Tp>> : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>> {
    };
    template <typename _Tp> struct owner_less<weak_ptr<_Tp>> : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>> {
    };
    template <typename _Tp> class enable_shared_from_this {
    protected:
        constexpr enable_shared_from_this<_Tp>() noexcept {
        }
        enable_shared_from_this<_Tp>(const enable_shared_from_this<_Tp> &) noexcept {
        }
        enable_shared_from_this<_Tp> &operator=(const enable_shared_from_this<_Tp> &) noexcept {
            return *this;
        }
        ~enable_shared_from_this<_Tp>() {
        }
    public:
        shared_ptr<_Tp> shared_from_this() {
            return shared_ptr<_Tp>(this->_M_weak_this);
        }
        shared_ptr<const _Tp> shared_from_this() const {
            return shared_ptr<const _Tp>(this->_M_weak_this);
        }
        weak_ptr<_Tp> weak_from_this() noexcept {
            return this->_M_weak_this;
        }
        weak_ptr<const _Tp> weak_from_this() const noexcept {
            return this->_M_weak_this;
        }
    private:
        template <typename _Tp1> void _M_weak_assign(_Tp1 *__p, const __shared_count<> &__n) const noexcept {
            this->_M_weak_this._M_assign(__p, __n);
        }
        friend const enable_shared_from_this<_Tp> *__enable_shared_from_this_base(const __shared_count<> &, const enable_shared_from_this<_Tp> *__p) {
            return __p;
        }
;
        friend template <typename, __gnu_cxx::_Lock_policy> class __shared_ptr;
        mutable weak_ptr<_Tp> _M_weak_this;
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> inline shared_ptr<_NonArray<_Tp>> allocate_shared(const _Alloc &__a, _Args &&...__args) {
        return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>({__a}), std::forward<_Args>(__args)...);
    }
    template <typename _Tp, typename ..._Args> inline shared_ptr<_NonArray<_Tp>> make_shared(_Args &&...__args) {
        using _Alloc = allocator<void>;
        _Alloc __a;
        return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a}, std::forward<_Args>(__args)...);
    }
    template <typename _Tp> struct hash<shared_ptr<_Tp>> : public __hash_base<std::size_t, shared_ptr<_Tp>> {
        std::size_t operator()(const shared_ptr<_Tp> &__s) const noexcept {
            return std::hash<typename shared_ptr<_Tp>::element_type *>()(__s.get());
        }
    };
}
namespace std {
    typedef enum memory_order {
        memory_order_relaxed,
        memory_order_consume,
        memory_order_acquire,
        memory_order_release,
        memory_order_acq_rel,
        memory_order_seq_cst
    } memory_order;
    enum __memory_order_modifier {
        __memory_order_mask = 65535,
        __memory_order_modifier_mask = 4294901760U,
        __memory_order_hle_acquire = 65536,
        __memory_order_hle_release = 131072
    };
    constexpr std::memory_order operator|(std::memory_order __m, std::__memory_order_modifier __mod) {
        return std::memory_order(int(__m) | int(__mod));
    }
    constexpr std::memory_order operator&(std::memory_order __m, std::__memory_order_modifier __mod) {
        return std::memory_order(int(__m) & int(__mod));
    }
    constexpr std::memory_order __cmpexch_failure_order2(std::memory_order __m) noexcept {
        return __m == memory_order_acq_rel ? memory_order_acquire : __m == memory_order_release ? memory_order_relaxed : __m;
    }
    constexpr std::memory_order __cmpexch_failure_order(std::memory_order __m) noexcept {
        return std::memory_order(__cmpexch_failure_order2(__m & __memory_order_mask) | std::__memory_order_modifier(__m & __memory_order_modifier_mask));
    }
    constexpr bool __is_valid_cmpexch_failure_order(std::memory_order __m) noexcept {
        return (__m & __memory_order_mask) != memory_order_release && (__m & __memory_order_mask) != memory_order_acq_rel;
    }
    inline void atomic_thread_fence(std::memory_order __m) noexcept __attribute__((always_inline)) {
        __atomic_thread_fence(int(__m));
    }
    inline void atomic_signal_fence(std::memory_order __m) noexcept __attribute__((always_inline)) {
        __atomic_signal_fence(int(__m));
    }
    template <typename _Tp> inline _Tp kill_dependency(_Tp __y) noexcept {
        _Tp __ret(__y);
        return __ret;
    }
    template <typename _IntTp> struct __atomic_base;
    template <typename _Tp> struct atomic;
    template <typename _Tp> struct atomic<_Tp *>;
    typedef bool __atomic_flag_data_type;
    extern "C" {
        struct __atomic_flag_base {
            std::__atomic_flag_data_type _M_i;
        };
    }
    struct atomic_flag : public std::__atomic_flag_base {
        atomic_flag() noexcept = default
        ~atomic_flag() noexcept = default
        atomic_flag(const std::atomic_flag &) = delete
        std::atomic_flag &operator=(const std::atomic_flag &) = delete
        std::atomic_flag &operator=(const std::atomic_flag &) volatile = delete
        constexpr atomic_flag(bool __i) noexcept : std::__atomic_flag_base({_S_init(__i)}) {
        }
        inline bool test_and_set(std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_test_and_set(&this->_M_i, int(__m));
        }
        inline bool test_and_set(std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_test_and_set(&this->_M_i, int(__m));
        }
        inline void clear(std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_consume))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acquire))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            __atomic_clear(&this->_M_i, int(__m));
        }
        inline void clear(std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_consume))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acquire))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            __atomic_clear(&this->_M_i, int(__m));
        }
    private:
        static constexpr std::__atomic_flag_data_type _S_init(bool __i) {
            return __i ? 1 : 0;
        }
    };
    template <typename _ITp> struct __atomic_base {
        using value_type = _ITp;
        using difference_type = std::__atomic_base::value_type;
    private:
        typedef _ITp __int_type;
        static constexpr int _S_alignment = sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);
        std::__atomic_base::__int_type _M_i alignas(_S_alignment);
    public:
        __atomic_base<_IntTp>() noexcept = default
        ~__atomic_base<_IntTp>() noexcept = default
        __atomic_base<_IntTp>(const __atomic_base<_IntTp> &) = delete
        __atomic_base<_IntTp> &operator=(const __atomic_base<_IntTp> &) = delete
        __atomic_base<_IntTp> &operator=(const __atomic_base<_IntTp> &) volatile = delete
        constexpr __atomic_base<_IntTp>(std::__atomic_base::__int_type __i) noexcept : _M_i(__i) {
        }
        operator __int_type() const noexcept {
            return load();
        }
        operator __int_type() const volatile noexcept {
            return load();
        }
        std::__atomic_base::__int_type operator=(std::__atomic_base::__int_type __i) noexcept {
            store(__i);
            return __i;
        }
        std::__atomic_base::__int_type operator=(std::__atomic_base::__int_type __i) volatile noexcept {
            store(__i);
            return __i;
        }
        std::__atomic_base::__int_type operator++(int) noexcept {
            return fetch_add(1);
        }
        std::__atomic_base::__int_type operator++(int) volatile noexcept {
            return fetch_add(1);
        }
        std::__atomic_base::__int_type operator--(int) noexcept {
            return fetch_sub(1);
        }
        std::__atomic_base::__int_type operator--(int) volatile noexcept {
            return fetch_sub(1);
        }
        std::__atomic_base::__int_type operator++() noexcept {
            return __atomic_add_fetch(& this->_M_i, 1, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator++() volatile noexcept {
            return __atomic_add_fetch(& this->_M_i, 1, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator--() noexcept {
            return __atomic_sub_fetch(& this->_M_i, 1, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator--() volatile noexcept {
            return __atomic_sub_fetch(& this->_M_i, 1, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator+=(std::__atomic_base::__int_type __i) noexcept {
            return __atomic_add_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator+=(std::__atomic_base::__int_type __i) volatile noexcept {
            return __atomic_add_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator-=(std::__atomic_base::__int_type __i) noexcept {
            return __atomic_sub_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator-=(std::__atomic_base::__int_type __i) volatile noexcept {
            return __atomic_sub_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator&=(std::__atomic_base::__int_type __i) noexcept {
            return __atomic_and_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator&=(std::__atomic_base::__int_type __i) volatile noexcept {
            return __atomic_and_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator|=(std::__atomic_base::__int_type __i) noexcept {
            return __atomic_or_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator|=(std::__atomic_base::__int_type __i) volatile noexcept {
            return __atomic_or_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator^=(std::__atomic_base::__int_type __i) noexcept {
            return __atomic_xor_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        std::__atomic_base::__int_type operator^=(std::__atomic_base::__int_type __i) volatile noexcept {
            return __atomic_xor_fetch(& this->_M_i, __i, int(memory_order_seq_cst));
        }
        bool is_lock_free() const noexcept {
            return __atomic_is_lock_free(sizeof (this->_M_i), reinterpret_cast<void *>(-_S_alignment));
        }
        bool is_lock_free() const volatile noexcept {
            return __atomic_is_lock_free(sizeof (this->_M_i), reinterpret_cast<void *>(-_S_alignment));
        }
        inline void store(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acquire))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_consume))
                    __builtin_unreachable();
            } while (false);
            __atomic_store_n(& this->_M_i, __i, int(__m));
        }
        inline void store(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acquire))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_consume))
                    __builtin_unreachable();
            } while (false);
            __atomic_store_n(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type load(std::memory_order __m = memory_order_seq_cst) const noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_release))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            return __atomic_load_n(& this->_M_i, int(__m));
        }
        inline std::__atomic_base::__int_type load(std::memory_order __m = memory_order_seq_cst) const volatile noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_release))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            return __atomic_load_n(& this->_M_i, int(__m));
        }
        inline std::__atomic_base::__int_type exchange(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_exchange_n(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type exchange(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_exchange_n(& this->_M_i, __i, int(__m));
        }
        inline bool compare_exchange_weak(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m1, std::memory_order __m2) noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_i, & __i1, __i2, 1, int(__m1), int(__m2));
        }
        inline bool compare_exchange_weak(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m1, std::memory_order __m2) volatile noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_i, & __i1, __i2, 1, int(__m1), int(__m2));
        }
        inline bool compare_exchange_weak(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return compare_exchange_weak(__i1, __i2, __m, __cmpexch_failure_order(__m));
        }
        inline bool compare_exchange_weak(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return compare_exchange_weak(__i1, __i2, __m, __cmpexch_failure_order(__m));
        }
        inline bool compare_exchange_strong(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m1, std::memory_order __m2) noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_i, & __i1, __i2, 0, int(__m1), int(__m2));
        }
        inline bool compare_exchange_strong(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m1, std::memory_order __m2) volatile noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_i, & __i1, __i2, 0, int(__m1), int(__m2));
        }
        inline bool compare_exchange_strong(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return compare_exchange_strong(__i1, __i2, __m, __cmpexch_failure_order(__m));
        }
        inline bool compare_exchange_strong(std::__atomic_base::__int_type &__i1, std::__atomic_base::__int_type __i2, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return compare_exchange_strong(__i1, __i2, __m, __cmpexch_failure_order(__m));
        }
        inline std::__atomic_base::__int_type fetch_add(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_fetch_add(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_add(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_fetch_add(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_sub(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_fetch_sub(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_sub(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_fetch_sub(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_and(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_fetch_and(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_and(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_fetch_and(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_or(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_fetch_or(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_or(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_fetch_or(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_xor(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_fetch_xor(& this->_M_i, __i, int(__m));
        }
        inline std::__atomic_base::__int_type fetch_xor(std::__atomic_base::__int_type __i, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_fetch_xor(& this->_M_i, __i, int(__m));
        }
    };
    template <typename _PTp> struct __atomic_base<_PTp *> {
    private:
        typedef _PTp *__pointer_type;
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type _M_p;
        constexpr std::ptrdiff_t _M_type_size(std::ptrdiff_t __d) const {
            return __d * sizeof(_PTp);
        }
        constexpr std::ptrdiff_t _M_type_size(std::ptrdiff_t __d) const volatile {
            return __d * sizeof(_PTp);
        }
    public:
        __atomic_base<type-parameter-0-0 *>() noexcept = default
        ~__atomic_base<type-parameter-0-0 *>() noexcept = default
        __atomic_base<type-parameter-0-0 *>(const __atomic_base<type-parameter-0-0 *> &) = delete
        __atomic_base<type-parameter-0-0 *> &operator=(const __atomic_base<type-parameter-0-0 *> &) = delete
        __atomic_base<type-parameter-0-0 *> &operator=(const __atomic_base<type-parameter-0-0 *> &) volatile = delete
        constexpr __atomic_base<type-parameter-0-0 *>(std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p) noexcept : _M_p(__p) {
        }
        operator __pointer_type() const noexcept {
            return load();
        }
        operator __pointer_type() const volatile noexcept {
            return load();
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator=(std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p) noexcept {
            store(__p);
            return __p;
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator=(std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p) volatile noexcept {
            store(__p);
            return __p;
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator++(int) noexcept {
            return fetch_add(1);
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator++(int) volatile noexcept {
            return fetch_add(1);
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator--(int) noexcept {
            return fetch_sub(1);
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator--(int) volatile noexcept {
            return fetch_sub(1);
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator++() noexcept {
            return __atomic_add_fetch(& this->_M_p, _M_type_size(1), int(memory_order_seq_cst));
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator++() volatile noexcept {
            return __atomic_add_fetch(& this->_M_p, _M_type_size(1), int(memory_order_seq_cst));
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator--() noexcept {
            return __atomic_sub_fetch(& this->_M_p, _M_type_size(1), int(memory_order_seq_cst));
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator--() volatile noexcept {
            return __atomic_sub_fetch(& this->_M_p, _M_type_size(1), int(memory_order_seq_cst));
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator+=(std::ptrdiff_t __d) noexcept {
            return __atomic_add_fetch(& this->_M_p, _M_type_size(__d), int(memory_order_seq_cst));
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator+=(std::ptrdiff_t __d) volatile noexcept {
            return __atomic_add_fetch(& this->_M_p, _M_type_size(__d), int(memory_order_seq_cst));
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator-=(std::ptrdiff_t __d) noexcept {
            return __atomic_sub_fetch(& this->_M_p, _M_type_size(__d), int(memory_order_seq_cst));
        }
        std::__atomic_base<type-parameter-0-0 *>::__pointer_type operator-=(std::ptrdiff_t __d) volatile noexcept {
            return __atomic_sub_fetch(& this->_M_p, _M_type_size(__d), int(memory_order_seq_cst));
        }
        bool is_lock_free() const noexcept {
            return __atomic_is_lock_free(sizeof (this->_M_p), reinterpret_cast<void *>(-__alignof (this->_M_p)));
        }
        bool is_lock_free() const volatile noexcept {
            return __atomic_is_lock_free(sizeof (this->_M_p), reinterpret_cast<void *>(-__alignof (this->_M_p)));
        }
        inline void store(std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acquire))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_consume))
                    __builtin_unreachable();
            } while (false);
            __atomic_store_n(& this->_M_p, __p, int(__m));
        }
        inline void store(std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acquire))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_consume))
                    __builtin_unreachable();
            } while (false);
            __atomic_store_n(& this->_M_p, __p, int(__m));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type load(std::memory_order __m = memory_order_seq_cst) const noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_release))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            return __atomic_load_n(& this->_M_p, int(__m));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type load(std::memory_order __m = memory_order_seq_cst) const volatile noexcept __attribute__((always_inline)) {
            std::memory_order __b = __m & __memory_order_mask __attribute__((unused));
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_release))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__b != memory_order_acq_rel))
                    __builtin_unreachable();
            } while (false);
            return __atomic_load_n(& this->_M_p, int(__m));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type exchange(std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_exchange_n(& this->_M_p, __p, int(__m));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type exchange(std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_exchange_n(& this->_M_p, __p, int(__m));
        }
        inline bool compare_exchange_weak(std::__atomic_base<type-parameter-0-0 *>::__pointer_type &__p1, std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p2, std::memory_order __m1, std::memory_order __m2) noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_p, & __p1, __p2, 1, int(__m1), int(__m2));
        }
        inline bool compare_exchange_weak(std::__atomic_base<type-parameter-0-0 *>::__pointer_type &__p1, std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p2, std::memory_order __m1, std::memory_order __m2) volatile noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_p, & __p1, __p2, 1, int(__m1), int(__m2));
        }
        inline bool compare_exchange_strong(std::__atomic_base<type-parameter-0-0 *>::__pointer_type &__p1, std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p2, std::memory_order __m1, std::memory_order __m2) noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_p, & __p1, __p2, 0, int(__m1), int(__m2));
        }
        inline bool compare_exchange_strong(std::__atomic_base<type-parameter-0-0 *>::__pointer_type &__p1, std::__atomic_base<type-parameter-0-0 *>::__pointer_type __p2, std::memory_order __m1, std::memory_order __m2) volatile noexcept __attribute__((always_inline)) {
            do {
                if (std::__is_constant_evaluated() && !bool(__is_valid_cmpexch_failure_order(__m2)))
                    __builtin_unreachable();
            } while (false);
            return __atomic_compare_exchange_n(& this->_M_p, & __p1, __p2, 0, int(__m1), int(__m2));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type fetch_add(std::ptrdiff_t __d, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_fetch_add(& this->_M_p, _M_type_size(__d), int(__m));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type fetch_add(std::ptrdiff_t __d, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_fetch_add(& this->_M_p, _M_type_size(__d), int(__m));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type fetch_sub(std::ptrdiff_t __d, std::memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) {
            return __atomic_fetch_sub(& this->_M_p, _M_type_size(__d), int(__m));
        }
        inline std::__atomic_base<type-parameter-0-0 *>::__pointer_type fetch_sub(std::ptrdiff_t __d, std::memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) {
            return __atomic_fetch_sub(& this->_M_p, _M_type_size(__d), int(__m));
        }
    };
}
namespace std {
    struct _Sp_locker {
        _Sp_locker(const std::_Sp_locker &) = delete
        std::_Sp_locker &operator=(const std::_Sp_locker &) = delete
        explicit _Sp_locker(const void *) noexcept;
        _Sp_locker(const void *, const void *) noexcept;
        ~_Sp_locker() noexcept;
    private:
        unsigned char _M_key1;
        unsigned char _M_key2;
    };
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool atomic_is_lock_free(const __shared_ptr<_Tp, _Lp> *__p) {
        return __gthread_active_p() == 0;
    }
    template <typename _Tp> inline bool atomic_is_lock_free(const shared_ptr<_Tp> *__p) {
        return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p);
    }
    template <typename _Tp> inline shared_ptr<_Tp> atomic_load_explicit(const shared_ptr<_Tp> *__p, std::memory_order) {
        std::_Sp_locker __lock{__p};
        return *__p;
    }
    template <typename _Tp> inline shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp> *__p) {
        return std::atomic_load_explicit(__p, memory_order_seq_cst);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr<_Tp, _Lp> atomic_load_explicit(const __shared_ptr<_Tp, _Lp> *__p, std::memory_order) {
        std::_Sp_locker __lock{__p};
        return *__p;
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr<_Tp, _Lp> atomic_load(const __shared_ptr<_Tp, _Lp> *__p) {
        return std::atomic_load_explicit(__p, memory_order_seq_cst);
    }
    template <typename _Tp> inline void atomic_store_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, std::memory_order) {
        std::_Sp_locker __lock{__p};
        __p->swap(__r);
    }
    template <typename _Tp> inline void atomic_store(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) {
        std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline void atomic_store_explicit(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> __r, std::memory_order) {
        std::_Sp_locker __lock{__p};
        __p->swap(__r);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline void atomic_store(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> __r) {
        std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst);
    }
    template <typename _Tp> inline shared_ptr<_Tp> atomic_exchange_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, std::memory_order) {
        std::_Sp_locker __lock{__p};
        __p->swap(__r);
        return __r;
    }
    template <typename _Tp> inline shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) {
        return std::atomic_exchange_explicit(__p, std::move(__r), memory_order_seq_cst);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr<_Tp, _Lp> atomic_exchange_explicit(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> __r, std::memory_order) {
        std::_Sp_locker __lock{__p};
        __p->swap(__r);
        return __r;
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr<_Tp, _Lp> atomic_exchange(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> __r) {
        return std::atomic_exchange_explicit(__p, std::move(__r), memory_order_seq_cst);
    }
    template <typename _Tp> bool atomic_compare_exchange_strong_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w, std::memory_order, std::memory_order) {
        shared_ptr<_Tp> __x;
        std::_Sp_locker __lock{__p, __v};
        owner_less<shared_ptr<_Tp>> __less;
        if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p)) {
            __x = std::move(*__p);
            *__p = std::move(__w);
            return true;
        }
        __x = std::move(*__v);
        *__v = *__p;
        return false;
    }
    template <typename _Tp> inline bool atomic_compare_exchange_strong(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w) {
        return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }
    template <typename _Tp> inline bool atomic_compare_exchange_weak_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w, std::memory_order __success, std::memory_order __failure) {
        return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), __success, __failure);
    }
    template <typename _Tp> inline bool atomic_compare_exchange_weak(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w) {
        return std::atomic_compare_exchange_weak_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> bool atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> *__v, __shared_ptr<_Tp, _Lp> __w, std::memory_order, std::memory_order) {
        __shared_ptr<_Tp, _Lp> __x;
        std::_Sp_locker __lock{__p, __v};
        owner_less<__shared_ptr<_Tp, _Lp>> __less;
        if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p)) {
            __x = std::move(*__p);
            *__p = std::move(__w);
            return true;
        }
        __x = std::move(*__v);
        *__v = *__p;
        return false;
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> *__v, __shared_ptr<_Tp, _Lp> __w) {
        return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> *__v, __shared_ptr<_Tp, _Lp> __w, std::memory_order __success, std::memory_order __failure) {
        return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), __success, __failure);
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp> *__p, __shared_ptr<_Tp, _Lp> *__v, __shared_ptr<_Tp, _Lp> __w) {
        return std::atomic_compare_exchange_weak_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }
}
namespace std {
    template <typename _Tp1> struct __attribute__((deprecated(""))) auto_ptr_ref {
        _Tp1 *_M_ptr;
        explicit auto_ptr_ref<_Tp1>(_Tp1 *__p) : _M_ptr(__p) {
        }
    };
    template <typename _Tp> class __attribute__((deprecated("use 'std::unique_ptr' instead"))) auto_ptr {
    private:
        _Tp *_M_ptr;
    public:
        typedef _Tp element_type;
        explicit auto_ptr<type-parameter-0-0>(std::auto_ptr::element_type *__p = 0) throw() : _M_ptr(__p) {
        }
        auto_ptr<type-parameter-0-0>(auto_ptr<type-parameter-0-0> &__a) throw() : _M_ptr(__a.release()) {
        }
        template <typename _Tp1> auto_ptr<type-parameter-0-0>(auto_ptr<_Tp1> &__a) throw() : _M_ptr(__a.release()) {
        }
        auto_ptr<type-parameter-0-0> &operator=(auto_ptr<type-parameter-0-0> &__a) throw() {
            this->reset(__a.release());
            return *this;
        }
        template <typename _Tp1> auto_ptr<type-parameter-0-0> &operator=(auto_ptr<_Tp1> &__a) throw() {
            this->reset(__a.release());
            return *this;
        }
        ~auto_ptr<type-parameter-0-0>() {
            delete this->_M_ptr;
        }
        std::auto_ptr::element_type &operator*() const throw() {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_ptr != 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_ptr;
        }
        std::auto_ptr::element_type *operator->() const throw() {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_ptr != 0))
                    __builtin_unreachable();
            } while (false);
            return this->_M_ptr;
        }
        std::auto_ptr::element_type *get() const throw() {
            return this->_M_ptr;
        }
        std::auto_ptr::element_type *release() throw() {
            std::auto_ptr::element_type *__tmp = this->_M_ptr;
            this->_M_ptr = 0;
            return __tmp;
        }
        void reset(std::auto_ptr::element_type *__p = 0) throw() {
            if (__p != this->_M_ptr) {
                delete this->_M_ptr;
                this->_M_ptr = __p;
            }
        }
        auto_ptr<type-parameter-0-0>(auto_ptr_ref<std::auto_ptr::element_type> __ref) throw() : _M_ptr(__ref._M_ptr) {
        }
        auto_ptr<type-parameter-0-0> &operator=(auto_ptr_ref<std::auto_ptr::element_type> __ref) throw() {
            if (__ref._M_ptr != this->get()) {
                delete this->_M_ptr;
                this->_M_ptr = __ref._M_ptr;
            }
            return *this;
        }
        template <typename _Tp1> operator auto_ptr_ref<_Tp1>() throw() {
            return auto_ptr_ref<_Tp1>(this->release());
        }
        template <typename _Tp1> operator auto_ptr<_Tp1>() throw() {
            return auto_ptr<_Tp1>(this->release());
        }
    };
    template<> class __attribute__((deprecated(""))) auto_ptr<void> {
    public:
        typedef void element_type;
    };
    template <__gnu_cxx::_Lock_policy _Lp> template <typename _Tp> inline explicit __shared_count<_Lp>::__shared_count<_Lp>(std::auto_ptr<_Tp> &&__r) : _M_pi(new _Sp_counted_ptr<_Tp *, _Lp>((__r.get()))) {
        __r.release();
    }
    template <typename _Tp, __gnu_cxx::_Lock_policy _Lp> template <typename _Tp1, typename = _Compatible<_Yp>> inline __shared_ptr<_Tp, _Lp>::__shared_ptr<_Tp, _Lp>(std::auto_ptr<_Tp1> &&__r) : _M_ptr(__r.get()), _M_refcount() {
        static_assert(sizeof(_Tp1) > 0, "incomplete type");
        _Tp1 *__tmp = __r.get();
        this->_M_refcount = __shared_count<_Lp>(std::move(__r));
        _M_enable_shared_from_this_with(__tmp);
    }
    template <typename _Tp> template <typename _Tp1, typename = _Constructible<auto_ptr<_Yp>>> inline shared_ptr<_Tp>::shared_ptr<_Tp>(std::auto_ptr<_Tp1> &&__r) : __shared_ptr<_Tp>(std::move(__r)) {
    }
    template <typename _Tp, typename _Dp> template <typename _Up, typename = _Require<is_convertible<_Up *, _Tp *>, is_same<_Dp, default_delete<_Tp>>>> inline unique_ptr<_Tp, _Dp>::unique_ptr<_Tp, _Dp>(auto_ptr<_Up> &&__u) noexcept : _M_t(__u.release(), std::unique_ptr::deleter_type()) {
    }
}
namespace std {
    enum class pointer_safety : int {
        relaxed,
        preferred,
        strict
    };
    inline void declare_reachable(void *) {
    }
    template <typename _Tp> inline _Tp *undeclare_reachable(_Tp *__p) {
        return __p;
    }
    inline void declare_no_pointers(char *, std::size_t) {
    }
    inline void undeclare_no_pointers(char *, std::size_t) {
    }
    inline std::pointer_safety get_pointer_safety() noexcept {
        return pointer_safety::relaxed;
    }
}
class Scott : public std::false_type {
public:
    std::string signature() const {
        return "Scott";
    }
};
class David : public std::true_type {
public:
    std::string signature() const {
        return "David";
    }
};
class Mario : public std::false_type {
public:
    std::string signature() const {
        return "Mario";
    }
};
template <typename Test, typename T = void> using EnableIf = typename std::enable_if_t<Test::value, T>;
template <typename Test, typename T = void> using DisableIf = typename std::enable_if_t<!Test::value, T>;
template <typename T> struct Filter : public T {
    static constexpr bool isDavid = T::value;
};
template<> struct Filter<Scott> : public Scott {
    static constexpr bool isDavid = Scott::value;
};
template<> struct Filter<David> : public David {
    static constexpr bool isDavid = David::value;
};
template<> struct Filter<Mario> : public Mario {
    static constexpr bool isDavid = Mario::value;
};
class Message {
public:
    template <class ...Filter> Message(Filter ...filter) {
        _impl<0>(filter...);
    }
    template<> Message<<Filter<Scott>, Filter<David>, Filter<Mario>>>(Filter<Scott> filter, Filter<David> filter, Filter<Mario> filter) {
        this->_impl<0>(filter, filter, filter);
    }
private:
    template <size_t I> void _impl() {
        std::cout << "who call it? I=" << I << std::endl;
    }
    template <size_t I, typename Filter, typename = std::enable_if_t<!Filter::isDavid>> void _impl(Filter &filter) {
        std::cout << I << ": " << filter.signature() << std::endl;
    }
    template<> void _impl<0UL, Filter<Scott>, void>(Filter<Scott> &filter) {
        std::cout << 0UL << ": " << filter.signature() << std::endl;
    }
    template<> void _impl<2UL, Filter<Mario>, void>(Filter<Mario> &filter) {
        std::cout << 2UL << ": " << filter.signature() << std::endl;
    }
    template <size_t I, typename Filter, typename SomeType = std::enable_if_t<Filter::isDavid, int>> void _impl(Filter &filter, SomeType *i = nullptr) {
        std::cout << I << ": SEPECIAL CASE : " << filter.signature() << std::endl;
    }
    template<> void _impl<1UL, Filter<David>, int>(Filter<David> &filter, int *i = nullptr) {
        std::cout << 1UL << ": SEPECIAL CASE : " << filter.signature() << std::endl;
    }
    template <size_t I, typename Filter, typename ...Filters> void _impl(Filter &filter, Filters ...filters) {
        _impl<I>(filter);
        _impl<I + 1>(filters...);
    }
    template<> void _impl<0UL, Filter<Scott>, <Filter<David>, Filter<Mario>>>(Filter<Scott> &filter, Filter<David> filters, Filter<Mario> filters) {
        this->_impl<0UL>(filter);
        this->_impl<0UL + 1>(filters, filters);
    }
    template<> void _impl<0UL, Filter<Scott>, <>>(Filter<Scott> &filter)    template<> void _impl<1UL, Filter<David>, <Filter<Mario>>>(Filter<David> &filter, Filter<Mario> filters) {
        this->_impl<1UL>(filter);
        this->_impl<1UL + 1>(filters);
    }
    template<> void _impl<1UL, Filter<David>, <>>(Filter<David> &filter)    template<> void _impl<2UL, Filter<Mario>, <>>(Filter<Mario> &filter)};
void bbegin();
Filter<Scott> st0;
Filter<David> st1;
Filter<Mario> st2;
Message m(st0, st1, st2);
void eend();
int main() {
    std::cout << utility::typeInfo(st0) << std::endl;
    std::cout << utility::typeInfo(st1) << std::endl;
    std::cout << utility::typeInfo(st2) << std::endl;
    return 0;
}
